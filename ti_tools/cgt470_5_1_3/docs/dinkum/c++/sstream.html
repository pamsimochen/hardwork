<HTML><HEAD><TITLE>&lt;sstream&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;sstream&gt;"><CODE>&lt;sstream&gt;</CODE></A></H1><HR>

<P>Include the <A HREF="lib_cpp.html#iostreams">iostreams</A>
standard header <B><CODE>&lt;sstream&gt;</CODE></B>
to define several template classes that support
iostreams operations on
sequences stored in an allocated array object.
Such sequences are easily converted to and from objects of
template class
<CODE><A HREF="string2.html#basic_string">basic_string</A></CODE>.</P>

<PRE>namespace std {
template&lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B><A HREF="#basic_stringbuf">basic_stringbuf</A></B>;
typedef basic_stringbuf&lt;char&gt; <B><A HREF="#stringbuf">stringbuf</A></B>;
typedef basic_stringbuf&lt;wchar_t&gt; <B><A HREF="#wstringbuf">wstringbuf</A></B>;
template&lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B><A HREF="#basic_istringstream">basic_istringstream</A></B>;
typedef basic_istringstream&lt;char&gt; <B><A HREF="#istringstream">istringstream</A></B>;
typedef basic_istringstream&lt;wchar_t&gt; <B><A HREF="#wistringstream">wistringstream</A></B>;
template&lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B><A HREF="#basic_ostringstream">basic_ostringstream</A></B>;
typedef basic_ostringstream&lt;char&gt; <B><A HREF="#ostringstream">ostringstream</A></B>;
typedef basic_ostringstream&lt;wchar_t&gt; <B><A HREF="#wostringstream">wostringstream</A></B>;
template&lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B><A HREF="#basic_stringstream">basic_stringstream</A></B>;
typedef basic_stringstream&lt;char&gt; <B><A HREF="#stringstream">stringstream</A></B>;
typedef basic_stringstream&lt;wchar_t&gt; <B><A HREF="#wstringstream">wstringstream</A></B>;
    };</PRE>

<H2><A NAME="basic_stringbuf"><CODE>basic_stringbuf</CODE></A></H2>

<PRE>template &lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B>basic_stringbuf</B>
        : public basic_streambuf&lt;Elem, Tr&gt; {
public:
    typedef typename basic_streambuf&lt;Elem, Tr&gt;::char_type
        char_type;
    typedef typename basic_streambuf&lt;Elem, Tr&gt;::traits_type
        traits_type;
    typedef typename basic_streambuf&lt;Elem, Tr&gt;::int_type
        int_type;
    typedef typename basic_streambuf&lt;Elem, Tr&gt;::pos_type
        pos_type;
    typedef typename basic_streambuf&lt;Elem, Tr&gt;::off_type
        off_type;
    typedef Alloc <B><A HREF="#basic_stringbuf::allocator_type">allocator_type</A></B>;
    <B><A HREF="#basic_stringbuf::basic_stringbuf">basic_stringbuf</A></B>(ios_base::openmode mode =
        ios_base::in | ios_base::out);
    <B><A HREF="#basic_stringbuf::basic_stringbuf">basic_stringbuf</A></B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
        ios_base::openmode mode =
            ios_base::in | ios_base::out);
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#basic_stringbuf::str">str</A></B>() const;
    void <B><A HREF="#basic_stringbuf::str">str</A></B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);
protected:
    virtual pos_type <B><A HREF="#basic_stringbuf::seekoff">seekoff</A></B>(off_type off,
        ios_base::seekdir way,
        ios_base::openmode mode =
            ios_base::in | ios_base::out);
    virtual pos_type <B><A HREF="#basic_stringbuf::seekpos">seekpos</A></B>(pos_type sp,
        ios_base::openmode mode =
            ios_base::in | ios_base::out);
    virtual int_type <B><A HREF="#basic_stringbuf::underflow">underflow</A></B>();
    virtual int_type <B><A HREF="#basic_stringbuf::pbackfail">pbackfail</A></B>(int_type meta =
        traits_type::eof());
    virtual int_type <B><A HREF="#basic_stringbuf::overflow">overflow</A></B>(int_type meta =
        traits_type::eof());
    };</PRE>

<P>The template class
describes a <B><A HREF="streambu.html#stream buffer">stream buffer</A></B> that controls
the transmission of elements
of type <CODE>Elem</CODE>, whose
<A HREF="string2.html#character traits">character traits</A> are determined by the
class <CODE>Tr</CODE>,
to and from a sequence of elements
stored in an array object. The object is allocated, extended, and
freed as necessary to accommodate changes in the sequence.</P>

<P>An object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>
stores a copy of the
<CODE>ios_base::<A HREF="ios.html#ios_base::openmode">openmode</A></CODE>
argument from its constructor as its
<B><A NAME="stringbuf mode">stringbuf mode</A></B> <CODE>mode</CODE>:</P>

<UL>
<LI>If <CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base::in">in</A></CODE> is nonzero,
the <A HREF="streambu.html#input buffer">input buffer</A>
is accessible.</LI>

<LI>If <CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base::out">out</A></CODE> is nonzero,
the <A HREF="streambu.html#output buffer">output buffer</A>
is accessible.</LI>
</UL>

<H3><A NAME="basic_stringbuf::allocator_type"><CODE>basic_stringbuf::allocator_type</CODE></A></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><A NAME="basic_stringbuf::basic_stringbuf"><CODE>basic_stringbuf::basic_stringbuf</CODE></A></H3>

<PRE><B>basic_stringbuf</B>(ios_base::openmode mode =
    ios_base::in | ios_base::out);
<B>basic_stringbuf</B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
    ios_base::openmode mode =
        ios_base::in | ios_base::out);</PRE>

<P>The first constructor stores a null pointer in all the pointers
controlling the
<A HREF="streambu.html#input buffer">input buffer</A> and the
<A HREF="streambu.html#output buffer">output buffer</A>. It
also stores <CODE>mode</CODE> as the
<A HREF="#stringbuf mode">stringbuf mode</A>.</P>

<P>The second constructor allocates a copy of the sequence controlled
by the string object <CODE>str</CODE>.
If <CODE>mode &amp; ios_base::in</CODE> is nonzero,
it sets the input buffer to begin reading
at the start of the sequence.
If <CODE>mode &amp; ios_base::out</CODE> is nonzero,
it sets the output buffer to begin
writing at the start of the sequence.
It also stores <CODE>mode</CODE> as the
<A HREF="#stringbuf mode">stringbuf mode</A>.</P>

<H3><A NAME="basic_stringbuf::char_type"><CODE>basic_stringbuf::char_type</CODE></A></H3>

<PRE>typedef Elem <B>char_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Elem</CODE>.</P>

<H3><A NAME="basic_stringbuf::int_type"><CODE>basic_stringbuf::int_type</CODE></A></H3>

<PRE>typedef typename traits_type::int_type <B>int_type</B>;</PRE>

<P>The type is a synonym for
<CODE>traits_type::<A HREF="string2.html#char_traits::int_type">int_type</A></CODE>.</P>

<H3><A NAME="basic_stringbuf::off_type"><CODE>basic_stringbuf::off_type</CODE></A></H3>

<PRE>typedef typename traits_type::off_type <B>off_type</B>;</PRE>

<P>The type is a synonym for
<CODE>traits_type::<A HREF="string2.html#char_traits::off_type">off_type</A></CODE>.</P>

<H3><A NAME="basic_stringbuf::overflow"><CODE>basic_stringbuf::overflow</CODE></A></H3>

<PRE>virtual int_type <B>overflow</B>(int_type meta =
    traits_type::eof());</PRE>

<P>If <CODE>meta</CODE> does not compare equal to
<CODE>traits_type::<A HREF="string2.html#char_traits::eof">eof</A>()</CODE>,
the protected virtual member function endeavors to insert the element
<CODE>traits_type::<A HREF="string2.html#char_traits::to_char_type">to_char_type</A>(meta)</CODE>
into the
<A HREF="streambu.html#output buffer">output buffer</A>.
It can do so in various ways:</P>

<UL>
<LI>If a <A HREF="streambu.html#write position">write position</A>
is available, it can store the element into the write position
and increment the next pointer for the output buffer.</LI>

<LI>It can make a write position available by allocating
new or additional storage for the output buffer. (Extending the
output buffer this way also extends any associated
<A HREF="streambu.html#input buffer">input buffer</A>.)</LI>
</UL>

<P>If the function cannot succeed, it returns <CODE>traits_type::eof()</CODE>.
Otherwise, it returns
<CODE>traits_type::<A HREF="string2.html#char_traits::not_eof">not_eof</A>(meta)</CODE>.</P>

<H3><A NAME="basic_stringbuf::pbackfail"><CODE>basic_stringbuf::pbackfail</CODE></A></H3>

<PRE>virtual int_type <B>pbackfail</B>(int_type meta =
    traits_type::eof());</PRE>

<P>The protected virtual member function endeavors to put back an element
into the
<A HREF="streambu.html#input buffer">input buffer</A>,
then make it the current element (pointed to
by the next pointer).
If <CODE>meta</CODE> compares equal to
<CODE>traits_type::<A HREF="string2.html#char_traits::eof">eof</A>()</CODE>,
the element to push back is effectively the one already in the stream
before the current element. Otherwise, that element is replaced by
<CODE>byte =
traits_type::<A HREF="string2.html#char_traits::to_char_type">to_char_type</A>(meta)</CODE>.
The function can put back an element in various ways:</P>

<UL>
<LI>If a <A HREF="streambu.html#putback position">putback position</A>
is available, and the element stored there compares equal to <CODE>byte</CODE>,
it can simply decrement the next pointer for the input buffer.</LI>

<LI>If a putback position is available,
and if the <A HREF="#stringbuf mode">stringbuf mode</A> permits
the sequence to be altered (<CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base::out">out</A></CODE> is nonzero),
it can store <CODE>byte</CODE> into the putback position and decrement the
next pointer for the input buffer.</LI>
</UL>

<P>If the function cannot succeed, it returns
<CODE>traits_type::eof()</CODE>. Otherwise, it returns
<CODE>traits_type::<A HREF="string2.html#char_traits::not_eof">not_eof</A>(meta)</CODE>.</P>

<H3><A NAME="basic_stringbuf::pos_type"><CODE>basic_stringbuf::pos_type</CODE></A></H3>

<PRE>typedef typename traits_type::pos_type <B>pos_type</B>;</PRE>

<P>The type is a synonym for
<CODE>traits_type::<A HREF="string2.html#char_traits::pos_type">pos_type</A></CODE>.</P>

<H3><A NAME="basic_stringbuf::seekoff"><CODE>basic_stringbuf::seekoff</CODE></A></H3>

<PRE>virtual pos_type <B>seekoff</B>(off_type off,
    ios_base::seekdir way,
    ios_base::openmode mode =
        ios_base::in | ios_base::out);</PRE>

<P>The protected virtual member function endeavors to alter the current
positions for the controlled streams. For an object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>,
a stream position consists
purely of a stream offset. Offset zero designates the first element
of the controlled sequence.</P>

<P>The new position is determined as follows:</P>

<UL>
<LI>If <CODE>way ==
ios_base::<A HREF="ios.html#ios_base::beg">beg</A></CODE>,
the new position is the beginning of the stream plus <CODE>off</CODE>.

<LI>If <CODE>way ==
ios_base::<A HREF="ios.html#ios_base::cur">cur</A></CODE>,
the new position is the current stream position plus <CODE>off</CODE>.

<LI>If <CODE>way ==
ios_base::<A HREF="ios.html#ios_base::end">end</A></CODE>,
the new position is the end of the stream plus <CODE>off</CODE>.
</UL>

<P>If
<CODE>mode &amp; ios_base::in</CODE> is nonzero,
the function alters the next position to read in the
<A HREF="streambu.html#input buffer">input buffer</A>.
If <CODE>mode &amp; ios_base::out</CODE> is nonzero,
the function alters the next position to write in the
<A HREF="streambu.html#output buffer">output buffer</A>.
For a stream to be affected, its buffer must exist.
For a positioning operation to succeed, the resulting
stream position must lie within the controlled sequence.
If the function affects both stream positions, <CODE>way</CODE>
must be <CODE>ios_base::beg</CODE> or <CODE>ios_base::end</CODE>
and both streams are positioned at the same element.
Otherwise (or if neither position is affected) the positioning
operation fails.</P>

<P>If the function succeeds in altering either or both of the stream positions,
it returns the resultant stream position.
Otherwise, it fails and returns an invalid stream position.</P>

<H3><A NAME="basic_stringbuf::seekpos"><CODE>basic_stringbuf::seekpos</CODE></A></H3>

<PRE>virtual pos_type <B>seekpos</B>(pos_type sp,
    ios_base::openmode mode =
        ios_base::in | ios_base::out);</PRE>

<P>The protected virtual member function endeavors to alter the current
positions for the controlled streams. For an object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>,
a stream position consists
purely of a stream offset. Offset zero designates the first element
of the controlled sequence. The new position is determined
by <CODE>sp</CODE>.</P>

<P>If
<CODE>mode &amp; ios_base::in</CODE> is nonzero,
the function alters the next position to read in the
<A HREF="streambu.html#input buffer">input buffer</A>.
If <CODE>mode &amp; ios_base::out</CODE> is nonzero,
the function alters the next position to write in the
<A HREF="streambu.html#output buffer">output buffer</A>.
For a stream to be affected, its buffer must exist.
For a positioning operation to succeed, the resulting
stream position must lie within the controlled sequence.
Otherwise (or if neither position is affected) the positioning
operation fails.</P>

<P>If the function succeeds in altering either or both of the stream positions,
it returns the resultant stream position.
Otherwise, it fails and returns an invalid stream position.</P>

<H3><A NAME="basic_stringbuf::str"><CODE>basic_stringbuf::str</CODE></A></H3>

<PRE>basic_string&lt;Elem, Tr, Alloc&gt; <B>str</B>() const;
void <B>str</B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);</PRE>

<P>The first member function returns an object of class
<CODE><A HREF="string2.html#basic_string">basic_string</A>&lt;Elem, Tr, Alloc&gt;</CODE>,
whose controlled sequence is a copy of the sequence controlled
by <CODE>*this</CODE>. The sequence copied depends on the stored
<A HREF="#stringbuf mode">stringbuf mode</A> <CODE>mode</CODE>:</P>

<UL>
<LI>If <CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base::out">out</A></CODE> is nonzero
and an <A HREF="streambu.html#output buffer">output buffer</A> exists,
the sequence is the entire output buffer
(<CODE><A HREF="streambu.html#basic_streambuf::epptr">epptr</A>() -
<A HREF="streambu.html#basic_streambuf::pbase">pbase</A>()</CODE>
elements beginning with <CODE>pbase()</CODE>).</LI>

<LI>Otherwise, if <CODE>mode &amp;
ios_base::<A HREF="ios.html#ios_base::in">in</A></CODE> is nonzero
and an <A HREF="streambu.html#input buffer">input buffer</A> exists,
the sequence is the entire input buffer
(<CODE><A HREF="streambu.html#basic_streambuf::egptr">egptr</A>() -
<A HREF="streambu.html#basic_streambuf::eback">eback</A>()</CODE>
elements beginning with <CODE>eback()</CODE>).</LI>

<LI>Otherwise, the copied sequence is empty.</LI>
</UL>

<P>The second member function deallocates any sequence currently
controlled by <CODE>*this</CODE>. It then
allocates a copy of the sequence controlled
by <CODE>newstr</CODE>. If <CODE>mode &amp; ios_base::in</CODE> is nonzero,
it sets the input buffer to begin reading
at the beginning of the sequence.
If <CODE>mode &amp; ios_base::out</CODE> is nonzero,
it sets the output buffer to begin
writing at the beginning of the sequence.</P>

<H3><A NAME="basic_stringbuf::traits_type"><CODE>basic_stringbuf::traits_type</CODE></A></H3>

<PRE>typedef Tr <B>traits_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Tr</CODE>.</P>

<H3><A NAME="basic_stringbuf::underflow"><CODE>basic_stringbuf::underflow</CODE></A></H3>

<PRE>virtual int_type <B>underflow</B>();</PRE>

<P>The protected virtual member function endeavors to extract the current
element <CODE>byte</CODE> from the
<A HREF="streambu.html#input buffer">input buffer</A>,
then advance the current stream position, and return the element as
<CODE>traits_type::<A HREF="string2.html#char_traits::to_int_type">to_int_type</A>(byte)</CODE>.
It can do so in only one way:
If a <A HREF="streambu.html#read position">read position</A>
is available, it takes <CODE>byte</CODE> as the element stored
in the read position and advances the next pointer for the input buffer.</P>

<P>If the function cannot succeed, it returns
<CODE>traits_type::<A HREF="string2.html#char_traits::eof">eof</A>()</CODE>. Otherwise,
it returns the current element in the input stream,
converted as described above.</P>

<H2><A NAME="basic_istringstream"><CODE>basic_istringstream</CODE></A></H2>

<PRE>template &lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B>basic_istringstream</B>
        : public basic_istream&lt;Elem, Tr&gt; {
public:
    typedef Alloc <B><A HREF="#basic_istringstream::allocator_type">allocator_type</A></B>;
    explicit <B><A HREF="#basic_istringstream::basic_istringstream">basic_istringstream</A></B>(
        ios_base::openmode mode = ios_base::in);
    explicit <B><A HREF="#basic_istringstream::basic_istringstream">basic_istringstream</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
        ios_base::openmode mode = ios_base::in);
    basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B><A HREF="#basic_istringstream::rdbuf">rdbuf</A></B>() const;
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#basic_istringstream::str">str</A></B>();
    void <B><A HREF="#basic_istringstream::str">str</A></B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);
    };</PRE>

<P>The template class describes an object that controls
extraction of elements and encoded objects from a
<A HREF="streambu.html#stream buffer">stream buffer</A> of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>,
with elements of type <CODE>Elem</CODE>, whose
<A HREF="string2.html#character traits">character traits</A> are determined
by the class <CODE>Tr</CODE>, and whose elements are allocated by
an allocator of class <CODE>Alloc</CODE>. The object stores an object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_istringstream::allocator_type"><CODE>basic_istringstream::allocator_type</CODE></A></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><A NAME="basic_istringstream::basic_istringstream"><CODE>basic_istringstream::basic_istringstream</CODE></A></H3>

<PRE>explicit <B>basic_istringstream</B>(
    ios_base::openmode mode = ios_base::in);
explicit <B>basic_istringstream</B>(
    const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
    ios_base::openmode mode = ios_base::in);</PRE>

<P>The first constructor initializes the base class by calling
<CODE><A HREF="istream.html#basic_istream::basic_istream">basic_istream</A>(sb)</CODE>,
where <CODE>sb</CODE> is the stored object of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf::basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(mode | ios_base::in)</CODE>.</P>

<P>The second constructor initializes the base class by calling
<CODE>basic_istream(sb)</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf::basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(str, mode | ios_base::in)</CODE>.</P>

<H3><A NAME="basic_istringstream::rdbuf"><CODE>basic_istringstream::rdbuf</CODE></A></H3>

<PRE>basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B>rdbuf</B>() const</PRE>

<P>The member function returns the address of the stored
stream buffer, of type pointer to
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_istringstream::str"><CODE>basic_istringstream::str</CODE></A></H3>

<PRE>basic_string&lt;Elem, Tr, Alloc&gt; <B>str</B>() const;
void <B>str</B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);</PRE>

<P>The first member function returns
<CODE><A HREF="#basic_istringstream::rdbuf">rdbuf</A>()-&gt;
<A HREF="#basic_stringbuf::str">str</A>()</CODE>.
The second member function calls <CODE>rdbuf()-&gt; str(newstr)</CODE>.</P>

<H2><A NAME="basic_ostringstream"><CODE>basic_ostringstream</CODE></A></H2>

<PRE>template &lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B>basic_ostringstream</B>
        : public basic_ostream&lt;Elem, Tr&gt; {
public:
    explicit <B><A HREF="#basic_ostringstream::basic_ostringstream">basic_ostringstream</A></B>(
        ios_base::openmode mode = ios_base::out);
    explicit <B><A HREF="#basic_ostringstream::basic_ostringstream">basic_ostringstream</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
        ios_base::openmode mode = ios_base::out);
    basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B><A HREF="#basic_ostringstream::rdbuf">rdbuf</A></B>() const;
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#basic_ostringstream::str">str</A></B>();
    void <B><A HREF="#basic_ostringstream::str">str</A></B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);
    };</PRE>

<P>The template class describes an object that controls
insertion of elements and encoded objects into a
<A HREF="streambu.html#stream buffer">stream buffer</A> of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>,
with elements of type <CODE>Elem</CODE>, whose
<A HREF="string2.html#character traits">character traits</A> are determined
by the class <CODE>Tr</CODE>, and whose elements are allocated by
an allocator of class <CODE>Alloc</CODE>. The object stores an object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_ostringstream::allocator_type"><CODE>basic_ostringstream::allocator_type</CODE></A></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><A NAME="basic_ostringstream::basic_ostringstream"><CODE>basic_ostringstream::basic_ostringstream</CODE></A></H3>

<PRE>explicit <B>basic_ostringstream</B>(
    ios_base::openmode mode = ios_base::out);
explicit <B>basic_ostringstream</B>(
    const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
    ios_base::openmode mode = ios_base::out);</PRE>

<P>The first constructor initializes the base class by calling
<CODE><A HREF="ostream.html#basic_ostream::basic_ostream">basic_ostream</A>(sb)</CODE>,
where <CODE>sb</CODE> is the stored object of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf::basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(mode | ios_base::out)</CODE>.</P>

<P>The second constructor initializes the base class by calling
<CODE>basic_ostream(sb)</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf::basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(str, mode | ios_base::out)</CODE>.</P>

<H3><A NAME="basic_ostringstream::rdbuf"><CODE>basic_ostringstream::rdbuf</CODE></A></H3>

<PRE>basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B>rdbuf</B>() const</PRE>

<P>The member function returns the address of the stored
stream buffer, of type pointer to
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_ostringstream::str"><CODE>basic_ostringstream::str</CODE></A></H3>

<PRE>basic_string&lt;Elem, Tr, Alloc&gt; <B>str</B>() const;
void <B>str</B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);</PRE>

<P>The first member function returns
<CODE><A HREF="#basic_ostringstream::rdbuf">rdbuf</A>()-&gt;
<A HREF="#basic_stringbuf::str">str</A>()</CODE>.
The second member function calls <CODE>rdbuf()-&gt; str(newstr)</CODE>.</P>

<H2><A NAME="basic_stringstream"><CODE>basic_stringstream</CODE></A></H2>

<PRE>template &lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B>basic_stringstream</B>
        : public basic_iostream&lt;Elem, Tr&gt; {
public:
    typedef Alloc <B><A HREF="#basic_stringstream::allocator_type">allocator_type</A></B>;
    explicit <B><A HREF="#basic_stringstream::basic_stringstream">basic_stringstream</A></B>(
        ios_base::openmode mode =
            ios_base::in | ios_base::out);
    explicit <B><A HREF="#basic_stringstream::basic_stringstream">basic_stringstream</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
        ios_base::openmode mode =
            ios_base::in | ios_base::out);
    basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B><A HREF="#basic_stringstream::rdbuf">rdbuf</A></B>() const;
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#basic_stringstream::str">str</A></B>();
    void <B><A HREF="#basic_stringstream::str">str</A></B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);
    };</PRE>

<P>The template class describes an object that controls
insertion and extraction of elements and encoded objects using a
<A HREF="streambu.html#stream buffer">stream buffer</A> of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>,
with elements of type <CODE>Elem</CODE>, whose
<A HREF="string2.html#character traits">character traits</A> are determined
by the class <CODE>Tr</CODE>, and whose elements are allocated by
an allocator of class <CODE>Alloc</CODE>. The object stores an object of class
<CODE>basic_stringbuf&lt;Elem, Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_stringstream::allocator_type"><CODE>basic_stringstream::allocator_type</CODE></A></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><A NAME="basic_stringstream::basic_stringstream"><CODE>basic_stringstream::basic_stringstream</CODE></A></H3>

<PRE>explicit <B>basic_stringstream</B>(
    ios_base::openmode mode =
        ios_base::in | ios_base::out);
explicit <B>basic_stringstream</B>(
    const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
    ios_base::openmode mode =
         ios_base::in | ios_base::out);</PRE>

<P>The first constructor initializes the base class by calling
<CODE><A HREF="istream.html#basic_iostream">basic_iostream</A>(sb)</CODE>,
where <CODE>sb</CODE> is the stored object of class
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem, Tr, Alloc&gt;</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf::basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(mode)</CODE>.</P>

<P>The second constructor initializes the base class by calling
<CODE>basic_iostream(sb)</CODE>.
It also initializes <CODE>sb</CODE> by calling
<CODE><A HREF="#basic_stringbuf::basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;(str, mode)</CODE>.</P>

<H3><A NAME="basic_stringstream::rdbuf"><CODE>basic_stringstream::rdbuf</CODE></A></H3>

<PRE>basic_stringbuf&lt;Elem, Tr, Alloc&gt; *<B>rdbuf</B>() const</PRE>

<P>The member function returns the address of the stored
stream buffer, of type pointer to
<CODE><A HREF="#basic_stringbuf">basic_stringbuf</A>&lt;Elem,
Tr, Alloc&gt;</CODE>.</P>

<H3><A NAME="basic_stringstream::str"><CODE>basic_stringstream::str</CODE></A></H3>

<PRE>basic_string&lt;Elem, Tr, Alloc&gt; <B>str</B>() const;
void <B>str</B>(const basic_string&lt;Elem, Tr, Alloc&gt;&amp; newstr);</PRE>

<P>The first member function returns
<CODE><A HREF="#basic_stringstream::rdbuf">rdbuf</A>()-&gt;
<A HREF="#basic_stringbuf::str">str</A>()</CODE>.
The second member function calls <CODE>rdbuf()-&gt; str(newstr)</CODE>.</P>

<H2><A NAME="istringstream"><CODE>istringstream</CODE></A></H2>

<PRE>typedef basic_istringstream&lt;char&gt; <B>istringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_istringstream"><CODE>basic_istringstream</CODE></A>, specialized
for elements of type <I>char.</I></P>

<H2><A NAME="ostringstream"><CODE>ostringstream</CODE></A></H2>

<PRE>typedef basic_ostringstream&lt;char&gt; <B>ostringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_ostringstream"><CODE>basic_ostringstream</CODE></A>, specialized
for elements of type <I>char.</I></P>

<H2><A NAME="stringbuf"><CODE>stringbuf</CODE></A></H2>

<PRE>typedef basic_stringbuf&lt;char&gt; <B>stringbuf</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_stringbuf"><CODE>basic_stringbuf</CODE></A>, specialized
for elements of type <I>char.</I></P>

<H2><A NAME="stringstream"><CODE>stringstream</CODE></A></H2>

<PRE>typedef basic_stringstream&lt;char&gt; <B>stringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_stringstream"><CODE>basic_stringstream</CODE></A>, specialized
for elements of type <I>char.</I></P>

<H2><A NAME="wistringstream"><CODE>wistringstream</CODE></A></H2>

<PRE>typedef basic_istringstream&lt;wchar_t&gt; <B>wistringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_istringstream"><CODE>basic_istringstream</CODE></A>, specialized
for elements of type <CODE>wchar_t</CODE>.</P>

<H2><A NAME="wostringstream"><CODE>wostringstream</CODE></A></H2>

<PRE>typedef basic_ostringstream&lt;wchar_t&gt; <B>wostringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_ostringstream"><CODE>basic_ostringstream</CODE></A>, specialized
for elements of type <CODE>wchar_t</CODE>.</P>

<H2><A NAME="wstringbuf"><CODE>wstringbuf</CODE></A></H2>

<PRE>typedef basic_stringbuf&lt;wchar_t&gt; <B>wstringbuf</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_stringbuf"><CODE>basic_stringbuf</CODE></A>, specialized
for elements of type <CODE>wchar_t</CODE>.</P>

<H2><A NAME="wstringstream"><CODE>wstringstream</CODE></A></H2>

<PRE>typedef basic_stringstream&lt;wchar_t&gt; <B>wstringstream</B>;</PRE>

<P>The type is a synonym for template class
<A HREF="#basic_stringstream"><CODE>basic_stringstream</CODE></A>, specialized
for elements of type <CODE>wchar_t</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2002
by P.J. Plauger. All rights reserved.</I></P>

<!--V4.02:1476--></BODY></HTML>
