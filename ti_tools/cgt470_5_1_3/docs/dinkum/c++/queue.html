<HTML><HEAD><TITLE>&lt;queue&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;queue&gt;"><CODE>&lt;queue&gt;</CODE></A></H1><HR>

<P>Include the <A HREF="index.html#STL">STL</A>
standard header <B><CODE>&lt;queue&gt;</CODE></B>
to define the template classes <CODE>priority_queue</CODE> and
<CODE>queue</CODE>, and several supporting templates.</P>

<PRE>namespace std {
template&lt;class Ty, class Container&gt;
    class <B><A HREF="#queue">queue</A></B>;
template&lt;class Ty, class Container, class Pr&gt;
    class <B><A HREF="#priority_queue">priority_queue</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator==">operator==</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator!=">operator!=</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&lt;=">operator&lt;=</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);
template&lt;class Ty, class Container&gt;
    bool <B><A HREF="#operator&gt;=">operator&gt;=</A></B>(const queue&lt;Ty, Container&gt;&amp; left,
        const queue&lt;Ty, Container&gt;&amp;);
    };</PRE>

<H2><A NAME="operator!="><CODE>operator!=</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator!=</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left == right)</CODE>.</P>

<H2><A NAME="operator=="><CODE>operator==</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator==</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator==</CODE> to compare
two objects of template class
<A HREF="#queue"><CODE>queue</CODE></A>. The function returns
<CODE>left.<A HREF="#queue::c">c</A> == right.c</CODE>.</P>

<H2><A NAME="operator&lt;"><CODE>operator&lt;</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&lt;</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function overloads <CODE>operator&lt;</CODE> to compare
two objects of template class
<A HREF="#queue"><CODE>queue</CODE></A>. The function returns
<CODE>left.<A HREF="#queue::c">c</A> &lt; right.c</CODE>.</P>

<H2><A NAME="operator&lt;="><CODE>operator&lt;=</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&lt;=</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(right &lt; left)</CODE>.</P>

<H2><A NAME="operator&gt;"><CODE>operator&gt;</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&gt;</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>right &lt; left</CODE>.</P>

<H2><A NAME="operator&gt;="><CODE>operator&gt;=</CODE></A></H2>

<PRE>template&lt;class Ty, class Container&gt;
    bool <B>operator&gt;=</B>(const queue &lt;Ty, Container&gt;&amp; left,
        const queue &lt;Ty, Container&gt;&amp; right);</PRE>

<P>The template function returns <CODE>!(left &lt; right)</CODE>.</P>

<H2><A NAME="priority_queue"><CODE>priority_queue</CODE></A></H2>

<PRE>template&lt;class Ty,
    class Container = vector&lt;Ty&gt;,
    class Pr = less&lt;typename Container::value_type&gt; &gt;
    class priority_queue {
public:
    typedef Container <B><A HREF="#priority_queue::container_type">container_type</A></B>;
    typedef typename Container::value_type <B><A HREF="#priority_queue::value_type">value_type</A></B>;
    typedef typename Container::size_type <B><A HREF="#priority_queue::size_type">size_type</A></B>;
    <B><A HREF="#priority_queue::priority_queue">priority_queue</A></B>();
    explicit <B><A HREF="#priority_queue::priority_queue">priority_queue</A></B>(const Pr&amp; pred);
    <B><A HREF="#priority_queue::priority_queue">priority_queue</A></B>(const Pr&amp; pred,
        const container_type&amp; cont);
    <B><A HREF="#priority_queue::priority_queue">priority_queue</A></B>(const priority_queue&amp; right);
    template&lt;class InIt&gt;
        <B><A HREF="#priority_queue::priority_queue">priority_queue</A></B>(InIt first, InIt last);
    template&lt;class InIt&gt;
        <B><A HREF="#priority_queue::priority_queue">priority_queue</A></B>(InIt first, InIt last,
            const Pr&amp; pred);
    template&lt;class InIt&gt;
        <B><A HREF="#priority_queue::priority_queue">priority_queue</A></B>(InIt first, InIt last,
            const Pr&amp; pred, const container_type&amp; cont);
    bool <B><A HREF="#priority_queue::empty">empty</A></B>() const;
    size_type <B><A HREF="#priority_queue::size">size</A></B>() const;
    const value_type&amp; <B><A HREF="#priority_queue::top">top</A></B>() const;
    void <B><A HREF="#priority_queue::push">push</A></B>(const value_type&amp; val);
    void <B><A HREF="#priority_queue::pop">pop</A></B>();
protected:
    Container <B><A HREF="#priority_queue::c">c</A></B>;
    Pr <B><A HREF="#priority_queue::comp">comp</A></B>;
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements.
The object allocates and frees storage for the sequence it controls
through a protected object named
<B><A NAME="priority_queue::c"><CODE>c</CODE></A></B>,
of class <CODE>Container</CODE>.
The type <CODE>Ty</CODE> of elements in the controlled sequence must match
<CODE><A HREF="#priority_queue::value_type">value_type</A></CODE>.</P>

<P>The sequence is ordered using a protected object named
<B><A NAME="priority_queue::comp"><CODE>comp</CODE></A></B>.
After each insertion or removal of the top element (at position zero),
for the iterators <CODE>P0</CODE> and <CODE>Pi</CODE>
designating elements at positions <CODE>0</CODE>
and <CODE>I</CODE>, <CODE>comp(*P0, *Pi)</CODE> is false.
(For the default template parameter
<CODE><A HREF="functio2.html#less">less</A>&lt;typename Container::value_type&gt;</CODE>
the top element of the sequence compares largest, or highest priority.)</P>

<P>An object of class <CODE>Container</CODE> must supply
random-access iterators and
several public members defined the same as for
<CODE><A HREF="deque.html#deque">deque</A></CODE> and
<CODE><A HREF="vector.html#vector">vector</A></CODE>
(both of which are suitable candidates for class <CODE>Container</CODE>).
The required members are:</P>

<PRE>    typedef Ty <B>value_type</B>;
    typedef T0 <B>size_type</B>;
    typedef T1 <B>iterator</B>;
    <B>Container</B>();
    template&lt;class InIt&gt;
        <B>Container</B>(InIt first, InIt last);
    template&lt;class InIt&gt;
        void <B>insert</B>(iterator where, InIt first, InIt last);
    iterator <B>begin</B>();
    iterator <B>end</B>();
    bool <B>empty</B>() const;
    size_type <B>size</B>() const;
    const value_type&amp; <B>front</B>() const;
    void <B>push_back</B>(const value_type&amp; val);
    void <B>pop_back</B>();</PRE>

<P>Here, <CODE>T0</CODE> and <CODE>T1</CODE> are unspecified types
that meet the stated requirements.</P>

<H3><CODE><A NAME="priority_queue::container_type">priority_queue::container_type</A></CODE></H3>

<PRE>typedef typename Container::container_type <B>container_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Container</CODE>.</P>

<H3><CODE><A NAME="priority_queue::empty">priority_queue::empty</A></CODE></H3>

<PRE>bool <B>empty</B>() const;</PRE>

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="priority_queue::pop">priority_queue::pop</A></CODE></H3>

<PRE>void <B>pop</B>();</PRE>

<P>The member function removes the first element of the
controlled sequence, which must be non-empty, then reorders it.</P>

<H3><CODE><A NAME="priority_queue::priority_queue">priority_queue::priority_queue</A></CODE></H3>

<PRE><B>priority_queue</B>();
explicit <B>priority_queue</B>(const Pr&amp; pred);
<B>priority_queue</B>(const Pr&amp; pred,
    const container_type&amp; cont);
<B>priority_queue</B>(const priority_queue&amp; right);
template&lt;class InIt&gt;
    <B>priority_queue</B>(InIt first, InIt last);
template&lt;class InIt&gt;
    <B>priority_queue</B>(InIt first, InIt last,
        const Pr&amp; pred);
template&lt;class InIt&gt;
    <B>priority_queue</B>(InIt first, InIt last,
        const Pr&amp; pred, const container_type&amp; cont);</PRE>

<P>All constructors with an argument <CODE>cont</CODE>
initialize the stored object with
<CODE><A HREF="#priority_queue::c">c</A>(cont)</CODE>.
The remaining constructors initialize the stored object with
<CODE><A HREF="#priority_queue::c">c</A></CODE>, to specify an
empty initial controlled sequence.
The last three constructors then call
<CODE>c.insert(c.end(), first, last)</CODE>.</P>

<P>All constructors also store a function object in
<CODE><A HREF="#priority_queue::comp">comp</A></CODE>.
The function object <CODE>comp</CODE> is the argument <CODE>pred</CODE>, if present.
For the copy constructor, it is <CODE>right.comp</CODE>.
Otherwise, it is <CODE>Pr()</CODE>.</P>

<P>A non-empty initial controlled sequence is then ordered by calling
<CODE><A HREF="algorith.html#make_heap">make_heap</A>(c.begin(),
c.end(), comp)</CODE>.</P>


<H3><CODE><A NAME="priority_queue::push">priority_queue::push</A></CODE></H3>

<PRE>void <B>push</B>(const Ty&amp; val);</PRE>

<P>The member function inserts an element with value <CODE>val</CODE>
at the end of the controlled sequence, then reorders it.</P>

<H3><CODE><A NAME="priority_queue::size">priority_queue::size</A></CODE></H3>

<PRE>size_type <B>size</B>() const;</PRE>

<P>The member function returns the length of the controlled sequence.</P>

<H3><CODE><A NAME="priority_queue::size_type">priority_queue::size_type</A></CODE></H3>

<PRE>typedef typename Container::size_type <B>size_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::size_type</CODE>.</P>

<H3><CODE><A NAME="priority_queue::top">priority_queue::top</A></CODE></H3>

<PRE>const value_type&amp; <B>top</B>() const;</PRE>

<P>The member function returns a reference to the first (highest priority)
element of the controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="priority_queue::value_type">priority_queue::value_type</A></CODE></H3>

<PRE>typedef typename Container::value_type <B>value_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::value_type</CODE>.</P>

<H2><A NAME="queue"><CODE>queue</CODE></A></H2>

<PRE>template&lt;class Ty,
    class Container = deque&lt;Ty&gt; &gt;
    class queue {
public:
    typedef Container <B><A HREF="#queue::container_type">container_type</A></B>;
    typedef typename Container::value_type <B><A HREF="#queue::value_type">value_type</A></B>;
    typedef typename Container::size_type <B><A HREF="#queue::size_type">size_type</A></B>;
    <B><A HREF="#queue::queue">queue</A></B>();
    explicit <B><A HREF="#queue::queue">queue</A></B>(const container_type&amp; cont);
    bool <B><A HREF="#queue::empty">empty</A></B>() const;
    size_type <B><A HREF="#queue::size">size</A></B>() const;
    value_type&amp; <B><A HREF="#queue::back">back</A></B>();
    const value_type&amp; <B><A HREF="#queue::back">back</A></B>() const;
    value_type&amp; <B><A HREF="#queue::front">front</A></B>();
    const value_type&amp; <B><A HREF="#queue::front">front</A></B>() const;
    void <B><A HREF="#queue::push">push</A></B>(const value_type&amp; val);
    void <B><A HREF="#queue::pop">pop</A></B>();
protected:
    Container <B><A HREF="#queue::c">c</A></B>;
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements.
The object allocates and frees storage for the sequence it controls
through a protected object named
<B><A NAME="queue::c"><CODE>c</CODE></A></B>,
of class <CODE>Container</CODE>.
The type <CODE>Ty</CODE> of elements in the controlled sequence must match
<CODE><A HREF="#queue::value_type">value_type</A></CODE>.</P>

<P>An object of class <CODE>Container</CODE> must supply
several public members defined the same as for
<CODE><A HREF="deque.html#deque">deque</A></CODE> and
<CODE><A HREF="list.html#list">list</A></CODE>
(both of which are suitable candidates for class <CODE>Container</CODE>).
The required members are:</P>

<PRE>    typedef Ty <B>value_type</B>;
    typedef T0 <B>size_type</B>;
    <B>Container</B>();
    bool <B>empty</B>() const;
    size_type <B>size</B>() const;
    value_type&amp; <B>front</B>();
    const value_type&amp; <B>front</B>() const;
    value_type&amp; <B>back</B>();
    const value_type&amp; <B>back</B>() const;
    void <B>push_back</B>(const value_type&amp; val);
    void <B>pop_front</B>();
    bool <B>operator==</B>(const Container&amp; cont) const;
    bool <B>operator!=</B>(const Container&amp; cont) const;
    bool <B>operator&lt;</B>(const Container&amp; cont) const;
    bool <B>operator&gt;</B>(const Container&amp; cont) const;
    bool <B>operator&lt;=</B>(const Container&amp; cont) const;
    bool <B>operator&gt;=</B>(const Container&amp; cont) const;</PRE>

<P>Here, <CODE>T0</CODE> is an unspecified type
that meets the stated requirements.</P>

<H3><CODE><A NAME="queue::back">queue::back</A></CODE></H3>

<PRE>value_type&amp; <B>back</B>();
const value_type&amp; <B>back</B>() const;</PRE>

<P>The member function returns a reference to the last element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="queue::container_type">queue::container_type</A></CODE></H3>

<PRE>typedef Container <B>container_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Container</CODE>.</P>

<H3><CODE><A NAME="queue::empty">queue::empty</A></CODE></H3>

<PRE>bool <B>empty</B>() const;</PRE>

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="queue::front">queue::front</A></CODE></H3>

<PRE>value_type&amp; <B>front</B>();
const value_type&amp; <B>front</B>() const;</PRE>

<P>The member function returns a reference to the first element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="queue::pop">queue::pop</A></CODE></H3>

<PRE>void <B>pop</B>();</PRE>

<P>The member function removes the first element of the
controlled sequence, which must be non-empty.</P>

<H3><CODE><A NAME="queue::push">queue::push</A></CODE></H3>

<PRE>void <B>push</B>(const Ty&amp; val);</PRE>

<P>The member function inserts an element with value <CODE>val</CODE>
at the end of the controlled sequence.</P>

<H3><CODE><A NAME="queue::queue">queue::queue</A></CODE></H3>

<PRE><B>queue</B>();
explicit <B>queue</B>(const container_type&amp; cont);</PRE>

<P>The first constructor initializes the stored object with
<CODE><A HREF="#queue::c">c</A>()</CODE>, to specify an
empty initial controlled sequence.
The second constructor initializes the stored object with
<CODE><A HREF="#queue::c">c</A>(cont)</CODE>, to specify an
initial controlled sequence that is a copy of the sequence controlled
by <CODE>cont</CODE>.</P>

<H3><CODE><A NAME="queue::size">queue::size</A></CODE></H3>

<PRE>size_type <B>size</B>() const;</PRE>

<P>The member function returns the length of the controlled sequence.</P>

<H3><CODE><A NAME="queue::size_type">queue::size_type</A></CODE></H3>

<PRE>typedef typename Container::size_type <B>size_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::size_type</CODE>.</P>

<H3><CODE><A NAME="queue::value_type">queue::value_type</A></CODE></H3>

<PRE>typedef typename Container::value_type <B>value_type</B>;</PRE>

<P>The type is a synonym for <CODE>Container::value_type</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1994-2002
by P.J. Plauger. Portions derived from work
<A HREF="crit_hp.html">copyright</A> &#169; 1994
by Hewlett-Packard Company. All rights reserved.</I></P>

<!--V4.02:1476--></BODY></HTML>
