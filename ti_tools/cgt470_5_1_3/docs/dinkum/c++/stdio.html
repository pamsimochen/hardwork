<HTML><HEAD><TITLE>&lt;stdio.h&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;stdio.h&gt;"><CODE>&lt;stdio.h&gt;</CODE></A></H1><HR>

<P><B><CODE><A HREF="#_IOFBF">_IOFBF</A>
&#183; <A HREF="#_IOLBF">_IOLBF</A>
&#183; <A HREF="#_IONBF">_IONBF</A>
&#183; <A HREF="#BUFSIZ">BUFSIZ</A>
&#183; <A HREF="#EOF">EOF</A>
&#183; <A HREF="#FILE">FILE</A>
&#183; <A HREF="#FILENAME_MAX">FILENAME_MAX</A>
&#183; <A HREF="#FOPEN_MAX">FOPEN_MAX</A>
&#183; <A HREF="#L_tmpnam">L_tmpnam</A>
&#183; <A HREF="#NULL">NULL</A>
&#183; <A HREF="#SEEK_CUR">SEEK_CUR</A>
&#183; <A HREF="#SEEK_END">SEEK_END</A>
&#183; <A HREF="#SEEK_SET">SEEK_SET</A>
&#183; <A HREF="#TMP_MAX">TMP_MAX</A>
</CODE></B></P>

<P><B><CODE><A HREF="#clearerr">clearerr</A>
&#183; <A HREF="#fclose">fclose</A>
&#183; <A HREF="#feof">feof</A>
&#183; <A HREF="#ferror">ferror</A>
&#183; <A HREF="#fflush">fflush</A>
&#183; <A HREF="#fgetc">fgetc</A>
&#183; <A HREF="#fgetpos">fgetpos</A>
&#183; <A HREF="#fgets">fgets</A>
&#183; <A HREF="#fopen">fopen</A>
&#183; <A HREF="#fpos_t">fpos_t</A>
&#183; <A HREF="#fprintf">fprintf</A>
&#183; <A HREF="#fputc">fputc</A>
&#183; <A HREF="#fputs">fputs</A>
&#183; <A HREF="#fread">fread</A>
&#183; <A HREF="#freopen">freopen</A>
&#183; <A HREF="#fscanf">fscanf</A>
&#183; <A HREF="#fseek">fseek</A>
&#183; <A HREF="#fsetpos">fsetpos</A>
&#183; <A HREF="#ftell">ftell</A>
&#183; <A HREF="#fwrite">fwrite</A>
&#183; <A HREF="#getc">getc</A>
&#183; <A HREF="#getchar">getchar</A>
&#183; <A HREF="#gets">gets</A>
&#183; <A HREF="#perror">perror</A>
&#183; <A HREF="#printf">printf</A>
&#183; <A HREF="#putc">putc</A>
&#183; <A HREF="#putchar">putchar</A>
&#183; <A HREF="#puts">puts</A>
&#183; <A HREF="#remove">remove</A>
&#183; <A HREF="#rename">rename</A>
&#183; <A HREF="#rewind">rewind</A>
&#183; <A HREF="#scanf">scanf</A>
&#183; <A HREF="#setbuf">setbuf</A>
&#183; <A HREF="#setvbuf">setvbuf</A>
&#183; <A HREF="#size_t">size_t</A>
&#183; <A HREF="#sprintf">sprintf</A>
&#183; <A HREF="#sscanf">sscanf</A>
&#183; <A HREF="#stderr">stderr</A>
&#183; <A HREF="#stdin">stdin</A>
&#183; <A HREF="#stdout">stdout</A>
&#183; <A HREF="#tmpfile">tmpfile</A>
&#183; <A HREF="#tmpnam">tmpnam</A>
&#183; <A HREF="#ungetc">ungetc</A>
&#183; <A HREF="#vfprintf">vfprintf</A>
&#183; <A HREF="#vprintf">vprintf</A>
&#183; <A HREF="#vsprintf">vsprintf</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;stdio.h&gt;</CODE></B>
so that you can perform input and output operations on streams and files.</P>

<PRE>    /* MACROS */
#define <A HREF="#_IOFBF"><B>_IOFBF</B></A> <I>&lt;integer constant expression&gt;</I>
#define <A HREF="#_IOLBF"><B>_IOLBF</B></A> <I>&lt;integer constant expression&gt;</I>
#define <A HREF="#_IONBF"><B>_IONBF</B></A> <I>&lt;integer constant expression&gt;</I>
#define <A HREF="#BUFSIZ"><B>BUFSIZ</B></A> <I>&lt;integer constant expression &gt;= 256&gt;</I>
#define <A HREF="#EOF"><B>EOF</B></A> <I>&lt;integer constant expression &lt; 0&gt;</I>
#define <A HREF="#FILENAME_MAX"><B>FILENAME_MAX</B></A> <I>&lt;integer constant expression &gt; 0&gt;</I>
#define <A HREF="#FOPEN_MAX"><B>FOPEN_MAX</B></A> <I>&lt;integer constant expression &gt;= 8&gt;</I>
#define <A HREF="#L_tmpnam"><B>L_tmpnam</B></A> <I>&lt;integer constant expression &gt; 0&gt;</I>
#define <A HREF="#NULL"><B>NULL</B></A> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B>
#define <A HREF="#SEEK_CUR"><B>SEEK_CUR</B></A> <I>&lt;integer constant expression&gt;</I>
#define <A HREF="#SEEK_END"><B>SEEK_END</B></A> <I>&lt;integer constant expression&gt;</I>
#define <A HREF="#SEEK_SET"><B>SEEK_SET</B></A> <I>&lt;integer constant expression&gt;</I>
#define <A HREF="#TMP_MAX"><B>TMP_MAX</B></A> <I>&lt;integer constant expression &gt;= 25&gt;</I>

#define <A HREF="#stderr"><B>stderr</B></A> <I>&lt;pointer to FILE rvalue&gt;</I>
#define <A HREF="#stdin"><B>stdin</B></A> <I>&lt;pointer to FILE rvalue&gt;</I>
#define <A HREF="#stdout"><B>stdout</B></A> <I>&lt;pointer to FILE rvalue&gt;</I>

    /* TYPES */
typedef <I>o-type</I> <A HREF="#FILE"><B>FILE</B></A>;
typedef <I>o-type</I> <A HREF="#fpos_t"><B>fpos_t</B></A>;
typedef <I>ui-type</I> <A HREF="#size_t"><B>size_t</B></A>;

    /* FUNCTIONS */
void <A HREF="#clearerr"><B>clearerr</B></A>(FILE *stream);
int <A HREF="#fclose"><B>fclose</B></A>(FILE *stream);
int <A HREF="#feof"><B>feof</B></A>(FILE *stream);
int <A HREF="#ferror"><B>ferror</B></A>(FILE *stream);
int <A HREF="#fflush"><B>fflush</B></A>(FILE *stream);
FILE *<A HREF="#fopen"><B>fopen</B></A>(const char *filename, const char *mode);
FILE *<A HREF="#freopen"><B>freopen</B></A>(const char *filename, const char *mode,
    FILE *stream);
int <A HREF="#remove"><B>remove</B></A>(const char *filename);
int <A HREF="#rename"><B>rename</B></A>(const char *old, const char *new);
void <A HREF="#rewind"><B>rewind</B></A>(FILE *stream);
void <A HREF="#setbuf"><B>setbuf</B></A>(FILE *stream, char *buf);
int <A HREF="#setvbuf"><B>setvbuf</B></A>(FILE *stream, char *buf, int mode,
    size_t size);
FILE *<A HREF="#tmpfile"><B>tmpfile</B></A>(void)
char *<A HREF="#tmpnam"><B>tmpnam</B></A>(char *s);

int <A HREF="#fseek"><B>fseek</B></A>(FILE *stream, long offset, int mode);
int <A HREF="#fsetpos"><B>fsetpos</B></A>(FILE *stream, const fpos_t *pos);
int <A HREF="#fgetpos"><B>fgetpos</B></A>(FILE *stream, fpos_t *pos);
long <A HREF="#ftell"><B>ftell</B></A>(FILE *stream);

int <A HREF="#fgetc"><B>fgetc</B></A>(FILE *stream);
char *<A HREF="#fgets"><B>fgets</B></A>(char *s, int n, FILE *stream);
size_t <A HREF="#fread"><B>fread</B></A>(void *ptr,
    size_t size, size_t nelem, FILE *stream);
int <A HREF="#getc"><B>getc</B></A>(FILE *stream);
int <A HREF="#getchar"><B>getchar</B></A>(void);
char *<A HREF="#gets"><B>gets</B></A>(char *s);
int <A HREF="#ungetc"><B>ungetc</B></A>(int c, FILE *stream);

int <A HREF="#fputc"><B>fputc</B></A>(int c, FILE *stream);
int <A HREF="#fputs"><B>fputs</B></A>(const char *s, FILE *stream);
size_t <A HREF="#fwrite"><B>fwrite</B></A>(const void *ptr,
    size_t size, size_t nelem, FILE *stream);
void <A HREF="#perror"><B>perror</B></A>(const char *s);
int <A HREF="#putc"><B>putc</B></A>(int c, FILE *stream);
int <A HREF="#putchar"><B>putchar</B></A>(int c);
int <A HREF="#puts"><B>puts</B></A>(const char *s);

int <A HREF="#fscanf"><B>fscanf</B></A>(FILE *stream, const char *format, ...);
int <A HREF="#scanf"><B>scanf</B></A>(const char *format, ...);
int <A HREF="#sscanf"><B>sscanf</B></A>(const char *s, const char *format, ...);

int <A HREF="#fprintf"><B>fprintf</B></A>(FILE *stream, const char *format, ...);
int <A HREF="#printf"><B>printf</B></A>(const char *format, ...);
int <A HREF="#sprintf"><B>sprintf</B></A>(char *s, const char *format, ...);
int <A HREF="#vfprintf"><B>vfprintf</B></A>(FILE *stream, const char *format,
    va_list ap);
int <A HREF="#vprintf"><B>vprintf</B></A>(const char *format,
    va_list ap);
int <A HREF="#vsprintf"><B>vsprintf</B></A>(char *s, const char *format,
    va_list ap);</PRE>

<H2><A NAME="BUFSIZ"><CODE>BUFSIZ</CODE></A></H2>

<PRE>#define <B>BUFSIZ</B> <I>&lt;integer constant expression &gt;= 256&gt;</I></PRE>

<P>The macro yields the size of the stream buffer used by
<A HREF="#setbuf"><CODE>setbuf</CODE></A>.</P>

<H2><A NAME="clearerr"><CODE>clearerr</CODE></A></H2>

<PRE>void <B>clearerr</B>(FILE *stream);</PRE>

<P>The function clears the end-of-file and error indicators for
the stream <CODE>stream</CODE>.</P>

<H2><A NAME="EOF"><CODE>EOF</CODE></A></H2>

<PRE>#define <B>EOF</B> <I>&lt;integer constant expression &lt; 0&gt;</I></PRE>

<P>The macro yields the return value used to signal the end of
a stream or to report an error condition.</P>

<H2><A NAME="fclose"><CODE>fclose</CODE></A></H2>

<PRE>int <B>fclose</B>(FILE *stream);</PRE>

<P>The function closes the file associated with
the stream <CODE>stream</CODE>.
It returns zero if successful; otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.
<CODE>fclose</CODE> writes any buffered output to the file,
deallocates the stream buffer if it was automatically allocated,
and removes the association between the stream and the file.
Do not use the value of <CODE>stream</CODE> in subsequent expressions.</P>

<H2><A NAME="feof"><CODE>feof</CODE></A></H2>

<PRE>int <B>feof</B>(FILE *stream);</PRE>

<P>The function returns a nonzero value if the end-of-file indicator
is set for the stream <CODE>stream</CODE>.</P>

<H2><A NAME="ferror"><CODE>ferror</CODE></A></H2>

<PRE>int <B>ferror</B>(FILE *stream);</PRE>

<P>The function returns a nonzero value if the error indicator
is set for the stream <CODE>stream</CODE>.</P>

<H2><A NAME="fflush"><CODE>fflush</CODE></A></H2>

<PRE>int <B>fflush</B>(FILE *stream);</PRE>

<P>The function writes any buffered output to the file associated
with the stream <CODE>stream</CODE> and returns zero if successful;
otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.
If <CODE>stream</CODE> is a null pointer, <CODE>fflush</CODE>
writes any buffered output to all files opened for output.</P>

<H2><A NAME="fgetc"><CODE>fgetc</CODE></A></H2>

<PRE>int <B>fgetc</B>(FILE *stream);</PRE>

<P>The function reads the next character <CODE>c</CODE> (if present)
from the input stream <CODE>stream</CODE>, advances the
file-position indicator (if defined),
and returns <CODE>(int)(unsigned char)c</CODE>. If the
function sets either the end-of-file indicator or the error indicator,
it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="fgetpos"><CODE>fgetpos</CODE></A></H2>

<PRE>int <B>fgetpos</B>(FILE *stream, fpos_t *pos);</PRE>

<P>The function stores the
file-position indicator for the stream
<CODE>stream</CODE> in <CODE>*pos</CODE> and returns zero if successful;
otherwise, the function stores a positive value in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns a
nonzero value.</P>

<H2><A NAME="fgets"><CODE>fgets</CODE></A></H2>

<PRE>char *<B>fgets</B>(char *s, int n, FILE *stream);</PRE>

<P>The function reads characters from the input stream <CODE>stream</CODE>
and stores them in successive elements of the array
beginning at <CODE>s</CODE>
and continuing until it stores <CODE>n-1</CODE> characters,
stores an <CODE><I>NL</I></CODE> character,
or sets the end-of-file or error indicators. If <CODE>fgets</CODE>
stores any characters, it concludes by storing a null character in
the next element of the array. It returns <CODE>s</CODE> if it stores any
characters and it has not set the error indicator for the stream;
otherwise, it returns a null pointer. If it sets the error indicator,
the array contents are indeterminate.</P>

<H2><A NAME="FILE"><CODE>FILE</CODE></A></H2>

<PRE>typedef <I>o-type</I> <B>FILE</B>;</PRE>

<P>The type is an object type <CODE><I>o-type</I></CODE> that stores all
<A HREF="lib_file.html#Controlling Streams">control information</A>
for a stream. The functions
<A HREF="#fopen"><CODE>fopen</CODE></A> and
<A HREF="#freopen"><CODE>freopen</CODE></A>
allocate all <CODE>FILE</CODE> objects used by the read and write functions.</P>

<H2><A NAME="FILENAME_MAX"><CODE>FILENAME_MAX</CODE></A></H2>

<PRE>#define <B>FILENAME_MAX</B> <I>&lt;integer constant expression &gt; 0&gt;</I></PRE>

<P>The macro yields the maximum size array of characters that you
must provide to hold a
<A HREF="lib_over.html#filename">filename</A>.</P>

<H2><A NAME="fopen"><CODE>fopen</CODE></A></H2>

<PRE>FILE *<B>fopen</B>(const char *filename, const char *mode);</PRE>

<P>The function opens the file with the filename <CODE>filename</CODE>,
associates it with a stream, and returns a pointer to the object controlling
the stream. If the open fails, it returns a null pointer. The initial
characters of <CODE>mode</CODE> determine how the program
<A HREF="lib_file.html#Files and Streams">manipulates</A> the stream
and whether it interprets the stream as
<A HREF="lib_file.html#Text and Binary Streams">text or binary</A>.
The initial characters must be one of the following sequences:</P>

<UL>
<LI><B><CODE>"r"</CODE></B> -- to open an existing text file for reading

<LI><B><CODE>"w"</CODE></B> -- to create a text file or to open and truncate
an existing text file, for writing

<LI><B><CODE>"a"</CODE></B> -- to create a text file or to open
an existing text file, for writing. The
file-position indicator is positioned
at the end of the file before each write

<LI><B><CODE>"rb"</CODE></B> -- to open an existing binary file for reading

<LI><B><CODE>"wb"</CODE></B> -- to create a binary file or to open and truncate
an existing binary file, for writing

<LI><B><CODE>"ab"</CODE></B> -- to create a binary file or to open an existing
binary file, for writing. The
file-position indicator is positioned
at the end of the file (possibly after arbitrary null byte padding)
before each write

<LI><B><CODE>"r+"</CODE></B> -- to open an existing text file for reading
and writing

<LI><B><CODE>"w+"</CODE></B> -- to create a text file or to open and truncate
an existing text file, for reading and writing

<LI><B><CODE>"a+"</CODE></B> -- to create a text file or to open an existing
text file, for reading and writing. The
file-position indicator is positioned
at the end of the file before each write

<LI><B><CODE>"r+b"</CODE></B> or <B><CODE>"rb+"</CODE></B> -- to open an existing binary
file for reading and writing

<LI><B><CODE>"w+b"</CODE></B> or <B><CODE>"wb+"</CODE></B> -- to create a binary file or
to open and truncate an existing binary file, for reading and writing

<LI><B><CODE>"a+b"</CODE></B> or <B><CODE>"ab+"</CODE></B> -- to create a binary file or
to open an existing binary file, for reading and writing. The
file-position indicator is positioned
at the end of the file (possibly after arbitrary
null byte padding) before each write
</UL>

<P>If you open a file for both reading and writing, the target
environment can open a binary file instead of a text file. If the
file is not interactive, the stream is fully buffered.</P>

<H2><A NAME="FOPEN_MAX"><CODE>FOPEN_MAX</CODE></A></H2>

<PRE>#define <B>FOPEN_MAX</B> <I>&lt;integer constant expression &gt;= 8&gt;</I></PRE>

<P>The macro yields the maximum number of files that the target
environment permits to be simultaneously open (including
<A HREF="#stderr"><CODE>stderr</CODE></A>,
<A HREF="#stdin"><CODE>stdin</CODE></A>, and
<A HREF="#stdout"><CODE>stdout</CODE></A>).</P>

<H2><A NAME="fpos_t"><CODE>fpos_t</CODE></A></H2>

<PRE>typedef <I>o-type</I> <B>fpos_t</B>;</PRE>

<P>The type is an object type <CODE><I>o-type</I></CODE>
of an object that you declare to hold the value of a
file-position indicator stored by
<A HREF="#fsetpos"><CODE>fsetpos</CODE></A> and accessed by
<A HREF="#fgetpos"><CODE>fgetpos</CODE></A>.</P>

<H2><A NAME="fprintf"><CODE>fprintf</CODE></A></H2>

<PRE>int <B>fprintf</B>(FILE *stream, const char *format, ...);</PRE>

<P>The function
<A HREF="lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream <CODE>stream</CODE>. It returns the
number of characters generated, or it returns a negative value if
the function sets the error indicator for the stream.</P>

<H2><A NAME="fputc"><CODE>fputc</CODE></A></H2>

<PRE>int <B>fputc</B>(int c, FILE *stream);</PRE>

<P>The function writes the character <CODE>(unsigned char)c</CODE> to
the output stream <CODE>stream</CODE>, advances the
file-position indicator (if defined),
and returns <CODE>(int)(unsigned char)c</CODE>. If the function
sets the error indicator for the stream, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="fputs"><CODE>fputs</CODE></A></H2>

<PRE>int <B>fputs</B>(const char *s, FILE *stream);</PRE>

<P>The function accesses characters from the
<A HREF="lib_over.html#C string">C string</A> <CODE>s</CODE> and
writes them to the output stream <CODE>stream</CODE>. The function does
not write the terminating null character. It returns a nonnegative
value if it has not set the error indicator; otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="fread"><CODE>fread</CODE></A></H2>

<PRE>size_t <B>fread</B>(void *ptr,
    size_t size, size_t nelem, FILE *stream);</PRE>

<P>The function reads characters from the input stream <CODE>stream</CODE>
and stores them in successive elements of the array whose first element
has the address <CODE>(char *)ptr</CODE>
until the function stores <CODE>size*nelem</CODE>
characters or sets the end-of-file or error indicator. It returns
<CODE>n/size</CODE>, where <CODE>n</CODE>
is the number of characters it read.
If <CODE>n</CODE> is not a multiple of <CODE>size</CODE>,
the value stored in the last element is indeterminate.
If the function sets the error indicator, the
file-position indicator is indeterminate.</P>

<H2><A NAME="freopen"><CODE>freopen</CODE></A></H2>

<PRE>FILE *<B>freopen</B>(const char *filename, const char *mode,
    FILE *stream);</PRE>

<P>The function closes the file associated with
the stream <CODE>stream</CODE> (as if by calling
<A HREF="#fclose"><CODE>fclose</CODE></A>);
then it opens the file with the filename <CODE>filename</CODE>
and associates the file with the stream <CODE>stream</CODE>
(as if by calling
<CODE><A HREF="#fopen">fopen</A>(filename, mode)</CODE>).
It returns <CODE>stream</CODE> if the open is successful;
otherwise, it returns a null pointer.</P>

<H2><A NAME="fscanf"><CODE>fscanf</CODE></A></H2>

<PRE>int <B>fscanf</B>(FILE *stream, const char *format, ...);</PRE>

<P>The function
<A HREF="lib_scan.html#Scan Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream <CODE>stream</CODE>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicator for the stream.</P>

<H2><A NAME="fseek"><CODE>fseek</CODE></A></H2>

<PRE>int <B>fseek</B>(FILE *stream, long offset, int mode);</PRE>

<P>The function sets the
file-position indicator for the stream
<CODE>stream</CODE> (as specified by
<CODE>offset</CODE> and <CODE>mode</CODE>), clears
the end-of-file indicator for the stream, and returns zero if successful.</P>

<P>For a
<A HREF="lib_file.html#binary stream">binary stream</A>,
<CODE>offset</CODE> is a signed offset in bytes:</P>

<UL>
<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_SET"><CODE>SEEK_SET</CODE></A>,
<CODE>fseek</CODE> adds <CODE>offset</CODE>
to the file-position indicator for the beginning of the file.

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_CUR"><CODE>SEEK_CUR</CODE></A>,
<CODE>fseek</CODE> adds <CODE>offset</CODE> to the current
file-position indicator.

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_END"><CODE>SEEK_END</CODE></A>,
<CODE>fseek</CODE> adds <CODE>offset</CODE> to the
file-position indicator for the end of the file
(possibly after arbitrary null character padding).
</UL>

<P><CODE>fseek</CODE> sets the file-position indicator to the result
of this addition.</P>

<P>For a
<A HREF="lib_file.html#text stream">text stream</A>:</P>

<UL>
<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_SET"><CODE>SEEK_SET</CODE></A>,
<CODE>fseek</CODE> sets the
file-position indicator to the value encoded
in <CODE>offset</CODE>, which is either a value returned
by an earlier successful call to
<A HREF="#ftell"><CODE>ftell</CODE></A>
or zero to indicate the beginning of the file.

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_CUR"><CODE>SEEK_CUR</CODE></A>
and <CODE>offset</CODE> is zero, <CODE>fseek</CODE> leaves the
file-position indicator at its current value.

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_END"><CODE>SEEK_END</CODE></A>
and <CODE>offset</CODE> is zero, <CODE>fseek</CODE> sets the
file-position indicator to indicate the end of the file.
</UL>

<P>The function defines no other combination of argument values.</P>

<H2><A NAME="fsetpos"><CODE>fsetpos</CODE></A></H2>

<PRE>int <B>fsetpos</B>(FILE *stream, const fpos_t *pos);</PRE>

<P>The function sets the file-position indicator for the stream
<CODE>stream</CODE> to the value stored in <CODE>*pos</CODE>,
clears the end-of-file indicator for the stream,
and returns zero if successful. Otherwise,
the function stores a positive value in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and returns a nonzero value.</P>

<H2><A NAME="ftell"><CODE>ftell</CODE></A></H2>

<PRE>long <B>ftell</B>(FILE *stream);</PRE>

<P>The function returns an encoded form of the file-position indicator
for the stream <CODE>stream</CODE> or stores a positive value in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns
the value -1. For a binary file, a successful return
value gives the number of bytes from the beginning of the file. For
a text file, target environments can vary on the representation and
range of encoded file-position indicator values.</P>

<H2><A NAME="fwrite"><CODE>fwrite</CODE></A></H2>

<PRE>size_t <B>fwrite</B>(const void *ptr,
    size_t size, size_t nelem, FILE *stream);</PRE>

<P>The function writes characters to the output stream <CODE>stream</CODE>,
accessing values from successive elements of the array whose first
element has the address <CODE>(char *)ptr</CODE> until the function writes
<CODE>size*nelem</CODE> characters or sets the error indicator. It returns
<CODE>n/size</CODE>, where <CODE>n</CODE>
is the number of characters it wrote.
If the function sets the error indicator,
the file-position indicator is indeterminate.</P>

<H2><A NAME="getc"><CODE>getc</CODE></A></H2>

<PRE>int <B>getc</B>(FILE *stream);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fgetc">fgetc</A>(stream)</CODE> except
that a macro version of <CODE>getc</CODE>
can evaluate <CODE>stream</CODE> more than once.</P>

<H2><A NAME="getchar"><CODE>getchar</CODE></A></H2>

<PRE>int <B>getchar</B>(void);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fgetc">fgetc</A>(stdin)</CODE>,
reading a character from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A></P>

<H2><A NAME="gets"><CODE>gets</CODE></A></H2>

<PRE>char *<B>gets</B>(char *s);</PRE>

<P>The function reads characters from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A>
and stores them in successive elements of the array whose first element
has the address <CODE>s</CODE> until the function reads
an <CODE><I>NL</I></CODE> character
(which is not stored) or sets the end-of-file or error indicator.
If <CODE>gets</CODE> reads any characters, it concludes by storing a null
character in the next element of the array. It returns <CODE>s</CODE> if
it reads any characters and has not set the error indicator for the
stream; otherwise, it returns a null pointer. If it sets the error
indicator, the array contents are indeterminate. The number of characters
that <CODE>gets</CODE> reads and stores cannot be limited. Use
<A HREF="#fgets"><CODE>fgets</CODE></A> instead.</P>

<H2><A NAME="_IOFBF"><CODE>_IOFBF</CODE></A></H2>

<PRE>#define <B>_IOFBF</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#setvbuf"><CODE>setvbuf</CODE></A> to indicate
<B><A NAME="full buffering">full buffering</A></B>.
(Flush the stream buffer only when it fills.)</P>

<H2><A NAME="_IOLBF"><CODE>_IOLBF</CODE></A></H2>

<PRE>#define <B>_IOLBF</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#setvbuf"><CODE>setvbuf</CODE></A> to indicate
<B><A NAME="line buffering">line buffering</A></B>.
(Flush the stream buffer at the end of a
<A HREF="lib_file.html#text lines">text line</A>.)</P>

<H2><A NAME="_IONBF"><CODE>_IONBF</CODE></A></H2>

<PRE>#define <B>_IONBF</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#setvbuf"><CODE>setvbuf</CODE></A> to indicate
<B><A NAME="no buffering">no buffering</A></B>.
(Flush the stream buffer at the end of each write operation.)</P>

<H2><A NAME="L_tmpnam"><CODE>L_tmpnam</CODE></A></H2>

<PRE>#define <B>L_tmpnam</B> <I>&lt;integer constant expression &gt; 0&gt;</I></PRE>

<P>The macro yields the number of characters that the target environment
requires for representing temporary filenames created by
<A HREF="#tmpnam"><CODE>tmpnam</CODE></A>.</P>

<H2><A NAME="NULL"><CODE>NULL</CODE></A></H2>

<PRE>#define <B>NULL</B> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B></PRE>

<P>The macro yields a null pointer constant that is usable as an
<A HREF="express.html#address constant expression">
address constant expression</A>.</P>

<H2><A NAME="perror"><CODE>perror</CODE></A></H2>

<PRE>void <B>perror</B>(const char *s);</PRE>

<P>The function writes a line of text to the stream
<A HREF="#stderr"><CODE>stderr</CODE></A>.
If <CODE>s</CODE> is not a null pointer,
the function first writes the
<A HREF="lib_over.html#C string">C string</A> <CODE>s</CODE>
(as if by calling
<CODE><A HREF="#fputs">fputs</A>(s, stderr)</CODE>),
followed by a colon (<CODE>:</CODE>) and a <CODE><I>space</I></CODE>.
It then writes the same message
<A HREF="lib_over.html#C string">C string</A> that is returned by
<CODE><A HREF="string.html#strerror">strerror</A>(errno)</CODE>,
converting the value stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>,
followed by an <CODE><I>NL</I></CODE>.</P>

<H2><A NAME="printf"><CODE>printf</CODE></A></H2>

<PRE>int <B>printf</B>(const char *format, ...);</PRE>

<P>The function
<A HREF="lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>.
It returns the number of characters generated,
or it returns a negative value if the function
sets the error indicator for the stream.</P>

<H2><A NAME="putc"><CODE>putc</CODE></A></H2>

<PRE>int <B>putc</B>(int c, FILE *stream);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fputc">fputc</A>(c, stream)</CODE>
except that a macro version of <CODE>putc</CODE>
can evaluate <CODE>stream</CODE> more than once.</P>

<H2><A NAME="putchar"><CODE>putchar</CODE></A></H2>

<PRE>int <B>putchar</B>(int c);</PRE>

<P>The function has the same effect as
<CODE><A HREF="#fputc">fputc</A>(c, stdout)</CODE>,
writing a character to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>.</P>

<H2><A NAME="puts"><CODE>puts</CODE></A></H2>

<PRE>int <B>puts</B>(const char *s);</PRE>

<P>The function accesses characters from the
<A HREF="lib_over.html#C string">C string</A> <CODE>s</CODE> and
writes them to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>. The function writes
an <CODE><I>NL</I></CODE> character to the stream
in place of the terminating null character.
It returns a nonnegative value if it has not set the
error indicator; otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="remove"><CODE>remove</CODE></A></H2>

<PRE>int <B>remove</B>(const char *filename);</PRE>

<P>The function removes the file with the filename <CODE>filename</CODE>
and returns zero if successful.
If the file is open when you remove it,
the result is implementation defined. After you remove it, you
cannot open it as an existing file.</P>

<H2><A NAME="rename"><CODE>rename</CODE></A></H2>

<PRE>int <B>rename</B>(const char *old, const char *new);</PRE>

<P>The function renames the file with the filename <CODE>old</CODE> to
have the filename <CODE>new</CODE> and returns zero if successful. If a
file with the filename <CODE>new</CODE> already exists,
the result is implementation defined.
After you rename it, you cannot open the file
with the filename <CODE>old</CODE>.</P>

<H2><A NAME="rewind"><CODE>rewind</CODE></A></H2>

<PRE>void <B>rewind</B>(FILE *stream);</PRE>

<P>The function calls
<CODE><A HREF="#fseek">fseek</A>(stream, 0L, SEEK_SET)</CODE>
and then clears the error indicator for the stream <CODE>stream</CODE>.</P>

<H2><A NAME="scanf"><CODE>scanf</CODE></A></H2>

<PRE>int <B>scanf</B>(const char *format, ...);</PRE>

<P>The function
<A HREF="lib_scan.html#Scan Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A>. It returns the number
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the
function does not store values before it sets the end-of-file or error
indicators for the stream.</P>

<H2><A NAME="SEEK_CUR"><CODE>SEEK_CUR</CODE></A></H2>

<PRE>#define <B>SEEK_CUR</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#fseek"><CODE>fseek</CODE></A>
to indicate seeking relative to the current
file-position indicator.</P>

<H2><A NAME="SEEK_END"><CODE>SEEK_END</CODE></A></H2>

<PRE>#define <B>SEEK_END</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#fseek"><CODE>fseek</CODE></A>
to indicate seeking relative to the end of the file.</P>

<H2><A NAME="SEEK_SET"><CODE>SEEK_SET</CODE></A></H2>

<PRE>#define <B>SEEK_SET</B> <I>&lt;integer constant expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#fseek"><CODE>fseek</CODE></A>
to indicate seeking relative to the beginning of the file.</P>

<H2><A NAME="setbuf"><CODE>setbuf</CODE></A></H2>

<PRE>void <B>setbuf</B>(FILE *stream, char *buf);</PRE>

<P>If <CODE>buf</CODE> is not a null pointer, the function calls
<CODE><A HREF="#setvbuf">setvbuf</A>(stream, buf,
__IOFBF, BUFSIZ)</CODE>,
specifying full buffering with
<A HREF="#_IOFBF"><CODE>_IOFBF</CODE></A>
and a buffer size of
<A HREF="#BUFSIZ"><CODE>BUFSIZ</CODE></A> characters.
Otherwise, the function calls
<CODE><A HREF="#setvbuf">setvbuf</A>(stream,
0, _IONBF, BUFSIZ)</CODE>,
specifying no buffering with
<A HREF="#_IONBF"><CODE>_IONBF</CODE></A>.</P>

<H2><A NAME="setvbuf"><CODE>setvbuf</CODE></A></H2>

<PRE>int <B>setvbuf</B>(FILE *stream, char *buf, int mode,
    size_t size);</PRE>

<P>The function sets the buffering mode for the stream <CODE>stream</CODE>
according to <CODE>buf</CODE>, <CODE>mode</CODE>, and <CODE>size</CODE>.
It returns zero if successful.
If <CODE>buf</CODE> is not a null pointer, then <CODE>buf</CODE>
is the address of the first element of an array of <I>char</I> of
size <CODE>size</CODE> that can be used as the stream buffer. Otherwise,
<CODE>setvbuf</CODE> can allocate a stream buffer that is freed when the
file is closed. For <CODE>mode</CODE> you must supply one of the following
values:</P>

<UL>
<LI><B><A HREF="#_IOFBF"><CODE>_IOFBF</CODE></A></B>
-- to indicate full buffering

<LI><B><A HREF="#_IOLBF"><CODE>_IOLBF</CODE></A></B>
-- to indicate line buffering

<LI><B><A HREF="#_IONBF"><CODE>_IONBF</CODE></A></B>
-- to indicate no buffering
</UL>

<P>You must call <CODE>setvbuf</CODE> after you call
<A HREF="#fopen"><CODE>fopen</CODE></A>
to associate a file with that stream and before you call a library
function that performs any other operation on the stream.</P>

<H2><A NAME="size_t"><CODE>size_t</CODE></A></H2>

<PRE>typedef <I>ui-type</I> <B>size_t</B>;</PRE>

<P>The type is the unsigned integer type <CODE><I>ui-type</I></CODE>
of an object that you declare to store the result of the
<A HREF="express.html#sizeof operator"><I>sizeof</I></A> operator.</P>

<H2><A NAME="sprintf"><CODE>sprintf</CODE></A></H2>

<PRE>int <B>sprintf</B>(char *s, const char *format, ...);</PRE>

<P>The function
<A HREF="lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose
first element has the address <CODE>s</CODE>. The function concludes by
storing a null character in the next location of the array. It returns
the number of characters generated -- not including the null character.

<H2><A NAME="sscanf"><CODE>sscanf</CODE></A></H2>

<PRE>int <B>sscanf</B>(const char *s, const char *format, ...);</PRE>

<P>The function
<A HREF="lib_scan.html#Scan Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It accesses each scanned
character from successive locations of the array object whose first
element has the address <CODE>s</CODE>.
It returns the number of items matched
and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>
if the function does not store
values before it accesses a null character from the array.</P>

<H2><A NAME="stderr"><CODE>stderr</CODE></A></H2>

<PRE>#define <B>stderr</B> <I>&lt;pointer to FILE rvalue&gt;</I></PRE>

<P>The macro yields a pointer to the object that controls the standard
error output stream.</P>

<H2><A NAME="stdin"><CODE>stdin</CODE></A></H2>

<PRE>#define <B>stdin</B> <I>&lt;pointer to FILE rvalue&gt;</I></PRE>

<P>The macro yields a pointer to the object that controls the standard
input stream.</P>

<H2><A NAME="stdout"><CODE>stdout</CODE></A></H2>

<PRE>#define <B>stdout</B> <I>&lt;pointer to FILE rvalue&gt;</I></PRE>

<P>The macro yields a pointer to the object that controls the standard
output stream.</P>

<H2><A NAME="tmpfile"><CODE>tmpfile</CODE></A></H2>

<PRE>FILE *<B>tmpfile</B>(void)</PRE>

<P>The function creates a temporary binary file with the filename
<CODE><I>temp-name</I></CODE> and then has the same effect as calling
<CODE><A HREF="#fopen">fopen</A>(<I>temp-name</I>,
"wb+")</CODE>.
The file <CODE><I>temp-name</I></CODE> is removed when the program closes
it, either by calling
<A HREF="#fclose"><CODE>fclose</CODE></A>
explicitly or at normal program termination.
The filename <CODE><I>temp-name</I></CODE> does not conflict with
any filenames that you create. If the open is successful, the function
returns a pointer to the object controlling the stream; otherwise,
it returns a null pointer.</P>

<H2><A NAME="TMP_MAX"><CODE>TMP_MAX</CODE></A></H2>

<PRE>#define <B>TMP_MAX</B> <I>&lt;integer constant expression &gt;= 25&gt;</I></PRE>

<P>The macro yields the minimum number of distinct filenames created
by the function
<A HREF="#tmpnam"><CODE>tmpnam</CODE></A>.</P>

<H2><A NAME="tmpnam"><CODE>tmpnam</CODE></A></H2>

<PRE>char *<B>tmpnam</B>(char *s);</PRE>

<P>The function creates a unique filename <CODE><I>temp-name</I></CODE> and
returns a pointer to the filename. If <CODE>s</CODE> is not a null pointer,
then <CODE>s</CODE> must be the address
of the first element of an array at least of size
<A HREF="#L_tmpnam"><CODE>L_tmpnam</CODE></A>.
The function stores <CODE><I>temp-name</I></CODE>
in the array and returns <CODE>s</CODE>.
Otherwise, if <CODE>s</CODE> is a null
pointer, the function stores <CODE><I>temp-name</I></CODE>
in a static-duration array and returns the address of its first element.
Subsequent calls to <CODE>tmpnam</CODE>
can alter the values stored in this array.</P>

<P>The function returns unique filenames for each of the first
<A HREF="#TMP_MAX"><CODE>TMP_MAX</CODE></A>
times it is called, after which its behavior is implementation defined.
The filename <CODE><I>temp-name</I></CODE>
does not conflict with any filenames that you create.</P>

<H2><A NAME="ungetc"><CODE>ungetc</CODE></A></H2>

<PRE>int <B>ungetc</B>(int c, FILE *stream);</PRE>

<P>If <CODE>c</CODE> is not equal to
<A HREF="#EOF"><CODE>EOF</CODE></A>, the function stores
<CODE>(unsigned char)c</CODE> in the object
whose address is <CODE>stream</CODE>
and clears the end-of-file indicator. If <CODE>c</CODE> equals
<A HREF="#EOF"><CODE>EOF</CODE></A>
or the store cannot occur, the function returns
<A HREF="#EOF"><CODE>EOF</CODE></A>; otherwise,
it returns <CODE>(unsigned char)c</CODE>. A subsequent library function
call that reads a character from the stream <CODE>stream</CODE> obtains
this stored value, which is then forgotten.</P>

<P>Thus, you can effectively
<B><A NAME="push back">push back</A></B> a character to a
stream after reading a character. (You need not push back the same
character that you read.) An implementation can let you push back
additional characters before you read the first one. You read the
characters in reverse order of pushing them back to the stream. You
cannot portably:</P>

<UL>
<LI>push back more than one character

<LI>push back a character if the file-position indicator is at the
beginning of the file

<LI>Call
<A HREF="#ftell"><CODE>ftell</CODE></A>
for a text file that has a character currently pushed back
</UL>

<P>A call to the functions
<A HREF="#fseek"><CODE>fseek</CODE></A>,
<A HREF="#fsetpos"><CODE>fsetpos</CODE></A>, or
<A HREF="#rewind"><CODE>rewind</CODE></A>
for the stream causes the stream to forget any pushed-back characters.
For a binary stream, the file-position indicator is decremented for
each character that is pushed back.</P>

<H2><A NAME="vfprintf"><CODE>vfprintf</CODE></A></H2>

<PRE>int <B>vfprintf</B>(FILE *stream, const char *format,
     va_list ap);</PRE>

<P>The function
<A HREF="lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream <CODE>stream</CODE>.
It returns the number
of characters generated, or it returns a negative value if the function
sets the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vprintf"><CODE>vprintf</CODE></A></H2>

<PRE>int <B>vprintf</B>(const char *format,
    va_list ap);</PRE>

<P>The function
<A HREF="lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes
each generated character to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>.
It returns the number of characters generated,
or a negative value if the function sets
the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vsprintf"><CODE>vsprintf</CODE></A></H2>

<PRE>int <B>vsprintf</B>(char *s, const char *format,
    va_list ap);</PRE>

<P>The function
<A HREF="lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose
first element has the address <CODE>s</CODE>. The function concludes by
storing a null character in the next location of the array. It returns
the number of characters generated -- not including the null character.</P>

<P>The function accesses additional arguments by using the context
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pb.html">Copyright</A> &#169; 1989-2002
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

<!--V4.02:1476--></BODY></HTML>
