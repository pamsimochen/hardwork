<HTML><HEAD><TITLE>&lt;string&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;string&gt;"><CODE>&lt;string&gt;</CODE></A></H1><HR>

<P><B><CODE><A HREF="#basic_string">basic_string</A>
&#183; <A HREF="#char_traits">char_traits</A>
&#183; <A HREF="#char_traits&lt;char&gt;">char_traits&lt;char&gt;</A>
&#183; <A HREF="#char_traits&lt;wchar_t&gt;">char_traits&lt;wchar_t&gt;</A>
&#183; <A HREF="#getline">getline</A>
&#183; <A HREF="#operator+">operator+</A>
&#183; <A HREF="#operator!=">operator!=</A>
&#183; <A HREF="#operator==">operator==</A>
&#183; <A HREF="#operator&lt;">operator&lt;</A>
&#183; <A HREF="#operator&lt;&lt;">operator&lt;&lt;</A>
&#183; <A HREF="#operator&lt;=">operator&lt;=</A>
&#183; <A HREF="#operator&gt;">operator&gt;</A>
&#183; <A HREF="#operator&gt;=">operator&gt;=</A>
&#183; <A HREF="#operator&gt;&gt;">operator&gt;&gt;</A>
&#183; <A HREF="#string">string</A>
&#183; <A HREF="#swap">swap</A>
&#183; <A HREF="#wstring">wstring</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;string&gt;</CODE></B>
to define the
<A HREF="lib_cont.html#Containers">container</A>
template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A> and various
supporting templates.</P>

<PRE>namespace std {
template&lt;class Elem&gt;
    class <B><A HREF="#char_traits">char_traits</A></B>;
template&lt;&gt;
    class <B><A HREF="#char_traits&lt;char&gt;">char_traits&lt;char&gt;</A></B>;
template&lt;&gt;
    class <B><A HREF="#char_traits&lt;wchar_t&gt;">char_traits&lt;wchar_t&gt;</A></B>;
template&lt;class Elem,
    class Tr = char_traits&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B><A HREF="#basic_string">basic_string</A></B>;
typedef basic_string&lt;char&gt; <B><A HREF="#string">string</A></B>;
typedef basic_string&lt;wchar_t&gt; <B><A HREF="#wstring">wstring</A></B>;

        // TEMPLATE FUNCTIONS
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#operator+">operator+</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#operator+">operator+</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#operator+">operator+</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        Elem right);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#operator+">operator+</A></B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_string&lt;Elem, Tr, Alloc&gt; <B><A HREF="#operator+">operator+</A></B>(
        Elem left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator==">operator==</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator==">operator==</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator==">operator==</A></B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator!=">operator!=</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator!=">operator!=</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator!=">operator!=</A></B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&lt;">operator&lt;</A></B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&gt;">operator&gt;</A></B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&lt;=">operator&lt;=</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&lt;=">operator&lt;=</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&lt;=">operator&lt;=</A></B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&gt;=">operator&gt;=</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&gt;=">operator&gt;=</A></B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B><A HREF="#operator&gt;=">operator&gt;=</A></B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    void <B><A HREF="#swap">swap</A></B>(
        basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_ostream&lt;Elem&gt;&amp; <B><A HREF="#operator&lt;&lt;">operator&lt;&lt;</A></B>(
        basic_ostream&lt;Elem&gt;&amp; ostr,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_istream&lt;Elem&gt;&amp; <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(
        basic_istream&lt;Elem&gt;&amp; istr,
        basic_string&lt;Elem, Tr, Alloc&gt;&amp; str);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_istream&lt;Elem, Tr&gt;&amp; <B><A HREF="#getline">getline</A></B>(
        basic_istream&lt;Elem, Tr&gt;&amp; istr,
        basic_string&lt;Elem, Tr, Alloc&gt;&amp; str);
 template&lt;class Elem, class Tr, class Alloc&gt;
    basic_istream&lt;Elem, Tr&gt;&amp; <B><A HREF="#getline">getline</A></B>(
        basic_istream&lt;Elem, Tr&gt;&amp; istr,
        basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
        Elem delim);
    };</PRE>

<H2><A NAME="basic_string"><CODE>basic_string</CODE></A></H2>

<HR>
<P><B><CODE><A HREF="#basic_string::basic_string">basic_string</A>
&#183; <A HREF="#basic_string::allocator_type">allocator_type</A>
&#183; <A HREF="#basic_string::append">append</A>
&#183; <A HREF="#basic_string::assign">assign</A>
&#183; <A HREF="#basic_string::at">at</A>
&#183; <A HREF="#basic_string::begin">begin</A>
&#183; <A HREF="#basic_string::c_str">c_str</A>
&#183; <A HREF="#basic_string::capacity">capacity</A>
&#183; <A HREF="#basic_string::clear">clear</A>
&#183; <A HREF="#basic_string::compare">compare</A>
&#183; <A HREF="#basic_string::const_iterator">const_iterator</A>
&#183; <A HREF="#basic_string::const_pointer">const_pointer</A>
&#183; <A HREF="#basic_string::const_reference">const_reference</A>
&#183; <A HREF="#basic_string::const_reverse_iterator">const_reverse_iterator</A>
&#183; <A HREF="#basic_string::copy">copy</A>
&#183; <A HREF="#basic_string::data">data</A>
&#183; <A HREF="#basic_string::difference_type">difference_type</A>
&#183; <A HREF="#basic_string::empty">empty</A>
&#183; <A HREF="#basic_string::end">end</A>
&#183; <A HREF="#basic_string::erase">erase</A>
&#183; <A HREF="#basic_string::find">find</A>
&#183; <A HREF="#basic_string::find_first_not_of">find_first_not_of</A>
&#183; <A HREF="#basic_string::find_first_of">find_first_of</A>
&#183; <A HREF="#basic_string::find_last_not_of">find_last_not_of</A>
&#183; <A HREF="#basic_string::find_last_of">find_last_of</A>
&#183; <A HREF="#basic_string::get_allocator">get_allocator</A>
&#183; <A HREF="#basic_string::insert">insert</A>
&#183; <A HREF="#basic_string::iterator">iterator</A>
&#183; <A HREF="#basic_string::length">length</A>
&#183; <A HREF="#basic_string::max_size">max_size</A>
&#183; <A HREF="#basic_string::npos">npos</A>
&#183; <A HREF="#basic_string::operator+=">operator+=</A>
&#183; <A HREF="#basic_string::operator=">operator=</A>
&#183; <A HREF="#basic_string::operator[]">operator[]</A>
&#183; <A HREF="#basic_string::pointer">pointer</A>
&#183; <A HREF="#basic_string::push_back">push_back</A>
&#183; <A HREF="#basic_string::rbegin">rbegin</A>
&#183; <A HREF="#basic_string::reference">reference</A>
&#183; <A HREF="#basic_string::rend">rend</A>
&#183; <A HREF="#basic_string::replace">replace</A>
&#183; <A HREF="#basic_string::reserve">reserve</A>
&#183; <A HREF="#basic_string::resize">resize</A>
&#183; <A HREF="#basic_string::reverse_iterator">reverse_iterator</A>
&#183; <A HREF="#basic_string::rfind">rfind</A>
&#183; <A HREF="#basic_string::size">size</A>
&#183; <A HREF="#basic_string::size_type">size_type</A>
&#183; <A HREF="#basic_string::substr">substr</A>
&#183; <A HREF="#basic_string::swap">swap</A>
&#183; <A HREF="#basic_string::traits_type">traits_type</A>
&#183; <A HREF="#basic_string::value_type">value_type</A>
</CODE></B></P>
<HR>

<PRE>template&lt;class Elem,
    class Tr = <A HREF="#char_traits">char_traits</A>&lt;Elem&gt;,
    class Alloc = allocator&lt;Elem&gt; &gt;
    class <B>basic_string</B> {
public:
    typedef Tr <B><A HREF="#basic_string::traits_type">traits_type</A></B>;
    typedef Alloc <B><A HREF="#basic_string::allocator_type">allocator_type</A></B>;
    typedef T0 <B><A HREF="#basic_string::iterator">iterator</A></B>;
    typedef T1 <B><A HREF="#basic_string::const_iterator">const_iterator</A></B>;
    typedef T2 <B><A HREF="#basic_string::size_type">size_type</A></B>;
    typedef T3 <B><A HREF="#basic_string::difference_type">difference_type</A></B>;
    typedef reverse_iterator&lt;const_iterator&gt;
        <B><A HREF="#basic_string::const_reverse_iterator">const_reverse_iterator</A></B>;
    typedef reverse_iterator&lt;iterator&gt;
        <B><A HREF="#basic_string::reverse_iterator">reverse_iterator</A></B>;
    typedef typename allocator_type::pointer
        <B><A HREF="#basic_string::pointer">pointer</A></B>;
    typedef typename allocator_type::const_pointer
        <B><A HREF="#basic_string::const_pointer">const_pointer</A></B>;
    typedef typename allocator_type::reference
        <B><A HREF="#basic_string::reference">reference</A></B>;
    typedef typename allocator_type::const_reference
        <B><A HREF="#basic_string::const_reference">const_reference</A></B>;
    typedef typename allocator_type::value_type
        <B><A HREF="#basic_string::value_type">value_type</A></B>;
    static const size_type <B><A HREF="#basic_string::npos">npos</A></B> = -1;
    <B><A HREF="#basic_string::basic_string">basic_string</A></B>();
    explicit <B><A HREF="#basic_string::basic_string">basic_string</A></B>(const allocator_type&amp; al);
    <B><A HREF="#basic_string::basic_string">basic_string</A></B>(const basic_string&amp; right);
    <B><A HREF="#basic_string::basic_string">basic_string</A></B>(const basic_string&amp; right, size_type roff,
        size_type count = npos);
    <B><A HREF="#basic_string::basic_string">basic_string</A></B>(const basic_string&amp; right, size_type roff,
        size_type count, const allocator_type&amp; al);
    <B><A HREF="#basic_string::basic_string">basic_string</A></B>(const value_type *ptr, size_type count);
    <B><A HREF="#basic_string::basic_string">basic_string</A></B>(const value_type *ptr, size_type count,
        const allocator_type&amp; al);
    <B><A HREF="#basic_string::basic_string">basic_string</A></B>(const value_type *ptr);
    <B><A HREF="#basic_string::basic_string">basic_string</A></B>(const value_type *ptr,
        const allocator_type&amp; al);
    <B><A HREF="#basic_string::basic_string">basic_string</A></B>(size_type count, value_type ch);
    <B><A HREF="#basic_string::basic_string">basic_string</A></B>(size_type count, value_type ch,
        const allocator_type&amp; al);
    template &lt;class InIt&gt;
        <B><A HREF="#basic_string::basic_string">basic_string</A></B>(InIt first, InIt last);
    template &lt;class InIt&gt;
        <B><A HREF="#basic_string::basic_string">basic_string</A></B>(InIt first, InIt last,
            const allocator_type&amp; al);
    basic_string&amp; <B><A HREF="#basic_string::operator=">operator=</A></B>(const basic_string&amp; right);
    basic_string&amp; <B><A HREF="#basic_string::operator=">operator=</A></B>(const value_type *ptr);
    basic_string&amp; <B><A HREF="#basic_string::operator=">operator=</A></B>(value_type ch);
    iterator <B><A HREF="#basic_string::begin">begin</A></B>();
    const_iterator <B><A HREF="#basic_string::begin">begin</A></B>() const;
    iterator <B><A HREF="#basic_string::end">end</A></B>();
    const_iterator <B><A HREF="#basic_string::end">end</A></B>() const;
    reverse_iterator <B><A HREF="#basic_string::rbegin">rbegin</A></B>();
    const_reverse_iterator <B><A HREF="#basic_string::rbegin">rbegin</A></B>() const;
    reverse_iterator <B><A HREF="#basic_string::rend">rend</A></B>();
    const_reverse_iterator <B><A HREF="#basic_string::rend">rend</A></B>() const;
    const_reference <B><A HREF="#basic_string::at">at</A></B>(size_type off) const;
    reference <B><A HREF="#basic_string::at">at</A></B>(size_type off);
    const_reference <B><A HREF="#basic_string::operator[]">operator[]</A></B>(size_type off) const;
    reference <B><A HREF="#basic_string::operator[]">operator[]</A></B>(size_type off);
    void <B><A HREF="#basic_string::push_back">push_back</A></B>(value_type ch);
    const value_type *<B><A HREF="#basic_string::c_str">c_str</A></B>() const;
    const value_type *<B><A HREF="#basic_string::data">data</A></B>() const;
    size_type <B><A HREF="#basic_string::length">length</A></B>() const;
    size_type <B><A HREF="#basic_string::size">size</A></B>() const;
    size_type <B><A HREF="#basic_string::max_size">max_size</A></B>() const;
    void <B><A HREF="#basic_string::resize">resize</A></B>(size_type newsize, value_type ch = value_type());
    size_type <B><A HREF="#basic_string::capacity">capacity</A></B>() const;
    void <B><A HREF="#basic_string::reserve">reserve</A></B>(size_type count = 0);
    bool <B><A HREF="#basic_string::empty">empty</A></B>() const;
    basic_string&amp; <B><A HREF="#basic_string::operator+=">operator+=</A></B>(const basic_string&amp; right);
    basic_string&amp; <B><A HREF="#basic_string::operator+=">operator+=</A></B>(const value_type *ptr);
    basic_string&amp; <B><A HREF="#basic_string::operator+=">operator+=</A></B>(value_type ch);</PRE>

<PRE>    basic_string&amp; <B><A HREF="#basic_string::append">append</A></B>(const basic_string&amp; right);
    basic_string&amp; <B><A HREF="#basic_string::append">append</A></B>(const basic_string&amp; right,
        size_type roff, size_type count);
    basic_string&amp; <B><A HREF="#basic_string::append">append</A></B>(const value_type *ptr,
        size_type count);
    basic_string&amp; <B><A HREF="#basic_string::append">append</A></B>(const value_type *ptr);
    basic_string&amp; <B><A HREF="#basic_string::append">append</A></B>(size_type count, value_type ch);
    template&lt;class InIt&gt;
        basic_string&amp; <B><A HREF="#basic_string::append">append</A></B>(InIt first, InIt last);
    basic_string&amp; <B><A HREF="#basic_string::assign">assign</A></B>(const basic_string&amp; right);
    basic_string&amp; <B><A HREF="#basic_string::assign">assign</A></B>(const basic_string&amp; right,
        size_type roff, size_type count);
    basic_string&amp; <B><A HREF="#basic_string::assign">assign</A></B>(const value_type *ptr,
        size_type count);
    basic_string&amp; <B><A HREF="#basic_string::assign">assign</A></B>(const value_type *ptr);
    basic_string&amp; <B><A HREF="#basic_string::assign">assign</A></B>(size_type count, value_type ch);
    template&lt;class InIt&gt;
        basic_string&amp; <B><A HREF="#basic_string::assign">assign</A></B>(InIt first, InIt last);
    basic_string&amp; <B><A HREF="#basic_string::insert">insert</A></B>(size_type off,
        const basic_string&amp; right);
    basic_string&amp; <B><A HREF="#basic_string::insert">insert</A></B>(size_type off,
        const basic_string&amp; right, size_type roff,
            size_type count);
    basic_string&amp; <B><A HREF="#basic_string::insert">insert</A></B>(size_type off,
        const value_type *ptr, size_type count);
    basic_string&amp; <B><A HREF="#basic_string::insert">insert</A></B>(size_type off,
        const value_type *ptr);
    basic_string&amp; <B><A HREF="#basic_string::insert">insert</A></B>(size_type off,
        size_type count, value_type ch);
    iterator <B><A HREF="#basic_string::insert">insert</A></B>(iterator where,
        value_type ch = value_type());
    void <B><A HREF="#basic_string::insert">insert</A></B>(iterator where, size_type count, value_type ch);
    template&lt;class InIt&gt;
        void <B><A HREF="#basic_string::insert">insert</A></B>(iterator where,
            InIt first, InIt last);
    basic_string&amp; <B><A HREF="#basic_string::erase">erase</A></B>(size_type off = 0,
        size_type count = npos);
    iterator <B><A HREF="#basic_string::erase">erase</A></B>(iterator where);
    iterator <B><A HREF="#basic_string::erase">erase</A></B>(iterator first, iterator last);
    void <B><A HREF="#basic_string::clear">clear</A></B>();
    basic_string&amp; <B><A HREF="#basic_string::replace">replace</A></B>(size_type off, size_type n0,
        const basic_string&amp; right);
    basic_string&amp; <B><A HREF="#basic_string::replace">replace</A></B>(size_type off, size_type n0,
        const basic_string&amp; right, size_type roff,
            size_type count);
    basic_string&amp; <B><A HREF="#basic_string::replace">replace</A></B>(size_type off, size_type n0,
        const value_type *ptr, size_type count);
    basic_string&amp; <B><A HREF="#basic_string::replace">replace</A></B>(size_type off, size_type n0,
        const value_type *ptr);
    basic_string&amp; <B><A HREF="#basic_string::replace">replace</A></B>(size_type off, size_type n0,
        size_type count, value_type ch);
    basic_string&amp; <B><A HREF="#basic_string::replace">replace</A></B>(iterator first, iterator last,
        const basic_string&amp; right);
    basic_string&amp; <B><A HREF="#basic_string::replace">replace</A></B>(iterator first, iterator last,
        const value_type *ptr, size_type count);
    basic_string&amp; <B><A HREF="#basic_string::replace">replace</A></B>(iterator first, iterator last,
        const value_type *ptr);
    basic_string&amp; <B><A HREF="#basic_string::replace">replace</A></B>(iterator first, iterator last,
        size_type count, value_type ch);
    template&lt;class InIt&gt;
        basic_string&amp;
            <B><A HREF="#basic_string::replace">replace</A></B>(iterator first, iterator last,
                InIt first2, InIt last2);
    size_type <B><A HREF="#basic_string::copy">copy</A></B>(value_type *ptr, size_type count,
        size_type off = 0) const;
    void <B><A HREF="#basic_string::swap">swap</A></B>(basic_string&amp; right);</PRE>

<PRE>    size_type <B><A HREF="#basic_string::find">find</A></B>(const basic_string&amp; right,
        size_type off = 0) const;
    size_type <B><A HREF="#basic_string::find">find</A></B>(const value_type *ptr, size_type off,
        size_type count) const;
    size_type <B><A HREF="#basic_string::find">find</A></B>(const value_type *ptr,
        size_type off = 0) const;
    size_type <B><A HREF="#basic_string::find">find</A></B>(value_type ch, size_type off = 0) const;
    size_type <B><A HREF="#basic_string::find">rfind</A></B>(const basic_string&amp; right,
        size_type off = npos) const;
    size_type <B><A HREF="#basic_string::rfind">rfind</A></B>(const value_type *ptr, size_type off,
        size_type count = npos) const;
    size_type <B><A HREF="#basic_string::rfind">rfind</A></B>(const value_type *ptr,
        size_type off = npos) const;
    size_type <B><A HREF="#basic_string::rfind">rfind</A></B>(value_type ch,
        size_type off = npos) const;
    size_type <B><A HREF="#basic_string::rfind">find_first_of</A></B>(const basic_string&amp; right,
        size_type off = 0) const;
    size_type <B><A HREF="#basic_string::rfind">find_first_of</A></B>(const value_type *ptr,
        size_type off, size_type count) const;
    size_type <B><A HREF="#basic_string::find_first_of">find_first_of</A></B>(const value_type *ptr,
        size_type off = 0) const;
    size_type <B><A HREF="#basic_string::find_first_of">find_first_of</A></B>(value_type ch,
        size_type off = 0) const;
    size_type <B><A HREF="#basic_string::find_last_of">find_last_of</A></B>(const basic_string&amp; right,
        size_type off = npos) const;
    size_type <B><A HREF="#basic_string::find_last_of">find_last_of</A></B>(const value_type *ptr,
        size_type off, size_type count = npos) const;
    size_type <B><A HREF="#basic_string::find_last_of">find_last_of</A></B>(const value_type *ptr,
        size_type off = npos) const;
    size_type <B><A HREF="#basic_string::find_last_of">find_last_of</A></B>(value_type ch,
        size_type off = npos) const;
    size_type <B><A HREF="#basic_string::find_first_not_of">find_first_not_of</A></B>(const basic_string&amp; right,
        size_type off = 0) const;
    size_type <B><A HREF="#basic_string::find_first_not_of">find_first_not_of</A></B>(const value_type *ptr,
        size_type off, size_type count) const;
    size_type <B><A HREF="#basic_string::find_first_not_of">find_first_not_of</A></B>(const value_type *ptr,
        size_type off = 0) const;
    size_type <B><A HREF="#basic_string::find_first_not_of">find_first_not_of</A></B>(value_type ch,
        size_type off = 0) const;
    size_type <B><A HREF="#basic_string::find_last_not_of">find_last_not_of</A></B>(const basic_string&amp; right,
        size_type off = npos) const;
    size_type <B><A HREF="#basic_string::find_last_not_of">find_last_not_of</A></B>(const value_type *ptr,
        size_type off, size_type count) const;
    size_type <B><A HREF="#basic_string::find_last_not_of">find_last_not_of</A></B>(const value_type *ptr,
        size_type off = npos) const;
    size_type <B><A HREF="#basic_string::find_last_not_of">find_last_not_of</A></B>(value_type ch,
        size_type off = npos) const;
    basic_string <B><A HREF="#basic_string::substr">substr</A></B>(size_type off = 0,
        size_type count = npos) const;
    int <B><A HREF="#basic_string::compare">compare</A></B>(const basic_string&amp; right) const;
    int <B><A HREF="#basic_string::compare">compare</A></B>(size_type off, size_type n0,
        const basic_string&amp; right) const;
    int <B><A HREF="#basic_string::compare">compare</A></B>(size_type off, size_type n0,
        const basic_string&amp; right, size_type roff,
            size_type count) const;
    int <B><A HREF="#basic_string::compare">compare</A></B>(const value_type *ptr) const;
    int <B><A HREF="#basic_string::compare">compare</A></B>(size_type off, size_type n0,
        const value_type *ptr) const;
    int <B><A HREF="#basic_string::compare">compare</A></B>(size_type off, size_type n0,
        const value_type *ptr, size_type off) const;
    allocator_type <B><A HREF="#basic_string::get_allocator">get_allocator</A></B>() const;
    };</PRE>

<P>The template class describes an object that controls a
varying-length sequence of elements of type <CODE>Elem</CODE>,
also known as
<CODE><A HREF="#basic_string::value_type">value_type</A></CODE>.
Such an element type must not require explicit construction or
destruction, and it must be suitable for use as the <CODE>Elem</CODE>
parameter to
<A HREF="istream.html#basic_istream"><CODE>basic_istream</CODE></A> or
<A HREF="ostream.html#basic_ostream"><CODE>basic_ostream</CODE></A>.
(A ``plain old data structure,'' or
<B><A NAME="POD">POD</A></B>, from C generally meets
this criterion.)
The Standard C++ library provides two specializations of this template
class, with the type definitions
<A HREF="#string"><CODE>string</CODE></A>,
for elements of type <I>char,</I> and
<A HREF="#wstring"><CODE>wstring</CODE></A>, for elements of type
<CODE>wchar_t</CODE>.</P>

<P>Various important properties of the elements
in a <CODE>basic_string</CODE>
specialization are described by the class <CODE>Tr</CODE>, also known as
<CODE><A HREF="#basic_string::traits_type">traits_type</A></CODE>.
A class that specifies these
<A HREF="#character traits">character traits</A> must
have the same external interface as an object of template class
<A HREF="#char_traits"><CODE>char_traits</CODE></A>.</P>

<P>The object allocates and frees storage for the sequence it controls
through a stored <A HREF="memory.html#allocator object">allocator object</A>
of class <CODE>Alloc</CODE>, also known as
<CODE><A HREF="#basic_string::allocator_type">allocator_type</A></CODE>.
Such an allocator object must have
the same external interface as an object of template class
<A HREF="memory.html#allocator"><CODE>allocator</CODE></A>.
(Class
<A HREF="#char_traits"><CODE>char_traits</CODE></A> has
no provision for alternate addressing schemes, such as might be required
to implement a
<A HREF="memory.html#far heap">far heap</A>.)
Note that the stored allocator object is <I>not</I> copied when the container
object is assigned.</P>

<P>The sequences controlled by an object of template class
<CODE>basic_string</CODE> are usually called
<B><A NAME="strings">strings</A></B>. These objects should not be
confused, however, with the null-terminated
<A HREF="lib_over.html#C string">C strings</A> used throughout the
Standard C++ library.</P>

<P>Many member functions require an
<B><A NAME="operand sequence">operand sequence</A></B> of elements.
You can specify such an operand sequence several
ways:</P>

<UL>
<LI><CODE>ch</CODE> -- one element
with value <CODE>ch</CODE></LI>

<LI><CODE>count, ch</CODE> -- a repetition of <CODE>count</CODE> elements each
with value <CODE>ch</CODE></LI>

<LI><CODE>ptr</CODE> -- a null-terminated sequence
(such as a <A HREF="lib_over.html#C string">C string</A>,
for <CODE>Elem</CODE> of type <I>char</I>) beginning at
<CODE>ptr</CODE> (which must not be a null pointer),
where the terminating element is the value
<CODE>value_type()</CODE> and is not part of
the operand sequence</LI>

<LI><CODE>ptr, count</CODE> -- a sequence of <CODE>count</CODE> elements
beginning at <CODE>ptr</CODE> (which must not be a null pointer)</LI>

<LI><CODE>right</CODE> -- the sequence specified by the
<CODE>basic_string</CODE> object <CODE>right</CODE></LI>

<LI><CODE>right, roff, count</CODE> -- the substring of the
<CODE>basic_string</CODE> object <CODE>right</CODE> with up to <CODE>count</CODE>
elements (or through the end of the string, whichever comes first)
beginning at position <CODE>roff</CODE></LI>

<LI><CODE>first, last</CODE> -- a sequence of elements delimited
by the iterators <CODE>first</CODE> and <CODE>last</CODE>, in the
range <CODE>[first, last)</CODE>, which <I>may</I> overlap
the sequence controlled by the string object whose member function
is being called</LI>
</UL>

<P>If a <B><A NAME="position argument">position argument</A></B>
(such as <CODE>roff</CODE> above) is beyond the end of the string on a
call to a <CODE>basic_string</CODE> member function, the function
reports an
<B><A NAME="out-of-range error">out-of-range error</A></B> by
throwing an object of class
<A HREF="stdexcep.html#out_of_range"><CODE>out_of_range</CODE></A>.</P>

<P>If a function is asked to generate a sequence longer than
<CODE><A HREF="#basic_string::max_size">max_size</A>()</CODE> elements,
the function reports a
<B><A NAME="length error">length error</A></B> by
throwing an object of class
<A HREF="stdexcep.html#length_error"><CODE>length_error</CODE></A>.</P>

<P>References, pointers, and iterators that designate elements of the
controlled sequence can become invalid after any call to a function
that alters the controlled sequence, or after the first call to the
non-const member functions
<CODE><A HREF="#basic_string::at">at</A></CODE>,
<CODE><A HREF="#basic_string::begin">begin</A></CODE>,
<CODE><A HREF="#basic_string::end">end</A></CODE>,
<CODE><A HREF="#basic_string::operator[]">operator[]</A></CODE>,
<CODE><A HREF="#basic_string::rbegin">rbegin</A></CODE>, or
<CODE><A HREF="#basic_string::rend">rend</A></CODE>.
(The idea is to permit multiple strings to share the same representation
until one string becomes a candidate for change, at which point that string
makes a private copy of the representation, using a discipline called
<B><A NAME="copy on write">copy on write</A></B>.)</P>

<H3><CODE><A NAME="basic_string::allocator_type">basic_string::allocator_type</A></CODE></H3>

<PRE>typedef Alloc <B>allocator_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Alloc</CODE>.</P>

<H3><CODE><A NAME="basic_string::append">basic_string::append</A></CODE></H3>

<PRE>basic_string&amp; <B>append</B>(const value_type *ptr);
basic_string&amp; <B>append</B>(const value_type *ptr,
    size_type count);
basic_string&amp; <B>append</B>(const basic_string&amp; right,
    size_type roff, size_type count);
basic_string&amp; <B>append</B>(const basic_string&amp; right);
basic_string&amp; <B>append</B>(size_type count, value_type ch);
template&lt;class InIt&gt;
    basic_string&amp; <B>append</B>(InIt first, InIt last);</PRE>

<P>If <CODE>InIt</CODE> is an integer type, the template member
function behaves the same as <CODE>append((size_type)first, (value_type)last)</CODE>.
Otherwise, the
member functions each append the
<A HREF="#operand sequence">operand sequence</A> to the end of the
sequence controlled by <CODE>*this</CODE>,
then return <CODE>*this</CODE>.</P>

<P>In this
<A HREF="index.html#implementation">implementation</A>, if a
translator does not support member template functions, the template:</P>

<PRE>template&lt;class InIt&gt;
    basic_string&amp; <B>append</B>(InIt first, InIt last);</PRE>

<P>is replaced by:</P>

<PRE>basic_string&amp; <B>append</B>(const_pointer first,
    const_pointer last);</PRE>

<H3><CODE><A NAME="basic_string::assign">basic_string::assign</A></CODE></H3>

<PRE>basic_string&amp; <B>assign</B>(const value_type *ptr);
basic_string&amp; <B>assign</B>(const value_type *ptr,
    size_type count);
basic_string&amp; <B>assign</B>(const basic_string&amp; right,
    size_type roff, size_type count);
basic_string&amp; <B>assign</B>(const basic_string&amp; right);
basic_string&amp; <B>assign</B>(size_type count, value_type ch);
template&lt;class InIt&gt;
    basic_string&amp; <B>assign</B>(InIt first, InIt last);</PRE>

<P>If <CODE>InIt</CODE> is an integer type, the template member
function behaves the same as <CODE>assign((size_type)first, (value_type)last)</CODE>.
Otherwise, the
member functions each replace
the sequence controlled by <CODE>*this</CODE> with the
<A HREF="#operand sequence">operand sequence</A>, then return <CODE>*this</CODE>.</P>

<P>In this
<A HREF="index.html#implementation">implementation</A>, if a
translator does not support member template functions, the template:</P>

<PRE>template&lt;class InIt&gt;
    basic_string&amp; <B>assign</B>(InIt first, InIt last);</PRE>

<P>is replaced by:</P>

<PRE>basic_string&amp; <B>assign</B>(const_pointer first,
    const_pointer last);</PRE>

<H3><CODE><A NAME="basic_string::at">basic_string::at</A></CODE></H3>

<PRE>const_reference <B>at</B>(size_type off) const;
reference <B>at</B>(size_type off);</PRE>

<P>The member functions each return a reference to the element of the
controlled sequence at position <CODE>off</CODE>,
or report an <A HREF="#out-of-range error">out-of-range error</A>.</P>

<H3><CODE><A NAME="basic_string::basic_string">basic_string::basic_string</A></CODE></H3>

<PRE><B>basic_string</B>(const value_type *ptr);
<B>basic_string</B>(const value_type *ptr,
    const allocator_type&amp; al);
<B>basic_string</B>(const value_type *ptr, size_type count);
<B>basic_string</B>(const value_type *ptr, size_type count,
    const allocator_type&amp; al);
<B>basic_string</B>(const basic_string&amp; right);
<B>basic_string</B>(const basic_string&amp; right, size_type roff,
    size_type count = npos);
<B>basic_string</B>(const basic_string&amp; right, size_type roff,
    size_type count, const allocator_type&amp; al);
<B>basic_string</B>(size_type count, value_type ch);
<B>basic_string</B>(size_type count, value_type ch,
    const allocator_type&amp; al);
<B>basic_string</B>();
explicit <B>basic_string</B>(const allocator_type&amp; al);
template &lt;class InIt&gt;
    <B>basic_string</B>(InIt first, InIt last);
template &lt;class InIt&gt;
    <B>basic_string</B>(InIt first, InIt last, const allocator_type&amp; al);</PRE>

<P>All constructors store an
<A HREF="memory.html#allocator object">allocator object</A> and
initialize the controlled sequence. The allocator object is the argument
<CODE>al</CODE>, if present. For the copy constructor, it is
<CODE>right.<A HREF="#basic_string::get_allocator">get_allocator</A>()</CODE>.
Otherwise, it is <CODE>Alloc()</CODE>.</P>

<P>The controlled sequence is initialized to a copy of the
<A HREF="#operand sequence">operand sequence</A> specified by the
remaining operands. A constructor with no operand sequence specifies an
empty initial controlled sequence.
If <CODE>InIt</CODE> is an integer type in a template constructor,
the operand sequence <CODE>first, last</CODE> behaves the same as
<CODE>(size_type)first, (value_type)last</CODE>.</P>

<P>In this
<A HREF="index.html#implementation">implementation</A>, if a
translator does not support member template functions, the templates:</P>

<PRE>template &lt;class InIt&gt;
    <B>basic_string</B>(InIt first, InIt last);
template &lt;class InIt&gt;
    <B>basic_string</B>(InIt first, InIt last,
        const allocator_type&amp; al);</PRE>

<P>are replaced by:</P>

<PRE><B>basic_string</B>(const_pointer first, const_pointer last);
<B>basic_string</B>(const_pointer first, const_pointer last,
    const allocator_type&amp; al);</PRE>

<H3><CODE><A NAME="basic_string::begin">basic_string::begin</A></CODE></H3>

<PRE>const_iterator <B>begin</B>() const;
iterator <B>begin</B>();</PRE>

<P>The member functions each return a random-access iterator that points at
the first element of the sequence (or just beyond the end of an empty
sequence).</P>

<H3><CODE><A NAME="basic_string::c_str">basic_string::c_str</A></CODE></H3>

<PRE>const value_type <B>*c_str</B>() const;</PRE>

<P>The member function returns a pointer to a non-modifiable
<A HREF="lib_over.html#C string">C string</A> constructed by adding a
terminating null element
(<CODE>value_type()</CODE>) to the controlled
sequence. Calling any non-const member function for
<CODE>*this</CODE> can invalidate the pointer.</P>

<H3><CODE><A NAME="basic_string::capacity">basic_string::capacity</A></CODE></H3>

<PRE>size_type <B>capacity</B>() const;</PRE>

<P>The member function returns the storage currently allocated to hold
the controlled sequence, a value at least as large as
<CODE><A HREF="#basic_string::size">size</A>()</CODE>.</P>

<H3><CODE><A NAME="basic_string::clear">basic_string::clear</A></CODE></H3>

<PRE>void <B>clear</B>();</PRE>

<P>The member function calls
<CODE><A HREF="#basic_string::erase">erase</A>(
<A HREF="#basic_string::begin">begin</A>(),
<A HREF="#basic_string::end">end</A>())</CODE>.</P>

<H3><CODE><A NAME="basic_string::compare">basic_string::compare</A></CODE></H3>

<PRE>int <B>compare</B>(const basic_string&amp; right) const;
int <B>compare</B>(size_type off, size_type n0,
    const basic_string&amp; right) const;
int <B>compare</B>(size_type off, size_type n0,
    const basic_string&amp; right, size_type roff, size_type count) const;
int <B>compare</B>(const value_type *ptr) const;
int <B>compare</B>(size_type off, size_type n0,
    const value_type *ptr) const;
int <B>compare</B>(size_type off, size_type n0,
    const value_type *ptr, size_type off) const;</PRE>

<P>The member functions each compare up to <CODE>n0</CODE> elements of the
controlled sequence beginning with position <CODE>off</CODE>, or the
entire controlled sequence if these arguments are not supplied,
to the <A HREF="#operand sequence">operand sequence</A>.
Each function returns:</P>

<UL>
<LI>a negative value if the first differing element in the controlled
sequence compares less than the corresponding element in the operand
sequence (as determined by
<CODE>traits_type::<A HREF="#char_traits::compare">compare</A></CODE>), or if the
two have a common prefix but the operand sequence is longer</LI>

<LI>zero if the two compare equal element by element and are the same
length</LI>

<LI>a positive value otherwise</LI>
</UL>

<H3><CODE><A NAME="basic_string::const_iterator">basic_string::const_iterator</A></CODE></H3>

<PRE>typedef T1 <B>const_iterator</B>;</PRE>

<P>The type describes an object that can serve as a constant
random-access iterator for the controlled sequence.
It is described here as a
synonym for the implementation-defined type <CODE>T1</CODE>.</P>

<H3><CODE><A NAME="basic_string::const_pointer">basic_string::const_pointer</A></CODE></H3>

<PRE>typedef typename allocator_type::const_pointer
    <B>const_pointer</B>;</PRE>

<P>The type is a synonym for <CODE>allocator_type::const_pointer</CODE>.</P>

<H3><CODE><A NAME="basic_string::const_reference">basic_string::const_reference</A></CODE></H3>

<PRE>typedef typename allocator_type::const_reference
    <B>const_reference</B>;</PRE>

<P>The type is a synonym for <CODE>allocator_type::const_reference</CODE>.</P>

<H3><CODE><A NAME="basic_string::const_reverse_iterator">basic_string::const_reverse_iterator</A></CODE></H3>

<PRE>typedef reverse_iterator&lt;const_iterator&gt;
    <B>const_reverse_iterator</B>;</PRE>

<P>The type describes an object that can serve as a constant reverse
iterator for the controlled sequence.</P>

<H3><CODE><A NAME="basic_string::copy">basic_string::copy</A></CODE></H3>

<PRE>size_type <B>copy</B>(value_type *ptr, size_type count,
    size_type off = 0) const;</PRE>

<P>The member function copies up to <CODE>count</CODE> elements from the
controlled sequence, beginning at position <CODE>off</CODE>, to the
array of <CODE>value_type</CODE> beginning at <CODE>ptr</CODE>. It returns the
number of elements actually copied.</P>

<H3><CODE><A NAME="basic_string::data">basic_string::data</A></CODE></H3>

<PRE>const value_type <B>*data</B>() const;</PRE>

<P>The member function returns a pointer to the first element
of the sequence (or, for an empty sequence, a non-null pointer
that cannot be dereferenced).</P>

<H3><CODE><A NAME="basic_string::difference_type">basic_string::difference_type</A></CODE></H3>

<PRE>typedef T3 <B>difference_type</B>;</PRE>

<P>The signed integer type describes an object that can represent the
difference between the addresses of any two elements in the controlled
sequence. It is described here as a
synonym for the implementation-defined type <CODE>T3</CODE>.</P>

<H3><CODE><A NAME="basic_string::empty">basic_string::empty</A></CODE></H3>

<PRE>bool <B>empty</B>() const;</PRE>

<P>The member function returns true for an empty controlled sequence.</P>

<H3><CODE><A NAME="basic_string::end">basic_string::end</A></CODE></H3>

<PRE>const_iterator <B>end</B>() const;
iterator <B>end</B>();</PRE>

<P>The member functions each return a random-access iterator that points
just beyond the end of the sequence.</P>

<H3><CODE><A NAME="basic_string::erase">basic_string::erase</A></CODE></H3>

<PRE>iterator <B>erase</B>(iterator first, iterator last);
iterator <B>erase</B>(iterator where);
basic_string&amp; <B>erase</B>(size_type off = 0,
    size_type count = npos);</PRE>

<P>The first member function removes the elements of the controlled
sequence in the range <CODE>[first, last)</CODE>.
The second member function removes the element of the controlled
sequence pointed to by <CODE>where</CODE>.
Both return an iterator that designates the first element remaining
beyond any elements removed, or
<CODE><A HREF="#basic_string::end">end</A>()</CODE>
if no such element exists.</P>

<P>The third member function removes up to <CODE>count</CODE> elements of
the controlled sequence beginning at position <CODE>off</CODE>, then
returns <CODE>*this</CODE>.</P>

<H3><CODE><A NAME="basic_string::find">basic_string::find</A></CODE></H3>

<PRE>size_type <B>find</B>(value_type ch, size_type off = 0) const;
size_type <B>find</B>(const value_type *ptr,
    size_type off = 0) const;
size_type <B>find</B>(const value_type *ptr, size_type off,
    size_type count) const;
size_type <B>find</B>(const basic_string&amp; right,
    size_type off = 0) const;</PRE>

<P>The member functions each find the first (lowest beginning position)
subsequence in the controlled sequence, beginning on or after position
<CODE>off</CODE>, that matches the
<A HREF="#operand sequence">operand sequence</A> specified by the
remaining operands. If it succeeds, it returns the position where the
matching subsequence begins. Otherwise, the function returns
<CODE><A HREF="#basic_string::npos">npos</A></CODE>.</P>

<H3><CODE><A NAME="basic_string::find_first_not_of">basic_string::find_first_not_of</A></CODE></H3>

<PRE>size_type <B>find_first_not_of</B>(value_type ch,
    size_type off = 0) const;
size_type <B>find_first_not_of</B>(const value_type *ptr,
    size_type off = 0) const;
size_type <B>find_first_not_of</B>(const value_type *ptr,
    size_type off, size_type count) const;
size_type <B>find_first_not_of</B>(const basic_string&amp; right,
    size_type off = 0) const;</PRE>

<P>The member functions each find the first (lowest position) element of the
controlled sequence, at or after position <CODE>off</CODE>, that
matches <I>none</I> of the elements in the
<A HREF="#operand sequence">operand sequence</A> specified by the
remaining operands. If it succeeds, it returns the position. Otherwise,
the function returns
<CODE><A HREF="#basic_string::npos">npos</A></CODE>.</P>

<H3><CODE><A NAME="basic_string::find_first_of">basic_string::find_first_of</A></CODE></H3>

<PRE>size_type <B>find_first_of</B>(value_type ch,
    size_type off = 0) const;
size_type <B>find_first_of</B>(const value_type *ptr,
    size_type off = 0) const;
size_type <B>find_first_of</B>(const value_type *ptr,
    size_type off, size_type count) const;
size_type <B>find_first_of</B>(const basic_string&amp; right,
    size_type off = 0) const;</PRE>

<P>The member functions each find the first (lowest position) element of the
controlled sequence, at or after position <CODE>off</CODE>, that
matches <I>any</I> of the elements in the
<A HREF="#operand sequence">operand sequence</A> specified by the
remaining operands. If it succeeds, it returns the position. Otherwise,
the function returns
<CODE><A HREF="#basic_string::npos">npos</A></CODE>.</P>

<H3><CODE><A NAME="basic_string::find_last_not_of">basic_string::find_last_not_of</A></CODE></H3>

<PRE>size_type <B>find_last_not_of</B>(value_type ch,
    size_type off = npos) const;
size_type <B>find_last_not_of</B>(const value_type *ptr,
    size_type off = npos) const;
size_type <B>find_last_not_of</B>(const value_type *ptr,
    size_type off, size_type count) const;
size_type <B>find_last_not_of</B>(const basic_string&amp; right,
    size_type off = npos) const;</PRE>

<P>The member functions each find the last (highest position) element of the
controlled sequence, at or before position <CODE>off</CODE>, that
matches <I>none</I> of the elements in the
<A HREF="#operand sequence">operand sequence</A> specified by the
remaining operands. If it succeeds, it returns the position. Otherwise,
the function returns
<CODE><A HREF="#basic_string::npos">npos</A></CODE>.</P>

<H3><CODE><A NAME="basic_string::find_last_of">basic_string::find_last_of</A></CODE></H3>

<PRE>size_type <B>find_last_of</B>(value_type ch,
    size_type off = npos) const;
size_type <B>find_last_of</B>(const value_type *ptr,
    size_type off = npos) const;
size_type <B>find_last_of</B>(const value_type *ptr,
    size_type off, size_type count = npos) const;
size_type <B>find_last_of</B>(const basic_string&amp; right,
    size_type off = npos) const;</PRE>

<P>The member functions each find the last (highest position) element of the
controlled sequence, at or before position <CODE>off</CODE>, that
matches <I>any</I> of the elements in the
<A HREF="#operand sequence">operand sequence</A> specified by the
remaining operands. If it succeeds, it returns the position. Otherwise,
the function returns
<CODE><A HREF="#basic_string::npos">npos</A></CODE>.</P>

<H3><CODE><A NAME="basic_string::get_allocator">basic_string::get_allocator</A></CODE></H3>

<PRE>allocator_type <B>get_allocator</B>() const;</PRE>

<P>The member function returns the stored
<A HREF="memory.html#allocator object">allocator object</A>.</P>

<H3><CODE><A NAME="basic_string::insert">basic_string::insert</A></CODE></H3>

<PRE>basic_string&amp; <B>insert</B>(size_type off, const value_type *ptr);
basic_string&amp; <B>insert</B>(size_type off, const value_type *ptr,
    size_type count);
basic_string&amp; <B>insert</B>(size_type off,
    const basic_string&amp; right);
basic_string&amp; <B>insert</B>(size_type off,
    const basic_string&amp; right, size_type roff, size_type count);
basic_string&amp; <B>insert</B>(size_type off,
    size_type count, value_type ch);
iterator <B>insert</B>(iterator where,
    value_type ch = value_type());
template&lt;class InIt&gt;
    void <B>insert</B>(iterator where, InIt first, InIt last);
void <B>insert</B>(iterator where, size_type count, value_type ch);</PRE>

<P>The member functions each insert, before position <CODE>off</CODE> or
before the element pointed to by <CODE>where</CODE> in the controlled
sequence, the
<A HREF="#operand sequence">operand sequence</A> specified by the
remaining operands. A function that returns a value returns
<CODE>*this</CODE>.
If <CODE>InIt</CODE> is an integer type in the template member function,
the operand sequence <CODE>first, last</CODE> behaves the same as
<CODE>(size_type)first, (value_type)last</CODE>.</P>

<P>In this
<A HREF="index.html#implementation">implementation</A>, if a
translator does not support member template functions, the template:</P>

<PRE>template&lt;class InIt&gt;
    void <B>insert</B>(iterator where, InIt first, InIt last);</PRE>

<P>is replaced by:</P>

<PRE>void <B>insert</B>(iterator where,
    const_pointer first, const_pointer last);</PRE>

<H3><CODE><A NAME="basic_string::iterator">basic_string::iterator</A></CODE></H3>

<PRE>typedef T0 <B>iterator</B>;</PRE>

<P>The type describes an object that can serve as a random-access
iterator for the controlled sequence.
It is described here as a
synonym for the implementation-defined type <CODE>T0</CODE>.</P>

<H3><CODE><A NAME="basic_string::length">basic_string::length</A></CODE></H3>

<PRE>size_type <B>length</B>() const;</PRE>

<P>The member function returns the length of the controlled sequence
(same as <CODE><A HREF="#basic_string::size">size</A>()</CODE>).</P>

<H3><CODE><A NAME="basic_string::max_size">basic_string::max_size</A></CODE></H3>

<PRE>size_type <B>max_size</B>() const;</PRE>

<P>The member function returns the length of the longest sequence that
the object can control.</P>

<H3><CODE><A NAME="basic_string::npos">basic_string::npos</A></CODE></H3>

<PRE>static const size_type <B>npos</B> = -1;</PRE>

<P>The constant is the largest representable value of type
<A HREF="#basic_string::size_type"><CODE>size_type</CODE></A>. It is
assuredly larger than
<CODE><A HREF="#basic_string::max_size">max_size</A>()</CODE>, hence
it serves as either a very large value or as a special code.</P>

<H3><CODE><A NAME="basic_string::operator+=">basic_string::operator+=</A></CODE></H3>

<PRE>basic_string&amp; <B>operator+=</B>(value_type ch);
basic_string&amp; <B>operator+=</B>(const value_type *ptr);
basic_string&amp; <B>operator+=</B>(const basic_string&amp; right);</PRE>

<P>The operators each append the
<A HREF="#operand sequence">operand sequence</A> to the end of the
sequence controlled by <CODE>*this</CODE>, then return <CODE>*this</CODE>.</P>

<H3><CODE><A NAME="basic_string::operator=">basic_string::operator=</A></CODE></H3>

<PRE>basic_string&amp; <B>operator=</B>(value_type ch);
basic_string&amp; <B>operator=</B>(const value_type *ptr);
basic_string&amp; <B>operator=</B>(const basic_string&amp; right);</PRE>

<P>The operators each replace the sequence controlled by <CODE>*this</CODE>
with the
<A HREF="#operand sequence">operand sequence</A>,
then return <CODE>*this</CODE>.</P>

<H3><CODE><A NAME="basic_string::operator[]">basic_string::operator[]</A></CODE></H3>

<PRE>const_reference <B>operator[]</B>(size_type off) const;
reference <B>operator[]</B>(size_type off);</PRE>

<P>The member functions each return a reference to the element of the
controlled sequence at position <CODE>off</CODE>. If that position is
invalid, the behavior is undefined. Note, however, that
<CODE>cstr[cstr.size()] == 0</CODE> for the first member function.</P>

<H3><CODE><A NAME="basic_string::pointer">basic_string::pointer</A></CODE></H3>

<PRE>typedef typename allocator_type::pointer
    <B>pointer</B>;</PRE>

<P>The type is a synonym for <CODE>allocator_type::pointer</CODE>.</P>

<H3><CODE><A NAME="basic_string::push_back">basic_string::push_back</A></CODE></H3>

<PRE>void <B>push_back</B>(value_type ch);</PRE>

<P>The member function effectively calls
<CODE><A HREF="#basic_string::insert">insert</A>(
<A HREF="#basic_string::end">end</A>(), ch)</CODE>.</P>

<H3><CODE><A NAME="basic_string::rbegin">basic_string::rbegin</A></CODE></H3>

<PRE>const_reverse_iterator <B>rbegin</B>() const;
reverse_iterator <B>rbegin</B>();</PRE>

<P>The member function returns a reverse iterator that points just
beyond the end of the controlled sequence. Hence, it designates the
beginning of the reverse sequence.</P>

<H3><CODE><A NAME="basic_string::reference">basic_string::reference</A></CODE></H3>

<PRE>typedef typename allocator_type::reference
    <B>reference</B>;</PRE>

<P>The type is a synonym for <CODE>allocator_type::reference</CODE>.</P>

<H3><CODE><A NAME="basic_string::rend">basic_string::rend</A></CODE></H3>

<PRE>const_reverse_iterator <B>rend</B>() const;
reverse_iterator <B>rend</B>();</PRE>

<P>The member functions each return a reverse iterator that points at the
first element of the sequence (or just beyond the end of an empty
sequence). Hence, the function designates the end of the reverse sequence.</P>

<H3><CODE><A NAME="basic_string::replace">basic_string::replace</A></CODE></H3>

<PRE>basic_string&amp; <B>replace</B>(size_type off, size_type n0,
    const value_type *ptr);
basic_string&amp; <B>replace</B>(size_type off, size_type n0,
    const value_type *ptr, size_type count);
basic_string&amp; <B>replace</B>(size_type off, size_type n0,
    const basic_string&amp; right);
basic_string&amp; <B>replace</B>(size_type off, size_type n0,
    const basic_string&amp; right, size_type roff, size_type count);
basic_string&amp; <B>replace</B>(size_type off, size_type n0,
    size_type count, value_type ch);
basic_string&amp; <B>replace</B>(iterator first, iterator last,
    const value_type *ptr);
basic_string&amp; <B>replace</B>(iterator first, iterator last,
    const value_type *ptr, size_type count);
basic_string&amp; <B>replace</B>(iterator first, iterator last,
    const basic_string&amp; right);
basic_string&amp; <B>replace</B>(iterator first, iterator last,
    size_type count, value_type ch);
template&lt;class InIt&gt;
    basic_string&amp;
        <B>replace</B>(iterator first, iterator last,
            InIt first2, InIt last2);</PRE>

<P>The member functions each replace up to <CODE>n0</CODE> elements of the
controlled sequence beginning with position <CODE>off</CODE>, or the
elements of the controlled sequence beginning with the one pointed to by
<CODE>first</CODE>, up to but not including <CODE>last</CODE>. The
replacement is the
<A HREF="#operand sequence">operand sequence</A> specified by the
remaining operands. The function then returns
<CODE>*this</CODE>.
If <CODE>InIt</CODE> is an integer type in the template member function,
the operand sequence <CODE>first2, last2</CODE> behaves the same as
<CODE>(size_type)first2, (value_type)last2</CODE>.</P>

<P>In this
<A HREF="index.html#implementation">implementation</A>, if a
translator does not support member template functions, the template:</P>

<PRE>template&lt;class InIt&gt;
    basic_string&amp; <B>replace</B>(iterator first, iterator last,
        InIt first2, InIt last2);</PRE>

<P>is replaced by:</P>

<PRE>basic_string&amp; <B>replace</B>(iterator first, iterator last,
    const_pointer first2, const_pointer last2);</PRE>

<H3><CODE><A NAME="basic_string::reserve">basic_string::reserve</A></CODE></H3>

<PRE>void <B>reserve</B>(size_type count = 0);</PRE>

<P>The member function ensures that
<CODE><A HREF="#basic_string::capacity">capacity</A>()</CODE>
henceforth returns at least <CODE>count</CODE>.</P>

<H3><CODE><A NAME="basic_string::resize">basic_string::resize</A></CODE></H3>

<PRE>void <B>resize</B>(size_type newsize, value_type ch = value_type());</PRE>

<P>The member function ensures that
<CODE><A HREF="#basic_string::size">size</A>()</CODE> henceforth
returns <CODE>newsize</CODE>. If it must make the controlled sequence longer,
it appends elements with value <CODE>ch</CODE>.
To make the controlled sequence shorter, the member function effectively calls
<CODE><A HREF="#basic_string::erase">erase</A>(begin() + newsize, end())</CODE>.</P>

<H3><CODE><A NAME="basic_string::reverse_iterator">basic_string::reverse_iterator</A></CODE></H3>

<PRE>typedef reverse_iterator&lt;iterator&gt;
    <B>reverse_iterator</B>;</PRE>

<P>The type describes an object that can serve as a reverse
iterator for the controlled sequence.</P>

<H3><CODE><A NAME="basic_string::rfind">basic_string::rfind</A></CODE></H3>

<PRE>size_type <B>rfind</B>(value_type ch, size_type off = npos) const;
size_type <B>rfind</B>(const value_type *ptr,
    size_type off = npos) const;
size_type <B>rfind</B>(const value_type *ptr,
    size_type off, size_type count = npos) const;
size_type <B>rfind</B>(const basic_string&amp; right,
    size_type off = npos) const;</PRE>

<P>The member functions each find the last
(highest beginning position) subsequence in
the controlled sequence, beginning on or before position <CODE>off</CODE>,
that matches the
<A HREF="#operand sequence">operand sequence</A> specified by the
remaining operands. If it succeeds, the function returns the position where the
matching subsequence begins. Otherwise, it returns
<CODE><A HREF="#basic_string::npos">npos</A></CODE>.</P>

<H3><CODE><A NAME="basic_string::size">basic_string::size</A></CODE></H3>

<PRE>size_type <B>size</B>() const;</PRE>

<P>The member function returns the length of the controlled sequence.</P>

<H3><CODE><A NAME="basic_string::size_type">basic_string::size_type</A></CODE></H3>

<PRE>typedef T2 <B>size_type</B>;</PRE>

<P>The unsigned integer type describes an object that can represent the
length of any controlled sequence. It is described here as a
synonym for the implementation-defined type <CODE>T2</CODE>.</P>

<H3><CODE><A NAME="basic_string::substr">basic_string::substr</A></CODE></H3>

<PRE>basic_string <B>substr</B>(size_type off = 0,
    size_type count = npos) const;</PRE>

<P>The member function returns an object whose controlled sequence is a
copy of up to <CODE>count</CODE> elements of the controlled sequence
beginning at position <CODE>off</CODE>.</P>

<H3><CODE><A NAME="basic_string::swap">basic_string::swap</A></CODE></H3>

<PRE>void <B>swap</B>(basic_string&amp; right);</PRE>

<P>The member function swaps the controlled sequences between
<CODE>*this</CODE> and <CODE>str</CODE>. If
<CODE><A HREF="#basic_string::get_allocator">get_allocator</A>()
== right.get_allocator()</CODE>, it does so in constant time,
it throws no exceptions, and it invalidates no references, pointers,
or iterators that designate elements in the two controlled sequences.
Otherwise, it performs a number of element assignments and constructor calls
proportional to the number of elements in the two controlled sequences.</P>

<H3><CODE><A NAME="basic_string::traits_type">basic_string::traits_type</A></CODE></H3>

<PRE>typedef Tr <B>traits_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Tr</CODE>.</P>

<H3><CODE><A NAME="basic_string::value_type">basic_string::value_type</A></CODE></H3>

<PRE>typedef typename allocator_type::value_type
    <B>value_type</B>;</PRE>

<P>The type is a synonym for <CODE>allocator_type::value_type</CODE>.</P>


<H2><A NAME="char_traits"><CODE>char_traits</CODE></A></H2>

<PRE>template&lt;class Elem&gt;
    class <B>char_traits</B> {
public:
    typedef Elem <B><A HREF="#char_traits::char_type">char_type</A></B>;
    typedef T1 <B><A HREF="#char_traits::int_type">int_type</A></B>;
    typedef T2 <B><A HREF="#char_traits::pos_type">pos_type</A></B>;
    typedef T3 <B><A HREF="#char_traits::off_type">off_type</A></B>;
    typedef T4 <B><A HREF="#char_traits::state_type">state_type</A></B>;
    static void <B><A HREF="#char_traits::assign">assign</A></B>(char_type&amp; left, const char_type&amp; right);
    static char_type *<B><A HREF="#char_traits::assign">assign</A></B>(char_type *first, size_t count,
        char_type ch);
    static bool <B><A HREF="#char_traits::eq">eq</A></B>(const char_type&amp; left,
        const char_type&amp; right);
    static bool <B><A HREF="#char_traits::lt">lt</A></B>(const char_type&amp; left,
        const char_type&amp; right);
    static int <B><A HREF="#char_traits::compare">compare</A></B>(const char_type *first1,
        const char_type *first2, size_t count);
    static size_t <B><A HREF="#char_traits::length">length</A></B>(const char_type *first);
    static char_type *<B><A HREF="#char_traits::copy">copy</A></B>(char_type *first1,
        const char_type *first2, size_t count);
    static char_type *<B><A HREF="#char_traits::move">move</A></B>(char_type *first1,
        const char_type *first2, size_t count);
    static const char_type *<B><A HREF="#char_traits::find">find</A></B>(const char_type *first,
        size_t count, const char_type&amp; ch);
    static char_type <B><A HREF="#char_traits::to_char_type">to_char_type</A></B>(const int_type&amp; meta);
    static int_type <B><A HREF="#char_traits::to_int_type">to_int_type</A></B>(const char_type&amp; ch);
    static bool <B><A HREF="#char_traits::eq_int_type">eq_int_type</A></B>(const int_type&amp; left,
        const int_type&amp; right);
    static int_type <B><A HREF="#char_traits::eof">eof</A></B>();
    static int_type <B><A HREF="#char_traits::not_eof">not_eof</A></B>(const int_type&amp; meta);
    };</PRE>

<P>The template class describes various
<B><A NAME="character traits">character traits</A></B>
for type <CODE>Elem</CODE>.
The template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A>
as well as several iostreams template classes, including
<A HREF="ios.html#basic_ios"><CODE>basic_ios</CODE></A>, use this information
to manipulate elements of type <CODE>Elem</CODE>.
Such an element type must not require explicit construction or
destruction. It must supply a default constructor, a copy constructor,
and an assignment operator, with the expected semantics.
A bitwise copy must have the same effect as an assignment.</P>

<P>Not all parts of the Standard C++ Library rely completely upon the member
functions of <CODE>char_traits&lt;Elem&gt;</CODE> to manipulate an element.
Specifically,
<A HREF="istream.html#formatted input functions">formatted input functions</A> and
<A HREF="ostream.html#formatted output functions">formatted output functions</A>
make use of the following additional operations,
also with the expected semantics:</P>

<UL>
<LI><CODE>operator==(Elem)</CODE> and <CODE>operator!=(Elem)</CODE>
to compare elements</LI>

<LI><CODE>(char)ch</CODE> to convert an element <CODE>ch</CODE>
to its corresponding single-byte character code,
or <CODE>'\0'</CODE> if no such code exists</LI>

<LI><CODE>(Elem)ch</CODE> to convert a <CODE>char</CODE> value <CODE>ch</CODE> to
its correponding character code of type <CODE>Elem</CODE></LI>
</UL>

<P>None of the member functions of class <CODE>char_traits</CODE> may
throw exceptions.</P>

<H3><CODE><A NAME="char_traits::assign">char_traits::assign</A></CODE></H3>

<PRE>static void <B>assign</B>(char_type&amp; left, const char_type&amp; right);
static char_type *<B>assign</B>(char_type *first, size_t count,
    char_type ch);</PRE>

<P>The first static member function assigns <CODE>right</CODE>
to <CODE>left</CODE>. The second static member function assigns <CODE>ch</CODE>
to each element <CODE>X[N]</CODE> for <CODE>N</CODE>
in the range <CODE>[0, count)</CODE>.</P>

<H3><CODE><A NAME="char_traits::char_type">char_traits::char_type</A></CODE></H3>

<PRE>typedef Elem <B>char_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Elem</CODE>.</P>

<H3><CODE><A NAME="char_traits::compare">char_traits::compare</A></CODE></H3>

<PRE>static int <B>compare</B>(const char_type *first1,
    const char_type *first2, size_t count);</PRE>

<P>The static member function compares the sequence of length <CODE>count</CODE>
beginning at <CODE>first1</CODE>to the sequence of the same length beginning
at <CODE>first2</CODE>. The function returns:</P>

<UL>
<LI>a negative value if the first differing element in <CODE>first1</CODE>
(as determined by
<CODE><A HREF="#char_traits::eq">eq</A></CODE>) compares less
than the corresponding element in <CODE>first2</CODE> (as determined by
<CODE><A HREF="#char_traits::lt">lt</A></CODE>)</LI>

<LI>zero if the two compare equal element by element</LI>

<LI>a positive value otherwise</LI>
</UL>

<H3><CODE><A NAME="char_traits::copy">char_traits::copy</A></CODE></H3>

<PRE>static char_type <B>*copy</B>(char_type *first1, const char_type *first2,
    size_t count);</PRE>

<P>The static member function copies the sequence of <CODE>count</CODE>
elements beginning at <CODE>first2</CODE> to the array beginning at <CODE>first1</CODE>,
then returns <CODE>first1</CODE>. The source and destination
must not overlap.</P>

<H3><A NAME="char_traits::eof"><CODE>char_traits::eof</CODE></A></H3>

<PRE>static int_type <B>eof</B>();</PRE>

<P>The static member function returns a value that represents
end-of-file (such as <CODE><A HREF="stdio.html#EOF">EOF</A></CODE> or
<CODE><A HREF="wchar.html#WEOF">WEOF</A></CODE>). If the value is also
representable as type <CODE>Elem</CODE>,
it must correspond to no <I>valid</I> value of that type.</P>

<H3><CODE><A NAME="char_traits::eq">char_traits::eq</A></CODE></H3>

<PRE>static bool <B>eq</B>(const char_type&amp; left, const char_type&amp; right);</PRE>

<P>The static member function returns true if <CODE>left</CODE> compares
equal to <CODE>right</CODE>.</P>

<H3><A NAME="char_traits::eq_int_type"><CODE>char_traits::eq_int_type</CODE></A></H3>

<PRE>static bool <B>eq_int_type</B>(const int_type&amp; left,
    const int_type&amp; right);</PRE>

<P>The static member function returns true if
<CODE>left</CODE> compares equal to <CODE>right</CODE>.</P>

<H3><CODE><A NAME="char_traits::find">char_traits::find</A></CODE></H3>

<PRE>static const char_type *<B>find</B>(const char_type *first,
    size_t count, const char_type&amp; ch);</PRE>

<P>The static member function determines the lowest <CODE>N</CODE>
in the range <CODE>[0, count)</CODE> for which
<CODE><A HREF="#char_traits::eq">eq</A>(first[N], ch)</CODE>
is true. If successful, it returns <CODE>first + N</CODE>. Otherwise,
it returns a null pointer.</P>

<H3><A NAME="char_traits::int_type"><CODE>char_traits::int_type</CODE></A></H3>

<PRE>typedef T1 <B>int_type</B>;</PRE>

<P>The type is (typically) an integer type <CODE>T1</CODE> that
describes an object that can represent any element of the controlled
sequence as well as the value returned by <CODE><A HREF="#char_traits::eof">
eof</A>()</CODE>.</P>

<H3><CODE><A NAME="char_traits::length">char_traits::length</A></CODE></H3>

<PRE>static size_t <B>length</B>(const char_type *first);</PRE>

<P>The static member function returns the number of elements
<CODE>N</CODE> in the sequence beginning at <CODE>first</CODE>
up to but not including the element <CODE>first[N]</CODE> which
compares equal to <CODE>char_type()</CODE>.</P>

<H3><CODE><A NAME="char_traits::lt">char_traits::lt</A></CODE></H3>

<PRE>static bool <B>lt</B>(const char_type&amp; left, const char_type&amp; right);</PRE>

<P>The static member function returns true if <CODE>left</CODE> compares
less than <CODE>right</CODE>.</P>

<H3><CODE><A NAME="char_traits::move">char_traits::move</A></CODE></H3>

<PRE>static char_type <B>*move</B>(char_type *first1, const char_type *first2,
    size_t count);</PRE>

<P>The static member function copies the sequence of <CODE>count</CODE>
elements beginning at <CODE>first2</CODE> to the array beginning at <CODE>first1</CODE>,
then returns <CODE>first1</CODE>. The source and destination may overlap.</P>

<H3><A NAME="char_traits::not_eof"><CODE>char_traits::not_eof</CODE></A></H3>

<PRE>static int_type <B>not_eof</B>(const int_type&amp; meta);</PRE>

<P>If
<CODE>!<A HREF="#char_traits::eq_int_type">eq_int_type</A>(
<A HREF="#char_traits::eof">eof</A>(), meta)</CODE>,
the static member function returns <CODE>meta</CODE>.
Otherwise, it returns a value other than
<CODE>eof()</CODE>.</P>

<H3><A NAME="char_traits::off_type"><CODE>char_traits::off_type</CODE></A></H3>

<PRE>typedef T3 <B>off_type</B>;</PRE>

<P>The type is a signed integer type <CODE>T3</CODE> that describes an
object that can store a byte offset involved in various stream
positioning operations. It is typically a synonym for
<CODE><A HREF="ios.html#streamoff">streamoff</A></CODE>, but in any case it
has essentially the same properties as that type.</P>

<H3><A NAME="char_traits::pos_type"><CODE>char_traits::pos_type</CODE></A></H3>

<PRE>typedef T2 <B>pos_type</B>;</PRE>

<P>The type is an opaque type <CODE>T2</CODE> that describes an object
that can store all the information needed to restore an arbitrary
<A HREF="lib_file.html#file-position indicator">file-position indicator</A>
within a stream. It is typically a synonym for
<CODE><A HREF="ios.html#streampos">streampos</A></CODE>, but in any case it
has essentially the same properties as that type.</P>

<H3><A NAME="char_traits::state_type"><CODE>char_traits::state_type</CODE></A></H3>

<PRE>typedef T4 <B>state_type</B>;</PRE>

<P>The type is an opaque type <CODE>T4</CODE> that describes an object
that can represent a
<A HREF="charset.html#conversion state">conversion state</A>. It is
typically a synonym for
<CODE><A HREF="wchar.html#mbstate_t">mbstate_t</A></CODE>, but in any
case it has essentially the same properties as that type.</P>

<H3><A NAME="char_traits::to_char_type"><CODE>char_traits::to_char_type</CODE></A></H3>

<PRE>static char_type <B>to_char_type</B>(const int_type&amp; meta);</PRE>

<P>The static member function returns <CODE>meta</CODE> represented as
type <CODE>Elem</CODE>. A value of <CODE>meta</CODE> that cannot be so
represented yields an unspecified result.</P>

<H3><A NAME="char_traits::to_int_type"><CODE>char_traits::to_int_type</CODE></A></H3>

<PRE>static int_type <B>to_int_type</B>(const char_type&amp; ch);</PRE>

<P>The static member function returns <CODE>ch</CODE> represented as
type <CODE>int_type</CODE>. It must be possible to convert any value <CODE>ch</CODE> of type
<CODE>Elem</CODE> to <CODE>int_type</CODE> (by evaluating
<CODE>meta = <A HREF="#char_traits::to_int_type">to_int_type</A>(ch)</CODE>)
then back to <CODE>Elem</CODE> (by evaluating
<CODE>ch = <A HREF="#char_traits::to_char_type">to_char_type</A>(meta)</CODE>)
and obtain a value that compares equal to <CODE>ch</CODE>.

<H2><A NAME="char_traits&lt;char&gt;"><CODE>char_traits&lt;char&gt;</CODE></A></H2>

<PRE>template&lt;&gt;
    class <B>char_traits&lt;char&gt;</B>;</PRE>

<P>The class is an explicit specialization of template class
<A HREF="#char_traits"><CODE>char_traits</CODE></A>
for elements of type <I>char,</I> (so that it
can take advantage of library functions that manipulate objects of this
type).</P>

<H2><A NAME="char_traits&lt;wchar_t&gt;"><CODE>char_traits&lt;wchar_t&gt;</CODE></A></H2>

<PRE>template&lt;&gt;
    class <B>char_traits&lt;wchar_t&gt;</B>;</PRE>

<P>The class is an explicit specialization of template class
<A HREF="#char_traits"><CODE>char_traits</CODE></A>
for elements of type <CODE>wchar_t</CODE> (so
that it can take advantage of library functions that manipulate objects
of this type).</P>

<H2><A NAME="getline"><CODE>getline</CODE></A></H2>

<PRE>template&lt;class Elem, class Tr, class Alloc&gt;
    basic_istream&lt;Elem, Tr&gt;&amp; <B>getline</B>(
        basic_istream&lt;Elem, Tr&gt;&amp; istr,
        basic_string&lt;Elem, Tr, Alloc&gt;&amp; str);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_istream&lt;Elem, Tr&gt;&amp; <B>getline</B>(
        basic_istream&lt;Elem, Tr&gt;&amp; istr,
        basic_string&lt;Elem, Tr, Alloc&gt;&amp; str,
        Elem delim);</PRE>

<P>The first function returns <CODE>getline(istr, str, istr.widen('\n'))</CODE>.

<P>The second function replaces the sequence controlled by
<CODE>str</CODE> with a sequence of elements extracted from the stream
<CODE>istr</CODE>. In order of testing, extraction stops:</P>

<OL>
<LI>at end of file</LI>

<LI>after the function extracts an element that compares equal to
<CODE>delim</CODE>, in which case the element is neither put back nor
appended to the controlled sequence</LI>

<LI>after the function extracts
<CODE>str.<A HREF="#basic_string::max_size">max_size</A>()</CODE>
elements, in which case the function calls
<CODE><A HREF="ios.html#basic_ios::setstate">setstate</A>(ios_base::failbit)</CODE>.</LI>
</OL>

<P>If the function extracts no elements, it calls
<CODE>setstate(failbit)</CODE>.
In any case, it returns <CODE>istr</CODE>.</P>

<H2><A NAME="operator+"><CODE>operator+</CODE></A></H2>

<PRE>template&lt;class Elem, class Tr, class Alloc&gt;
    basic_string&lt;Elem, Tr, Alloc&gt; <B>operator+</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_string&lt;Elem, Tr, Alloc&gt; <B>operator+</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_string&lt;Elem, Tr, Alloc&gt; <B>operator+</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        Elem right);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_string&lt;Elem, Tr, Alloc&gt; <B>operator+</B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    basic_string&lt;Elem, Tr, Alloc&gt; <B>operator+</B>(
        Elem left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);</PRE>

<P>The functions each overload <CODE>operator+</CODE> to
concatenate two objects of template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A>.
All effectively return <CODE>basic_string&lt;Elem, Tr,
Alloc&gt;(left).<A HREF="#basic_string::append">append</A>(right)</CODE>.</P>

<H2><A NAME="operator!="><CODE>operator!=</CODE></A></H2>

<PRE>template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator!=</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator!=</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator!=</B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);</PRE>

<P>The template functions each overload <CODE>operator!=</CODE> to compare
two objects of template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A>. All effectively
return <CODE>basic_string&lt;Elem, Tr,
Alloc&gt;(left).<A HREF="#basic_string::compare">compare</A>(right) != 0</CODE>.</P>

<H2><A NAME="operator=="><CODE>operator==</CODE></A></H2>

<PRE>template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator==</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator==</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator==</B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);</PRE>

<P>The template functions each overload <CODE>operator==</CODE> to compare
two objects of template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A>. All effectively
return <CODE>basic_string&lt;Elem, Tr,
Alloc&gt;(left).<A HREF="#basic_string::compare">compare</A>(right) == 0</CODE>.</P>

<H2><A NAME="operator&lt;"><CODE>operator&lt;</CODE></A></H2>

<PRE>template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&lt;</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&lt;</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&lt;</B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);</PRE>

<P>The template functions each overload <CODE>operator&lt;</CODE> to
compare two objects of template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A>. All effectively
return <CODE>basic_string&lt;Elem, Tr,
Alloc&gt;(left).<A HREF="#basic_string::compare">compare</A>(right)
&lt; 0</CODE>.</P>

<H2><A NAME="operator&lt;&lt;"><CODE>operator&lt;&lt;</CODE></A></H2>

<PRE>template&lt;class Elem, class Tr, class Alloc&gt;
    basic_ostream&lt;Elem, Tr&gt;&amp; <B>operator&lt;&lt;</B>(
        basic_ostream&lt;Elem, Tr&gt;&amp; ostr,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; str);</PRE>

<P>The template function overloads <CODE>operator&lt;&lt;</CODE> to
insert an object <CODE>str</CODE> of template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A> into the stream
<CODE>ostr</CODE> The function effectively returns
<CODE>ostr.<A HREF="ostream.html#basic_ostream::write">write</A>(
str.<A HREF="#basic_string::c_str">c_str</A>(),
str.<A HREF="#basic_string::size">size</A>())</CODE>.</P>

<H2><A NAME="operator&lt;="><CODE>operator&lt;=</CODE></A></H2>

<PRE>template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&lt;=</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&lt;=</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&lt;=</B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);</PRE>

<P>The template functions each overload <CODE>operator&lt;=</CODE> to
compare two objects of template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A>. All effectively
return <CODE>basic_string&lt;Elem, Tr,
Alloc&gt;(left).<A HREF="#basic_string::compare">compare</A>(right)
&lt;= 0</CODE>.</P>

<H2><A NAME="operator&gt;"><CODE>operator&gt;</CODE></A></H2>

<PRE>template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&gt;</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&gt;</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&gt;</B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);</PRE>

<P>The template functions each overload <CODE>operator&gt;</CODE> to
compare two objects of template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A>. All effectively
return <CODE>basic_string&lt;Elem, Tr,
Alloc&gt;(left).<A HREF="#basic_string::compare">compare</A>(right)
&gt; 0</CODE>.</P>

<H2><A NAME="operator&gt;="><CODE>operator&gt;=</CODE></A></H2>

<PRE>template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&gt;=</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&gt;=</B>(
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        const Elem *right);
template&lt;class Elem, class Tr, class Alloc&gt;
    bool <B>operator&gt;=</B>(
        const Elem *left,
        const basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);</PRE>

<P>The template functions each overload <CODE>operator&gt;=</CODE> to
compare two objects of template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A>. All effectively
return <CODE>basic_string&lt;Elem, Tr,
Alloc&gt;(left).<A HREF="#basic_string::compare">compare</A>(right)
&gt;= 0</CODE>.</P>

<H2><A NAME="operator&gt;&gt;"><CODE>operator&gt;&gt;</CODE></A></H2>

<PRE>template&lt;class Elem, class Tr, class Alloc&gt;
    basic_istream&lt;Elem, Tr&gt;&amp; <B>operator&gt;&gt;</B>(
        basic_istream&lt;Elem, Tr&gt;&amp; istr,
        basic_string&lt;Elem, Tr, Alloc&gt;&amp; str);</PRE>

<P>The template function overloads <CODE>operator&gt;&gt;</CODE> to
replace the sequence controlled by <CODE>str</CODE> with a sequence of
elements extracted from the stream <CODE>istr</CODE>. Extraction stops:</P>

<UL>
<LI>at end of file</LI>

<LI>after the function extracts
<CODE>istr.<A HREF="ios.html#ios_base::width">width</A>()</CODE>
elements, if that value is nonzero</LI>

<LI>after the function extracts
<CODE>istr.<A HREF="#basic_string::max_size">max_size</A>()</CODE>
elements</LI>

<LI>after the function extracts an element <CODE>ch</CODE> for which
<CODE><A HREF="locale2.html#use_facet">use_facet</A>&lt;
<A HREF="locale2.html#ctype">ctype</A>&lt;Elem&gt; &gt;(
<A HREF="ios.html#ios_base::getloc">getloc</A>()).
<A HREF="locale2.html#ctype::is">is</A>(
ctype&lt;Elem&gt;::<A HREF="locale2.html#ctype_base::space">space</A>, ch)</CODE>
is true, in which case the character is put back</LI>
</UL>

<P>If the function extracts no elements, it calls
<CODE><A HREF="ios.html#basic_ios::setstate">setstate</A>(ios_base::failbit)</CODE>.
In any case, it calls <CODE>istr.width(0)</CODE> and
returns <CODE>*this</CODE>.</P>

<H2><A NAME="string"><CODE>string</CODE></A></H2>

<PRE>typedef basic_string&lt;char&gt; <B>string</B>;</PRE>

<P>The type describes a specialization of template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A> specialized for
elements of type <I>char.</I></P>

<H2><A NAME="swap"><CODE>swap</CODE></A></H2>

<PRE>template&lt;class Tr, class Alloc&gt;
    void <B>swap</B>(
        basic_string&lt;Elem, Tr, Alloc&gt;&amp; left,
        basic_string&lt;Elem, Tr, Alloc&gt;&amp; right);</PRE>

<P>The template function executes
<CODE>left.<A HREF="#basic_string::swap">swap</A>(right)</CODE>.</P>

<H2><A NAME="wstring"><CODE>wstring</CODE></A></H2>

<PRE>typedef basic_string&lt;wchar_t&gt; <B>wstring</B>;</PRE>

<P>The type describes a specialization of template class
<A HREF="#basic_string"><CODE>basic_string</CODE></A> for
elements of type <CODE>wchar_t</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2002
by P.J. Plauger. All rights reserved.</I></P>

<!--V4.02:1476--></BODY></HTML>
