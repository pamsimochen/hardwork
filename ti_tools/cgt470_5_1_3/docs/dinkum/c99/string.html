<HTML><HEAD><TITLE>&lt;string.h&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;string.h&gt;"><CODE>&lt;string.h&gt;</CODE></A></H1><HR>

<P><B><CODE><A HREF="#memchr">memchr</A>
&#183; <A HREF="#memcmp">memcmp</A>
&#183; <A HREF="#memcpy">memcpy</A>
&#183; <A HREF="#memmove">memmove</A>
&#183; <A HREF="#memset">memset</A>
&#183; <A HREF="#NULL">NULL</A>
&#183; <A HREF="#size_t">size_t</A>
&#183; <A HREF="#strcat">strcat</A>
&#183; <A HREF="#strchr">strchr</A>
&#183; <A HREF="#strcmp">strcmp</A>
&#183; <A HREF="#strcoll">strcoll</A>
&#183; <A HREF="#strcpy">strcpy</A>
&#183; <A HREF="#strcspn">strcspn</A>
&#183; <A HREF="#strerror">strerror</A>
&#183; <A HREF="#strlen">strlen</A>
&#183; <A HREF="#strncat">strncat</A>
&#183; <A HREF="#strncmp">strncmp</A>
&#183; <A HREF="#strncpy">strncpy</A>
&#183; <A HREF="#strpbrk">strpbrk</A>
&#183; <A HREF="#strrchr">strrchr</A>
&#183; <A HREF="#strspn">strspn</A>
&#183; <A HREF="#strstr">strstr</A>
&#183; <A HREF="#strtok">strtok</A>
&#183; <A HREF="#strxfrm">strxfrm</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;string.h&gt;</CODE></B> to declare a
number of functions that help you manipulate
<A HREF="lib_over.html#C string">C strings</A> and other arrays of
characters.</P>

<PRE>    /* MACROS */
#define <A HREF="#NULL"><B>NULL</B></A> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B>

    /* TYPES */
typedef <I>ui-type</I> <A HREF="#size_t"><B>size_t</B></A>;

    /* FUNCTIONS */
int <A HREF="#memcmp"><B>memcmp</B></A>(const void *s1, const void *s2, size_t n);
void *<A HREF="#memcpy"><B>memcpy</B></A>(void *restrict s1, const void *restrict s2, size_t n);
void *<A HREF="#memmove"><B>memmove</B></A>(void *s1, const void *s2, size_t n);
void *<A HREF="#memset"><B>memset</B></A>(void *s, int c, size_t n);
char *<A HREF="#strcat"><B>strcat</B></A>(char *restrict s1, const char *restrict s2);
int <A HREF="#strcmp"><B>strcmp</B></A>(const char *s1, const char *s2);
int <A HREF="#strcoll"><B>strcoll</B></A>(const char *s1, const char *s2);
char *<A HREF="#strcpy"><B>strcpy</B></A>(char *restrict s1, const char *restrict s2);
size_t <A HREF="#strcspn"><B>strcspn</B></A>(const char *s1, const char *s2);
char *<A HREF="#strerror"><B>strerror</B></A>(int errcode);
size_t <A HREF="#strlen"><B>strlen</B></A>(const char *s);
char *<A HREF="#strncat"><B>strncat</B></A>(char *restrict s1, const char *restrict s2, size_t n);
int <A HREF="#strncmp"><B>strncmp</B></A>(const char *s1, const char *s2, size_t n);
char *<A HREF="#strncpy"><B>strncpy</B></A>(char *restrict s1, const char *restrict s2, size_t n);
size_t <A HREF="#strspn"><B>strspn</B></A>(const char *s1, const char *s2);
char *<A HREF="#strtok"><B>strtok</B></A>(char *restrict s1, const char *restrict s2);
size_t <A HREF="#strxfrm"><B>strxfrm</B></A>(char *restrict s1, const char *restrict s2, size_t n);

void *<A HREF="#memchr"><B>memchr</B></A>(const void *s, int c,
    size_t n); <B>[not in C++]</B>
const void *<A HREF="#memchr"><B>memchr</B></A>(const void *s, int c,
    size_t n); <B>[C++ only]</B>
void *<A HREF="#memchr"><B>memchr</B></A>(void *s, int c, size_t n); <B>[C++ only]</B>

char *<A HREF="#strchr"><B>strchr</B></A>(const char *s, int c); <B>[not in C++]</B>
const char *<A HREF="#strchr"><B>strchr</B></A>(const char *s, int c); <B>[C++ only]</B>
char *<A HREF="#strchr"><B>strchr</B></A>(char *s, int c); <B>[C++ only]</B>

char *<A HREF="#strpbrk"><B>strpbrk</B></A>(const char *s1,
    const char *s2); <B>[not in C++]</B>
const char *<A HREF="#strpbrk"><B>strpbrk</B></A>(const char *s1,
    const char *s2); <B>[C++ only]</B>
char *<A HREF="#strpbrk"><B>strpbrk</B></A>(char *s1, const char *s2); <B>[C++ only]</B>

char *<A HREF="#strrchr"><B>strrchr</B></A>(const char *s, int c); <B>[not in C++]</B>
const char *<A HREF="#strrchr"><B>strrchr</B></A>(const char *s, int c); <B>[C++ only]</B>
char *<A HREF="#strrchr"><B>strrchr</B></A>(char *s, int c); <B>[C++ only]</B>

char *<A HREF="#strstr"><B>strstr</B></A>(const char *s1,
    const char *s2); <B>[not in C++]</B>
const char *<A HREF="#strstr"><B>strstr</B></A>(const char *s1,
    const char *s2); <B>[C++ only]</B>
char *<A HREF="#strstr"><B>strstr</B></A>(char *s1, const char *s2); <B>[C++ only]</B></PRE>

<H2><A NAME="memchr"><CODE>memchr</CODE></A></H2>

<PRE>void *<B>memchr</B>(const void *s, int c,
    size_t n); <B>[not in C++]</B>
const void *<B>memchr</B>(const void *s, int c,
    size_t n); <B>[C++ only]</B>
void *<B>memchr</B>(void *s, int c, size_t n); <B>[C++ only]</B></PRE>

<P>The function searches for the first element of an array of <I>unsigned
char,</I> beginning at the address <CODE>s</CODE> with size <CODE>n</CODE>,
that equals <CODE>(unsigned char)c</CODE>. If successful, it returns the
address of the matching element; otherwise, it returns a null pointer.</P>

<H2><A NAME="memcmp"><CODE>memcmp</CODE></A></H2>

<PRE>int <B>memcmp</B>(const void *s1, const void *s2, size_t n);</PRE>

<P>The function compares successive elements from two arrays of <I>unsigned
char,</I> beginning at the addresses <CODE>s1</CODE> and <CODE>s2</CODE>
(both of size <CODE>n</CODE>),
until it finds elements that are not equal:</P>

<UL>
<LI>If all elements are equal, the function returns zero.

<LI>If the differing element from <CODE>s1</CODE> is greater than the
element from <CODE>s2</CODE>, the function returns a positive number.

<LI>Otherwise, the function returns a negative number.
</UL>

<H2><A NAME="memcpy"><CODE>memcpy</CODE></A></H2>

<PRE>void *<B>memcpy</B>(void *restrict s1, const void *restrict s2, size_t n);</PRE>

<P>The function copies the array of <I>char</I> beginning at the address
<CODE>s2</CODE> to the array of <I>char</I> beginning at the address
<CODE>s1</CODE> (both of size <CODE>n</CODE>). It returns
<CODE>s1</CODE>. The elements of the arrays can be accessed and stored in any
order.</P>

<H2><A NAME="memmove"><CODE>memmove</CODE></A></H2>

<PRE>void *<B>memmove</B>(void *s1, const void *s2, size_t n);</PRE>

<P>The function copies the array of <I>char</I> beginning at
<CODE>s2</CODE> to the array of <I>char</I> beginning at <CODE>s1</CODE>
(both of size <CODE>n</CODE>). It returns <CODE>s1</CODE>. If the arrays
overlap, the function accesses each of the element values from
<CODE>s2</CODE> before it stores a new value in that element, so the copy is
not corrupted.</P>

<H2><A NAME="memset"><CODE>memset</CODE></A></H2>

<PRE>void *<B>memset</B>(void *s, int c, size_t n);</PRE>

<P>The function stores <CODE>(unsigned char)c</CODE> in each of the
elements of the array of <I>unsigned char</I> beginning at <CODE>s</CODE>,
with size <CODE>n</CODE>. It returns <CODE>s</CODE>.</P>

<H2><A NAME="NULL"><CODE>NULL</CODE></A></H2>

<PRE>#define <B>NULL</B> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B></PRE>

<P>The macro yields a null pointer constant that is usable as an
<A HREF="express.html#address constant expression">
address constant expression</A>.</P>

<H2><A NAME="size_t"><CODE>size_t</CODE></A></H2>

<PRE>typedef <I>ui-type</I> <B>size_t</B>;</PRE>

<P>The type is the unsigned integer type <CODE><I>ui-type</I></CODE>
of an object that you declare to store the result of the
<A HREF="express.html#sizeof operator"><I>sizeof</I></A> operator.</P>

<H2><A NAME="strcat"><CODE>strcat</CODE></A></H2>

<PRE>char *<B>strcat</B>(char *restrict s1, const char *restrict s2);</PRE>

<P>The function copies the string <CODE>s2</CODE>, including its
terminating null character, to successive elements
of the array of <I>char</I> that stores the string <CODE>s1</CODE>,
beginning with the element that stores
the terminating null character of <CODE>s1</CODE>. It returns
<CODE>s1</CODE>.</P>

<H2><A NAME="strchr"><CODE>strchr</CODE></A></H2>

<PRE>char *<B>strchr</B>(const char *s, int c); <B>[not in C++]</B>
const char *<B>strchr</B>(const char *s, int c); <B>[C++ only]</B>
char *<B>strchr</B>(char *s, int c); <B>[C++ only]</B></PRE>

<P>The function searches for the first element of the string
<CODE>s</CODE> that equals <CODE>(char)c</CODE>. It considers the
terminating null character as part of the string. If successful, the function
returns the address of the matching element; otherwise, it returns a null
pointer.</P>

<H2><A NAME="strcmp"><CODE>strcmp</CODE></A></H2>

<PRE>int <B>strcmp</B>(const char *s1, const char *s2);</PRE>

<P>The function compares successive elements from two strings,
<CODE>s1</CODE> and <CODE>s2</CODE>, until it finds elements that are not
equal.</P>

<UL>
<LI>If all elements are equal, the function returns zero.

<LI>If the differing element from <CODE>s1</CODE> is greater than the
element from <CODE>s2</CODE> (both taken as <I>unsigned char</I>), the
function returns a positive number.

<LI>Otherwise, the function returns a negative number.
</UL>

<H2><A NAME="strcoll"><CODE>strcoll</CODE></A></H2>

<PRE>int <B>strcoll</B>(const char *s1, const char *s2);</PRE>

<P>The function compares two strings, <CODE>s1</CODE> and
<CODE>s2</CODE>, using a comparison rule that depends on the current
<A HREF="locale.html#locale">locale</A>. If <CODE>s1</CODE>
compares greater than <CODE>s2</CODE> by this rule, the function returns a
positive number. If the two strings compare equal,
it returns zero. Otherwise, it returns a negative number.</P>

<H2><A NAME="strcpy"><CODE>strcpy</CODE></A></H2>

<PRE>char *<B>strcpy</B>(char *restrict s1, const char *restrict s2);</PRE>

<P>The function copies the string <CODE>s2</CODE>, including its
terminating null character, to successive elements
of the array of <I>char</I>
whose first element has the address <CODE>s1</CODE>. It returns
<CODE>s1</CODE>.</P>

<H2><A NAME="strcspn"><CODE>strcspn</CODE></A></H2>

<PRE>size_t <B>strcspn</B>(const char *s1, const char *s2);</PRE>

<P>The function searches for the first element
<CODE>s1[i]</CODE> in the string <CODE>s1</CODE> that
equals <I>any one</I> of the elements of the string <CODE>s2</CODE> and
returns <CODE>i</CODE>. Each terminating null character
is considered part of its string.</P>

<H2><A NAME="strerror"><CODE>strerror</CODE></A></H2>

<PRE>char *<B>strerror</B>(int errcode);</PRE>

<P>The function returns a pointer to an internal static-duration object
containing the message string corresponding to the error code
<CODE>errcode</CODE>. The program must not alter any of the values stored in
this object. A later call to <CODE>strerror</CODE> can alter the value stored
in this object.</P>

<H2><A NAME="strlen"><CODE>strlen</CODE></A></H2>

<PRE>size_t <B>strlen</B>(const char *s);</PRE>

<P>The function returns the number of characters in the string
<CODE>s</CODE>, <I>not</I> including its terminating null character.</P>

<H2><A NAME="strncat"><CODE>strncat</CODE></A></H2>

<PRE>char *<B>strncat</B>(char *s1, const char *s2, size_t n);</PRE>

<P>The function copies the string <CODE>s2</CODE>, <I>not</I> including
its terminating null character, to successive elements of the array of
<I>char</I> that stores the string <CODE>s1</CODE>, beginning with the
element that stores the terminating null character of <CODE>s1</CODE>. The
function copies no more than <CODE>n</CODE> characters from
<CODE>s2</CODE>. It then stores a null character, in the next element to be
altered in <CODE>s1</CODE>, and returns <CODE>s1</CODE>.</P>

<H2><A NAME="strncmp"><CODE>strncmp</CODE></A></H2>

<PRE>int <B>strncmp</B>(const char *s1, const char *s2, size_t n);</PRE>

<P>The function compares successive elements from two strings,
<CODE>s1</CODE> and <CODE>s2</CODE>, until it finds elements that are not
equal or until it has compared the first <CODE>n</CODE> elements of the two
strings.</P>

<UL>
<LI>If all elements are equal, the function returns zero.

<LI>If the differing element from <CODE>s1</CODE> is greater than the
element from <CODE>s2</CODE> (both taken as <I>unsigned char</I>), the
function returns a positive number.

<LI>Otherwise, it returns a negative number.
</UL>

<H2><A NAME="strncpy"><CODE>strncpy</CODE></A></H2>

<PRE>char *<B>strncpy</B>(char *restrict s1, const char *restrict s2, size_t n);</PRE>

<P>The function copies the string <CODE>s2</CODE>, <I>not</I> including
its terminating null character, to successive elements of the array of
<I>char</I> whose first element has the address <CODE>s1</CODE>. It copies no
more than <CODE>n</CODE> characters from <CODE>s2</CODE>. The function then
stores zero or more null characters in the next elements to be altered in
<CODE>s1</CODE> until it stores a total of <CODE>n</CODE> characters. It
returns <CODE>s1</CODE>.</P>

<H2><A NAME="strpbrk"><CODE>strpbrk</CODE></A></H2>

<PRE>char *<B>strpbrk</B>(const char *s1,
    const char *s2); <B>[not in C++]</B>
const char *<B>strpbrk</B>(const char *s1,
    const char *s2); <B>[C++ only]</B>
char *<B>strpbrk</B>(char *s1,
    const char *s2); <B>[C++ only]</B></PRE>

<P>The function searches for the first element
<CODE>s1[i]</CODE> in the string <CODE>s1</CODE> that
equals <I>any one</I> of the elements of the string <CODE>s2</CODE>. It
considers each terminating null character as part of its string. If
<CODE>s1[i]</CODE> is not the terminating null character, the
function returns <CODE>&amp;s1[i]</CODE>; otherwise, it returns a
null pointer.</P>

<H2><A NAME="strrchr"><CODE>strrchr</CODE></A></H2>

<PRE>char *<B>strrchr</B>(const char *s, int c); <B>[not in C++]</B>
const char *<B>strrchr</B>(const char *s, int c); <B>[C++ only]</B>
char *<B>strrchr</B>(char *s, int c); <B>[C++ only]</B></PRE>

<P>The function searches for the last element of the string <CODE>s</CODE>
that equals <CODE>(char)c</CODE>. It considers the terminating null character
as part of the string. If successful, the function returns the address of the
matching element; otherwise, it returns a null pointer.</P>

<H2><A NAME="strspn"><CODE>strspn</CODE></A></H2>

<PRE>size_t <B>strspn</B>(const char *s1, const char *s2);</PRE>

<P>The function searches for the first element
<CODE>s1[i]</CODE> in the string <CODE>s1</CODE> that
equals <I>none</I> of the elements of the string <CODE>s2</CODE> and returns
<CODE>i</CODE>. It considers the terminating null character
as part of the string <CODE>s1</CODE> only.</P>

<H2><A NAME="strstr"><CODE>strstr</CODE></A></H2>

<PRE>char *<B>strstr</B>(const char *s1,
    const char *s2); <B>[not in C++]</B>
const char *<B>strstr</B>(const char *s1,
    const char *s2); <B>[C++ only]</B>
char *<B>strstr</B>(char *s1, const char *s2); <B>[C++ only]</B></PRE>

<P>The function searches for the first sequence of elements in the string
<CODE>s1</CODE> that matches the sequence of elements in the string
<CODE>s2</CODE>, <I>not</I> including its terminating null character. If
successful, the function returns the address of the matching first element;
otherwise, it returns a null pointer.</P>

<H2><A NAME="strtok"><CODE>strtok</CODE></A></H2>

<PRE>char *<B>strtok</B>(char *restrict s1, const char *restrict s2);</PRE>

<P>If <CODE>s1</CODE> is not a null pointer, the function begins a search
of the string <CODE>s1</CODE>. Otherwise, it begins a search of the string
whose address was last stored in an internal static-duration object on an
earlier call to the function, as described below. The search proceeds as
follows:</P>

<OL>
<LI>The function searches the string for <CODE>begin</CODE>,
the address of the first element that equals
<I>none</I> of the elements of the string
<CODE>s2</CODE> (a set of token separators). It considers the terminating
null character as part of the search string only.

<LI>If the search does not find an element, the function stores the address
of the terminating null character in the internal static-duration object (so
that a subsequent search beginning with that address will fail) and returns a
null pointer. Otherwise, the function searches from <CODE>begin</CODE> for
<CODE>end</CODE>, the address of the first element
that equals <I>any one</I> of the elements of the string <CODE>s2</CODE>.
It again considers the terminating
null character as part of the search string only.

<LI>If the search does not find an element, the function stores the address
of the terminating null character in the internal static-duration object.
Otherwise, it stores a null character in the element whose address is
<CODE>end</CODE>. Then it stores the address
of the next element after <CODE>end</CODE> in
the internal static-duration object
(so that a subsequent search beginning with
that address will continue with the remaining elements of the string) and
returns <CODE>begin</CODE>.
</OL>

<H2><A NAME="strxfrm"><CODE>strxfrm</CODE></A></H2>

<PRE>size_t <B>strxfrm</B>(char *restrict s1, const char *restrict s2, size_t n);</PRE>

<P>The function stores a string in the array of <I>char</I> whose first
element has the address <CODE>s1</CODE>. It stores no more than
<CODE>n</CODE> characters, <I>including</I> the terminating null character,
and returns the number of characters needed to represent the entire string,
<I>not</I> including the terminating null character. If the value returned is
<CODE>n</CODE> or greater, the values stored in the array are indeterminate.
(If <CODE>n</CODE> is zero, <CODE>s1</CODE> can be a null pointer.)</P>

<P><CODE>strxfrm</CODE> generates the string it stores from the string
<CODE>s2</CODE> by using a transformation rule that depends on the current
<A HREF="locale.html#locale">locale</A>.
For example, if <CODE>x</CODE> is a transformation
of <CODE>s1</CODE> and <CODE>y</CODE> is a transformation
of <CODE>s2</CODE>, then
<CODE><A HREF="#strcmp">strcmp</A>(x, y)</CODE>
returns the same value as
<CODE><A HREF="#strcoll">strcoll</A>(s1, s2)</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pb.html">Copyright</A> &#169; 1989-2002
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

<!--V4.02:1476--></BODY></HTML>
