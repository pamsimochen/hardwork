<HTML><HEAD><TITLE>&lt;stdlib.h&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;stdlib.h&gt;"><CODE>&lt;stdlib.h&gt;</CODE></A></H1><HR>

<P><B><CODE><A HREF="#EXIT_FAILURE">EXIT_FAILURE</A>
&#183; <A HREF="#EXIT_SUCCESS">EXIT_SUCCESS</A>
&#183; <A HREF="#MB_CUR_MAX">MB_CUR_MAX</A>
&#183; <A HREF="#NULL">NULL</A>
&#183; <A HREF="#RAND_MAX">RAND_MAX</A>
</CODE></B></P>

<P><B><CODE><A HREF="#abort">abort</A>
&#183; <A HREF="#abs">abs</A>
&#183; <A HREF="#atexit">atexit</A>
&#183; <A HREF="#atof">atof</A>
&#183; <A HREF="#atoi">atoi</A>
&#183; <A HREF="#atol">atol</A>
&#183; <A HREF="#bsearch">bsearch</A>
&#183; <A HREF="#calloc">calloc</A>
&#183; <A HREF="#div">div</A>
&#183; <A HREF="#div_t">div_t</A>
&#183; <A HREF="#exit">exit</A>
&#183; <A HREF="#free">free</A>
&#183; <A HREF="#getenv">getenv</A>
&#183; <A HREF="#labs">labs</A>
&#183; <A HREF="#ldiv">ldiv</A>
&#183; <A HREF="#ldiv_t">ldiv_t</A>
&#183; <A HREF="#malloc">malloc</A>
&#183; <A HREF="#mblen">mblen</A>
&#183; <A HREF="#mbstowcs">mbstowcs</A>
&#183; <A HREF="#mbtowc">mbtowc</A>
&#183; <A HREF="#qsort">qsort</A>
&#183; <A HREF="#rand">rand</A>
&#183; <A HREF="#realloc">realloc</A>
&#183; <A HREF="#size_t">size_t</A>
&#183; <A HREF="#srand">srand</A>
&#183; <A HREF="#strtod">strtod</A>
&#183; <A HREF="#strtol">strtol</A>
&#183; <A HREF="#strtoul">strtoul</A>
&#183; <A HREF="#system">system</A>
&#183; <A HREF="#wchar_t">wchar_t</A>
&#183; <A HREF="#wcstombs">wcstombs</A>
&#183; <A HREF="#wctomb">wctomb</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;stdlib.h&gt;</CODE></B> to declare an
assortment of useful functions and to define the macros and types
that help you use them.</P>

<PRE>    /* MACROS */
#define <A HREF="#EXIT_FAILURE"><B>EXIT_FAILURE</B></A> <I>&lt;rvalue integer expression&gt;</I>
#define <A HREF="#EXIT_SUCCESS"><B>EXIT_SUCCESS</B></A> <I>&lt;rvalue integer expression&gt;</I>
#define <A HREF="#MB_CUR_MAX"><B>MB_CUR_MAX</B></A> <I>&lt;rvalue integer expression &gt;= 1&gt;</I>
#define <A HREF="#NULL"><B>NULL</B></A> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B>
#define <A HREF="#RAND_MAX"><B>RAND_MAX</B></A> <I>&lt;integer constant expression &gt;= 32,767&gt;</I>

    /* TYPES */
typedef struct {
    int quot, rem;
    } <A HREF="#div_t"><B>div_t</B></A>;
typedef struct {
    long quot, rem;
    } <A HREF="#ldiv_t"><B>ldiv_t</B></A>;

typedef <I>ui-type</I> <A HREF="#size_t"><B>size_t</B></A>;
typedef <I>i-type</I> <A HREF="#wchar_t"><B>wchar_t</B></A>; <B>[keyword in C++]</B>

    /* FUNCTIONS */
int <A HREF="#abs"><B>abs</B></A>(int i);
long <A HREF="#abs"><B>abs</B></A>(long i); <B>[C++ only]</B>
long <A HREF="#labs"><B>labs</B></A>(long i);

div_t <A HREF="#div"><B>div</B></A>(int numer, int denom);
ldiv_t <A HREF="#div"><B>div</B></A>(long numer, long denom); <B>[C++ only]</B>
ldiv_t <A HREF="#ldiv"><B>ldiv</B></A>(long numer, long denom);

int <A HREF="#rand"><B>rand</B></A>(void);
void <A HREF="#srand"><B>srand</B></A>(unsigned int seed);

double <A HREF="#atof"><B>atof</B></A>(const char *s);
int <A HREF="#atoi"><B>atoi</B></A>(const char *s);
long <A HREF="#atol"><B>atol</B></A>(const char *s);
double <A HREF="#strtod"><B>strtod</B></A>(const char *s, char **endptr);

long <A HREF="#strtol"><B>strtol</B></A>(const char *s, char **endptr, int base);
unsigned long <A HREF="#strtoul"><B>strtoul</B></A>(const char *s, char **endptr,
    int base);

void *<A HREF="#calloc"><B>calloc</B></A>(size_t nelem, size_t size);
void <A HREF="#free"><B>free</B></A>(void *ptr);
void *<A HREF="#malloc"><B>malloc</B></A>(size_t size);
void *<A HREF="#realloc"><B>realloc</B></A>(void *ptr, size_t size);

int <A HREF="#mblen"><B>mblen</B></A>(const char *s, size_t n);
size_t <A HREF="#mbstowcs"><B>mbstowcs</B></A>(wchar_t *wcs, const char *s, size_t n);
int <A HREF="#mbtowc"><B>mbtowc</B></A>(wchar_t *pwc, const char *s, size_t n);
size_t <A HREF="#wcstombs"><B>wcstombs</B></A>(char *s, const wchar_t *wcs, size_t n);
int <A HREF="#wctomb"><B>wctomb</B></A>(char *s, wchar_t wchar);

void <A HREF="#exit"><B>exit</B></A>(int status);
void <A HREF="#abort"><B>abort</B></A>(void);
char *<A HREF="#getenv"><B>getenv</B></A>(const char *name);
int <A HREF="#system"><B>system</B></A>(const char *s);

extern "C++"
    int <A HREF="#atexit"><B>atexit</B></A>(void (*func)(void)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    int <A HREF="#atexit"><B>atexit</B></A>(void (*func)(void));

extern "C++"
    void *<A HREF="#bsearch"><B>bsearch</B></A>(const void *key, const void *base,
        size_t nelem, size_t size,
            int (*cmp)(const void *ck,
                const void *ce)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void *<A HREF="#bsearch"><B>bsearch</B></A>(const void *key, const void *base,
        size_t nelem, size_t size,
            int (*cmp)(const void *ck,
                const void *ce));

extern "C++"
    void <A HREF="#qsort"><B>qsort</B></A>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2));
            <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void <A HREF="#qsort"><B>qsort</B></A>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2));</PRE>

<H2><A NAME="abort"><CODE>abort</CODE></A></H2>

<PRE>void <B>abort</B>(void);</PRE>

<P>The function calls
<CODE><A HREF="signal.html#raise">raise</A>(SIGABRT)</CODE>,
which reports the abort signal,
<A HREF="signal.html#SIGABRT"><CODE>SIGABRT</CODE></A>.
Default handling for the abort signal is to cause abnormal
program termination and report unsuccessful termination to the target
environment. Whether or not the target environment flushes output
streams, closes open files, or removes temporary files on abnormal
termination is implementation defined. If you specify handling that causes
<A HREF="signal.html#raise"><CODE>raise</CODE></A>
to return control to <CODE>abort</CODE>, the function calls
<CODE><A HREF="#exit">exit</A>(EXIT_FAILURE)</CODE>,
to report unsuccessful termination with
<A HREF="#EXIT_FAILURE"><CODE>EXIT_FAILURE</CODE></A>.
<CODE>abort</CODE> never returns control to its caller.</P>

<H2><A NAME="abs"><CODE>abs</CODE></A></H2>

<PRE>int <B>abs</B>(int i);
long <B>abs</B>(long i); <B>[C++ only]</B></PRE>

<P>The function returns the absolute value of
<CODE>i</CODE>, <CODE>|i|</CODE>. The version that accepts
a <I>long</I> argument behaves the same as
<A HREF="#abs"><CODE>labs</CODE></A></P>

<H2><A NAME="atexit"><CODE>atexit</CODE></A></H2>

<PRE>extern "C++"
    int <B>atexit</B>(void (*func)(void)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    int <B>atexit</B>(void (*func)(void));</PRE>

<P>The function registers the function whose address is <CODE>func</CODE>
to be called by
<A HREF="#exit"><CODE>exit</CODE></A> (or when
<A HREF="lib_over.html#main"><CODE>main</CODE></A> returns)
and returns zero if successful.
The functions are called in reverse order of registry. You can register at
least 32 functions.</P>

<P>Furthermore, in C++, if control leaves a called function because
it fails to handle a thrown exception, <CODE>terminate</CODE>
is called.</P>

<H2><A NAME="atof"><CODE>atof</CODE></A></H2>

<PRE>double <B>atof</B>(const char *s);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>double</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE><A HREF="#strtod">strtod</A>(s, 0)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="atoi"><CODE>atoi</CODE></A></H2>

<PRE>int <B>atoi</B>(const char *s);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>int</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE>(int)<A HREF="#strtol">strtol</A>(s, 0, 10)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="atol"><CODE>atol</CODE></A></H2>

<PRE>long <B>atol</B>(const char *s);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long</I> and then returns
<CODE>x.</CODE> The conversion is the same as for
<CODE><A HREF="#strtol">strtol</A>(s, 0, 10)</CODE>,
except that a value is not necessarily stored in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
if a conversion error occurs.</P>

<H2><A NAME="bsearch"><CODE>bsearch</CODE></A></H2>

<PRE>extern "C++"
    void *<B>bsearch</B>(const void *key, const void *base,
        size_t nelem, size_t size,
            int (*cmp)(const void *ck,
                const void *ce)); <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void *<B>bsearch</B>(const void *key, const void *base,
        size_t nelem, size_t size,
            int (*cmp)(const void *ck,
                const void *ce));</PRE>

<P>The function searches an array of ordered values and returns
the address of an array element that equals the search key <CODE>key</CODE>
(if one exists); otherwise, it returns a null pointer. The array consists
of <CODE>nelem</CODE> elements, each of <CODE>size</CODE> bytes,
beginning with the element whose address is <CODE>base</CODE>.</P>

<P><CODE>bsearch</CODE> calls the comparison function whose address is
<CODE>cmp</CODE> to compare the search key with elements of the array. The
comparison function must return:</P>

<UL>
<LI>a negative value if the search key <CODE>ck</CODE> is less than the
array element <CODE>ce</CODE>

<LI>zero if the two are equal

<LI>a positive value if the search key is greater than the array
element
</UL>

<P><CODE>bsearch</CODE> assumes that the array elements are in ascending
order according to the same comparison rules that are used by the
comparison function.</P>

<H2><A NAME="calloc"><CODE>calloc</CODE></A></H2>

<PRE>void *<B>calloc</B>(size_t nelem, size_t size);</PRE>

<P>The function allocates an array object containing <CODE>nelem</CODE>
elements each of size <CODE>size</CODE>, stores zeros in all bytes of the
array, and returns the address of the first element of the array if
successful; otherwise, it returns a null pointer. You can safely convert
the return value to an object pointer of any type whose size in bytes
is not greater than <CODE>size</CODE>.</P>

<H2><A NAME="div"><CODE>div</CODE></A></H2>

<PRE>div_t <B>div</B>(int numer, int denom);
ldiv_t <B>div</B>(long numer, long denom); <B>[C++ only]</B></PRE>

<P>The function divides <CODE>numer</CODE> by <CODE>denom</CODE> and returns
both quotient and remainder in the structure
result <CODE>x</CODE>, if the quotient can be represented.
The structure member <CODE>x.quot</CODE>
is the algebraic quotient truncated toward zero.
The structure member <CODE>x.rem</CODE> is the remainder, such
that <CODE>numer == x.quot*denom + x.rem</CODE>.</P>

<H2><A NAME="div_t"><CODE>div_t</CODE></A></H2>

<PRE>typedef struct {
    int quot, rem;
    } <B>div_t</B>;</PRE>

<P>The type is the structure type returned by the function
<A HREF="#div"><CODE>div</CODE></A>.
The structure contains members that represent the quotient
(<CODE>quot</CODE>) and remainder (<CODE>rem</CODE>)
of a signed integer division with operands of type <I>int.</I> The
members shown above can occur in either order.</P>

<H2><A NAME="exit"><CODE>exit</CODE></A></H2>

<PRE>void <B>exit</B>(int status);</PRE>

<P>The function calls all functions registered by
<A HREF="#atexit"><CODE>atexit</CODE></A>,
closes all files, and returns control to the target environment. If
<CODE>status</CODE> is zero or
<A HREF="#EXIT_SUCCESS"><CODE>EXIT_SUCCESS</CODE></A>,
the program reports successful termination. If <CODE>status</CODE> is
<A HREF="#EXIT_FAILURE"><CODE>EXIT_FAILURE</CODE></A>, the
program reports unsuccessful termination. An implementation can define
additional values for <CODE>status</CODE>.</P>

<H2><A NAME="EXIT_FAILURE"><CODE>EXIT_FAILURE</CODE></A></H2>

<PRE>#define <B>EXIT_FAILURE</B> <I>&lt;rvalue integer expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>status</CODE> argument to
<A HREF="#exit"><CODE>exit</CODE></A>
that reports unsuccessful termination.</P>

<H2><A NAME="EXIT_SUCCESS"><CODE>EXIT_SUCCESS</CODE></A></H2>

<PRE>#define <B>EXIT_SUCCESS</B> <I>&lt;rvalue integer expression&gt;</I></PRE>

<P>The macro yields the value of the <CODE>status</CODE> argument to
<A HREF="#exit"><CODE>exit</CODE></A>
that reports successful termination.</P>

<H2><A NAME="free"><CODE>free</CODE></A></H2>

<PRE>void <B>free</B>(void *ptr);</PRE>

<P>If <CODE>ptr</CODE> is not a null pointer, the function deallocates
the object whose address is <CODE>ptr</CODE>; otherwise, it does nothing.
You can deallocate only objects that you first allocate by calling
<A HREF="#calloc"><CODE>calloc</CODE></A>,
<A HREF="#malloc"><CODE>malloc</CODE></A>, or
<A HREF="#realloc"><CODE>realloc</CODE></A>.</P>

<H2><A NAME="getenv"><CODE>getenv</CODE></A></H2>

<PRE>char *<B>getenv</B>(const char *name);</PRE>

<P>The function searches an
<B><A NAME="environment list">environment list</A></B>,
which each implementation defines, for an entry
whose name matches the string <CODE>name</CODE>. If
the function finds a match, it returns a pointer to a static-duration
object that holds the definition associated with the target environment
name. Otherwise, it returns a null pointer. Do not alter the value
stored in the object. If you call <CODE>getenv</CODE> again, the value stored
in the object can change. No target environment names are required
of all environments.</P>

<H2><A NAME="labs"><CODE>labs</CODE></A></H2>

<PRE>long <B>labs</B>(long i);</PRE>

<P>The function returns the absolute value of <CODE>i</CODE>,
<CODE>|i|</CODE>, the same as
<A HREF="#abs"><CODE>abs</CODE></A>.</P>

<H2><A NAME="ldiv"><CODE>ldiv</CODE></A></H2>

<PRE>ldiv_t <B>ldiv</B>(long numer, long denom);</PRE>

<P>The function divides <CODE>numer</CODE> by <CODE>denom</CODE> and returns
both quotient and remainder in the structure
result <CODE>x</CODE>, if the quotient can be represented.
The structure member <CODE>x.quot</CODE>
is the algebraic quotient truncated toward zero.
The structure member <CODE>x.rem</CODE> is the remainder, such
that <CODE>numer == x.quot*denom + x.rem</CODE>.</P>

<H2><A NAME="ldiv_t"><CODE>ldiv_t</CODE></A></H2>

<PRE>typedef struct {
    long quot, rem;
    } <B>ldiv_t</B>;</PRE>

<P>The type is the structure type returned by the function
<A HREF="#ldiv"><CODE>ldiv</CODE></A>.
The structure contains members that represent the quotient
(<CODE>quot</CODE>) and remainder (<CODE>rem</CODE>)
of a signed integer division with operands of type <I>long.</I> The
members shown above can occur in either order.</P>

<H2><A NAME="malloc"><CODE>malloc</CODE></A></H2>

<PRE>void *<B>malloc</B>(size_t size);</PRE>

<P>The function allocates an object of size <CODE>size</CODE>, and returns
the address of the object if successful; otherwise, it returns a null
pointer. The values stored in the object are indeterminate. You can
safely convert the return value to an object pointer of any type whose
size is not greater than <CODE>size</CODE>.</P>

<H2><A NAME="MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A></H2>

<PRE>#define <B>MB_CUR_MAX</B> <I>&lt;rvalue integer expression &gt;= 1&gt;</I></PRE>

<P>The macro yields the maximum number of characters that constitute a
<A HREF="charset.html#Multibyte Characters">multibyte character</A>
in the current
<A HREF="locale.html">locale</A>. Its value is &lt;=
<A HREF="limits.html#MB_LEN_MAX"><CODE>MB_LEN_MAX</CODE></A>.</P>

<H2><A NAME="mblen"><CODE>mblen</CODE></A></H2>

<PRE>int <B>mblen</B>(const char *s, size_t n);</PRE>

<P>If <CODE>s</CODE> is not a null pointer, the function returns the
number of bytes in the multibyte string <CODE>s</CODE> that constitute the
next multibyte character, or it returns -1 if the next <CODE>n</CODE>
(or the remaining) bytes do not constitute a valid multibyte character.
<CODE>mblen</CODE> does not include the terminating null in the count of
bytes. The function can use a
<A HREF="charset.html#conversion state">conversion state</A>
stored in an internal
static-duration object to determine how
to interpret the multibyte string.</P>

<P>If <CODE>s</CODE> is a null pointer and if multibyte characters have a
<A HREF="charset.html#state-dependent encoding">state-dependent encoding</A>
in the current
<A HREF="locale.html#locale">locale</A>, the function stores the
<A HREF="charset.html#initial conversion state">initial conversion state</A>
in its internal static-duration object and
returns nonzero; otherwise, it returns zero.</P>

<H2><A NAME="mbstowcs"><CODE>mbstowcs</CODE></A></H2>

<PRE>size_t <B>mbstowcs</B>(wchar_t *wcs, const char *s, size_t n);</PRE>

<P>The function stores a wide character string, in successive elements
of the array whose first element has the address <CODE>wcs</CODE>,
by converting, in turn, each of the multibyte characters
in the multibyte string <CODE>s</CODE>.
The string begins in the
<A HREF="charset.html#initial conversion state">initial conversion state</A>.
The function converts each character as if by calling
<A HREF="#mbtowc"><CODE>mbtowc</CODE></A> (except that
the internal conversion state stored for that function is unaffected).
It stores at most <CODE>n</CODE> wide characters, stopping after it stores
a null wide character. It returns the number of wide characters it
stores, not counting the null wide character, if all conversions are
successful; otherwise, it returns -1.</P>

<H2><A NAME="mbtowc"><CODE>mbtowc</CODE></A></H2>

<PRE>int <B>mbtowc</B>(wchar_t *pwc, const char *s, size_t n);</PRE>

<P>If <CODE>s</CODE> is not a null pointer,
the function determines <CODE>x</CODE>,
the number of bytes in the multibyte string <CODE>s</CODE> that constitute
the next multibyte character.
(<CODE>x</CODE> cannot be greater than
<A HREF="#MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A>.)
If <CODE>pwc</CODE> is not a null pointer, the function converts the next
multibyte character to its corresponding wide-character value and
stores that value in <CODE>*pwc</CODE>.
It then returns <CODE>x,</CODE> or it
returns -1 if the next <CODE>n</CODE> or the remaining bytes do not
constitute a valid multibyte character. <CODE>mbtowc</CODE> does not include
the terminating null in the count of bytes. The function can use a
<A HREF="charset.html#conversion state">conversion state</A>
stored in an internal static-duration object to determine
how to interpret the multibyte string.</P>

<P>If <CODE>s</CODE> is a null pointer and if multibyte characters have a
<A HREF="charset.html#state-dependent encoding">state-dependent encoding</A>
in the current
<A HREF="locale.html#locale">locale</A>, the function stores the
<A HREF="charset.html#initial conversion state">initial conversion state</A>
in its internal static-duration object and
returns nonzero; otherwise, it returns zero.</P>

<H2><A NAME="NULL"><CODE>NULL</CODE></A></H2>

<PRE>#define <B>NULL</B> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B></PRE>

<P>The macro yields a null pointer constant that is usable as an
<A HREF="express.html#address constant expression">
address constant expression</A>.</P>

<H2><A NAME="qsort"><CODE>qsort</CODE></A></H2>

<PRE>extern "C++"
    void <B>qsort</B>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2));
            <B>[C++ only]</B>
extern "C" <B>[C++ only]</B>
    void <B>qsort</B>(void *base, size_t nelem, size_t size,
        int (*cmp)(const void *e1, const void *e2));</PRE>

<P>The function sorts, in place, an array consisting of <CODE>nelem</CODE>
elements, each of <CODE>size</CODE> bytes, beginning with the element whose
address is <CODE>base</CODE>. It calls the comparison function whose address
is <CODE>cmp</CODE> to compare pairs of elements. The comparison function
must return a negative value if <CODE>e1</CODE> is less than <CODE>e2</CODE>,
zero if the two are equal, or a positive value if <CODE>e1</CODE> is greater
than <CODE>e2</CODE>. Two array elements that are equal can appear in the
sorted array in either order.</P>

<H2><A NAME="rand"><CODE>rand</CODE></A></H2>

<PRE>int <B>rand</B>(void);</PRE>

<P>The function computes a pseudo-random number <CODE>x</CODE> based
on a seed value stored in an internal static-duration object, alters
the stored seed value, and returns <CODE>x.</CODE>
<CODE>x</CODE> is in the interval [0,
<A HREF="#RAND_MAX"><CODE>RAND_MAX</CODE></A>].</P>

<H2><A NAME="RAND_MAX"><CODE>RAND_MAX</CODE></A></H2>

<PRE>#define <B>RAND_MAX</B> <I>&lt;integer constant expression &gt;= 32,767&gt;</I></PRE>

<P>The macro yields the maximum value returned by <CODE>rand</CODE>.</P>

<H2><A NAME="realloc"><CODE>realloc</CODE></A></H2>

<PRE>void *<B>realloc</B>(void *ptr, size_t size);</PRE>

<P>The function allocates an object of size <CODE>size</CODE>, possibly
obtaining initial stored values from the object
whose address is <CODE>ptr</CODE>.
It returns the address of the new object if successful; otherwise,
it returns a null pointer. You can safely convert the return value
to an object pointer of any type
whose size is not greater than <CODE>size</CODE>.</P>

<P>If <CODE>ptr</CODE> is not a null pointer, it must be the address
of an existing object that you first allocate by calling
<A HREF="#calloc"><CODE>calloc</CODE></A>,
<A HREF="#malloc"><CODE>malloc</CODE></A>, or
<CODE>realloc</CODE>. If the existing object is not larger
than the newly allocated object, <CODE>realloc</CODE> copies the entire
existing object to the initial part of the allocated object. (The
values stored in the remainder of the object are indeterminate.) Otherwise,
the function copies only the initial part of the existing object that
fits in the allocated object. If <CODE>realloc</CODE> succeeds in allocating
a new object, it deallocates the existing object. Otherwise, the existing
object is left unchanged.</P>

<P>If <CODE>ptr</CODE> is a null pointer, the function does not store
initial values in the newly created object.</P>

<H2><A NAME="size_t"><CODE>size_t</CODE></A></H2>

<PRE>typedef <I>ui-type</I> <B>size_t</B>;</PRE>

<P>The type is the unsigned integer type <CODE><I>ui-type</I></CODE>
of an object that you declare to store the result of the
<A HREF="express.html#sizeof operator"><I>sizeof</I></A> operator.</P>

<H2><A NAME="srand"><CODE>srand</CODE></A></H2>

<PRE>void <B>srand</B>(unsigned int seed);</PRE>

<P>The function stores the seed value <CODE>seed</CODE>
in a static-duration object that
<A HREF="#rand"><CODE>rand</CODE></A>
uses to compute a pseudo-random number. From a given seed value,
that function always generates the same sequence of return
values. The program behaves as if the target environment calls
<CODE>srand(1)</CODE> at program startup.</P>

<H2><A NAME="strtod"><CODE>strtod</CODE></A></H2>

<PRE>double <B>strtod</B>(const char *s, char **endptr);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>double.</I>
If <CODE>endptr</CODE> is not a null pointer,
the function stores a pointer to the unconverted
remainder of the string in <CODE>*endptr</CODE>. The function then returns
<CODE>x</CODE>.</P>

<P>The initial characters of the string <CODE>s</CODE> must consist of
zero or more characters for which
<A HREF="ctype.html#isspace"><CODE>isspace</CODE></A> returns nonzero,
followed by an optional plus or minus sign,
followed by the longest sequence of one or more characters that match
the pattern for <CODE>strtod</CODE> shown in the diagram.</P>

<P><IMG SRC="strtod.gif"></P>

<P>Here, a <CODE><I>point</I></CODE> is the
<A HREF="locale.html#decimal_point">decimal-point</A>
character for the current
<A HREF="locale.html#locale">locale</A>.
(It is the dot (<CODE>.</CODE>) in the
<A HREF="locale.html#C locale"><CODE>"C"</CODE></A> locale.)
If the string <CODE>s</CODE> matches this pattern, its equivalent value
is the decimal integer represented by any digits to the left of the
<CODE><I>point</I></CODE>, plus the decimal fraction
represented by any digits to the right of the <CODE><I>point</I></CODE>,
times 10 raised to the signed decimal integer power
that follows an optional <CODE>e</CODE> or <CODE>E</CODE>. A leading
minus sign negates the value.</P>

<P>In locales other than the
<A HREF="locale.html#C locale"><CODE>"C"</CODE></A> locale,
<CODE>strtod</CODE> can define additional patterns as well.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If a
<A HREF="math.html#range error">range error</A> occurs,
<CODE>strtod</CODE> behaves exactly as the functions declared in
<A HREF="math.html#&lt;math.h&gt;"><CODE>&lt;math.h&gt;</CODE></A>.</P>

<H2><A NAME="strtol"><CODE>strtol</CODE></A></H2>

<PRE>long <B>strtol</B>(const char *s, char **endptr,
    int base);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>long.</I>
If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P>The initial characters of the string <CODE>s</CODE> must consist of
zero or more characters for which
<A HREF="ctype.html#isspace"><CODE>isspace</CODE></A> returns nonzero,
followed by the longest sequence of one or more characters that match
the pattern for <CODE>strtol</CODE> shown in the diagram.</P>

<P><IMG SRC="strtol.gif"></P>

<P>The function accepts the sequences
<CODE>0x</CODE> or <CODE>0X</CODE> only
when <CODE>base</CODE> equals zero or 16.
The letters <CODE>a-z</CODE> or <CODE>A-Z</CODE>
represent digits in the range [10, 36).
If <CODE>base</CODE> is in the range
[2, 36], the function accepts only digits
with values less than <CODE>base</CODE>.
If <CODE>base</CODE> == 0, then a leading <CODE>0x</CODE> or <CODE>0X</CODE>
(after any sign) indicates a hexadecimal (base 16) integer, a leading
<CODE>0</CODE> indicates an octal (base 8) integer, and any other valid
pattern indicates a decimal (base 10) integer.</P>

<P>If the string <CODE>s</CODE> matches this pattern, its equivalent
value is the signed integer of the appropriate base represented by
the digits that match the pattern. (A leading minus sign negates the
value.) In locales other than the
<A HREF="locale.html#C locale"><CODE>"C"</CODE></A> locale,
<CODE>strtol</CODE> can define additional patterns as well.</P>

<P>If the string <CODE>s</CODE> does not match a valid pattern, the value
stored in <CODE>*endptr</CODE> is <CODE>s</CODE>,
and <CODE>x</CODE> is zero. If the
equivalent value is too large to represent as type <I>long,</I>
<CODE>strtol</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A>
and returns either
<A HREF="limits.html#LONG_MAX"><CODE>LONG_MAX</CODE></A>,
if <CODE>x</CODE> is positive, or
<A HREF="limits.html#LONG_MIN"><CODE>LONG_MIN</CODE></A>,
if <CODE>x</CODE> is negative.</P>

<H2><A NAME="strtoul"><CODE>strtoul</CODE></A></H2>

<PRE>unsigned long <B>strtoul</B>(const char *s, char **endptr,
    int base);</PRE>

<P>The function converts the initial characters of the string <CODE>s</CODE>
to an equivalent value <CODE>x</CODE> of type <I>unsigned long.</I>
If <CODE>endptr</CODE> is not a null pointer,
it stores a pointer to the unconverted remainder
of the string in <CODE>*endptr</CODE>.
The function then returns <CODE>x</CODE>.</P>

<P><CODE>strtoul</CODE> converts strings exactly as does
<A HREF="#strtol"><CODE>strtol</CODE></A>,
but reports a range error only if the equivalent value is too large
to represent as type <I>unsigned long.</I>
In this case, <CODE>strtoul</CODE> stores the value of
<A HREF="errno.html#ERANGE"><CODE>ERANGE</CODE></A> in
<A HREF="errno.html#errno"><CODE>errno</CODE></A> and returns
<A HREF="limits.html#ULONG_MAX"><CODE>ULONG_MAX</CODE></A>.</P>

<H2><A NAME="system"><CODE>system</CODE></A></H2>

<PRE>int <B>system</B>(const char *s);</PRE>

<P>If <CODE>s</CODE> is not a null pointer, the function passes the string
<CODE>s</CODE> to be executed by a
<B><A NAME="command processor">command processor</A></B>, supplied by
the target environment, and returns the status reported by the command
processor. If <CODE>s</CODE> is a null pointer, the function returns nonzero
only if the target environment supplies a command processor. Each
implementation defines what strings its command processor accepts.</P>

<H2><A NAME="wchar_t"><CODE>wchar_t</CODE></A></H2>

<PRE>typedef <I>i-type</I> <B>wchar_t</B>; <B>[keyword in C++]</B></PRE>

<P>The type is the integer type <CODE><I>i-type</I></CODE> of a
<A HREF="charset.html#wide-character constant">
wide-character constant</A>, such as <CODE>L'X'</CODE>.
You declare an object of type <CODE>wchar_t</CODE> to hold a
<A HREF="charset.html#Wide-Character Encoding">wide character</A>.</P>

<H2><A NAME="wcstombs"><CODE>wcstombs</CODE></A></H2>

<PRE>size_t <B>wcstombs</B>(char *s, const wchar_t *wcs, size_t n);</PRE>

<P>The function stores a multibyte string, in successive elements
of the array whose first element has the address <CODE>s</CODE>,
by converting in turn each of the wide characters
in the string <CODE>wcs</CODE>. The multibyte string begins in the
<A HREF="charset.html#initial conversion state">initial conversion state</A>.
The function converts each wide character as if by calling
<A HREF="#wctomb"><CODE>wctomb</CODE></A> (except that the
<A HREF="charset.html#conversion state">conversion state</A>
stored for that function is unaffected). It stores no
more than <CODE>n</CODE> bytes, stopping after it stores a null byte. It
returns the number of bytes it stores, not counting the null byte,
if all conversions are successful; otherwise, it returns -1.</P>

<H2><A NAME="wctomb"><CODE>wctomb</CODE></A></H2>

<PRE>int <B>wctomb</B>(char *s, wchar_t wchar);</PRE>

<P>If <CODE>s</CODE> is not a null pointer,
the function determines <CODE>x,</CODE>
the number of bytes needed to represent
the multibyte character corresponding
to the wide character <CODE>wchar</CODE>.
<CODE>x</CODE> cannot exceed
<A HREF="#MB_CUR_MAX"><CODE>MB_CUR_MAX</CODE></A>.
The function converts <CODE>wchar</CODE> to its corresponding multibyte
character, which it stores in successive elements of the array whose
first element has the address <CODE>s</CODE>.
It then returns <CODE>x,</CODE> or it returns -1
if <CODE>wchar</CODE> does not correspond to a valid
multibyte character. <CODE>wctomb</CODE> includes the terminating
null byte in the count of bytes. The function can use a
<A HREF="charset.html#conversion state">conversion state</A>
stored in a static-duration object to determine how to interpret the
multibyte character string.</P>

<P>If <CODE>s</CODE> is a null pointer and if multibyte characters have a
<A HREF="charset.html#state-dependent encoding">state-dependent encoding</A>
in the current
<A HREF="locale.html#locale">locale</A>, the function stores the
<A HREF="charset.html#initial conversion state">initial conversion state</A>
in its static-duration object and returns
nonzero; otherwise, it returns zero.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pb.html">Copyright</A> &#169; 1989-2002
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

<!--V4.02:1476--></BODY></HTML>
