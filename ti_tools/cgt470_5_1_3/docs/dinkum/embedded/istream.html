<HTML><HEAD><TITLE>&lt;istream&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;istream&gt;"><CODE>&lt;istream&gt;</CODE></A></H1><HR>

<P>Include the <A HREF="lib_cpp.html#iostreams">iostreams</A>
standard header <B><CODE>&lt;istream&gt;</CODE></B>
to define class
<CODE><A HREF="#istream">istream</A></CODE>,
which mediates extractions for the iostreams.
The header also defines a related
<A HREF="ios.html#manipulators">manipulator</A>.
(This header is typically included for you by another
of the iostreams headers. You seldom have occasion to include it
directly.)</P>

<PRE>        // DECLARATIONS
class <B><A HREF="#istream">istream</A></B>;

        // EXTRACTORS
istream&amp;
    <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(istream&amp; istr, char *str);
istream&amp;
    <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(istream&amp; istr, char&amp; ch);
istream&amp;
    <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(istream&amp; istr, signed char *str);
istream&amp;
    <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(istream&amp; istr, signed char&amp; ch);
istream&amp;
    <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(istream&amp; istr, unsigned char *str);
istream&amp;
    <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(istream&amp; istr, unsigned char&amp; ch);

        // MANIPULATORS
istream&amp; <B><A HREF="#ws">ws</A></B>(istream&amp; istr);
        // END OF DECLARATIONS</PRE>


<H2><A NAME="istream"><CODE>istream</CODE></A></H2>

<HR>
<P><B><CODE><A HREF="#istream::istream">istream</A>
&#183; <A HREF="#istream::gcount">gcount</A>
&#183; <A HREF="#istream::get">get</A>
&#183; <A HREF="#istream::getline">getline</A>
&#183; <A HREF="#istream::ignore">ignore</A>
&#183; <A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A>
&#183; <A HREF="#istream::peek">peek</A>
&#183; <A HREF="#istream::putback">putback</A>
&#183; <A HREF="#istream::read">read</A>
&#183; <A HREF="#istream::readsome">readsome</A>
&#183; <A HREF="#istream::seekg">seekg</A>
&#183; <A HREF="#istream::sentry">sentry</A>
&#183; <A HREF="#istream::sync">sync</A>
&#183; <A HREF="#istream::tellg">tellg</A>
&#183; <A HREF="#istream::unget">unget</A>
</CODE></B></P>
<HR>

<PRE>class <B>istream</B> : public ios {
public:
    explicit <B><A HREF="#istream::istream">istream</A></B>(streambuf *strbuf);
    class <B><A HREF="#istream::sentry">sentry</A></B>;
    virtual <B>~istream</B>();
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(
        istream&amp; (*pfn)(istream&amp;));
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(
        ios_base&amp; (*pfn)(ios_base&amp;));
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(
        ios&amp; (*pfn)(ios&amp;));
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(
        streambuf *strbuf);
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(bool&amp; val);
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(short&amp; val);
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(unsigned short&amp; val);
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(int&amp; val);
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(unsigned int&amp; val);
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(long&amp; val);
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(unsigned long&amp; val);
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(void *&amp; val);
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(float&amp; val);
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(double&amp; val);
    istream&amp; <B><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></B>(long double&amp; val);
    streamsize <B><A HREF="#istream::gcount">gcount</A></B>() const;
    int_type <B><A HREF="#istream::get">get</A></B>();
    istream&amp; <B><A HREF="#istream::get">get</A></B>(char_type&amp; ch);
    istream&amp; <B><A HREF="#istream::get">get</A></B>(char_type *str, streamsize count);
    istream&amp;
        <B><A HREF="#istream::get">get</A></B>(char_type *str, streamsize count, char_type delim);
    istream&amp; <B><A HREF="#istream::get">get</A></B>(streambuf&amp; strbuf);
    istream&amp; <B><A HREF="#istream::get">get</A></B>(streambuf&amp; strbuf, char_type delim);
    istream&amp; <B><A HREF="#istream::getline">getline</A></B>(char_type *str, streamsize count);
    istream&amp; <B><A HREF="#istream::getline">getline</A></B>(char_type *str, streamsize count,
        char_type delim);
    istream&amp; <B><A HREF="#istream::ignore">ignore</A></B>(streamsize count = 1,
        int_type delim = traits_type::eof());
    int_type <B><A HREF="#istream::peek">peek</A></B>();
    istream&amp; <B><A HREF="#istream::read">read</A></B>(char_type *str, streamsize count);
    streamsize <B><A HREF="#istream::readsome">readsome</A></B>(char_type *str, streamsize count);
    istream&amp; <B><A HREF="#istream::putback">putback</A></B>(char_type ch);
    istream&amp; <B><A HREF="#istream::unget">unget</A></B>();
    pos_type <B><A HREF="#istream::tellg">tellg</A></B>();
    istream&amp; <B><A HREF="#istream::seekg">seekg</A></B>(pos_type pos);
    istream&amp; <B><A HREF="#istream::seekg">seekg</A></B>(off_type off,
        ios_base::seek_dir way);
    int <B><A HREF="#istream::sync">sync</A></B>();
    };</PRE>

<P>The class describes an object that controls
extraction of elements and encoded objects from a
<A HREF="streambu.html#stream buffer">stream buffer</A>
with elements of type <I>char,</I> also known as
<CODE><A HREF="ios.html#ios::char_type">char_type</A></CODE>, whose
<A HREF="string2.html#character traits">character traits</A> are determined by the
class <CODE><A HREF="string2.html#char_traits">char_traits</A></CODE>,
also known as
<CODE><A HREF="ios.html#ios::traits_type">traits_type</A></CODE>.</P>

<P>Most of the member functions that overload
<CODE><A HREF="#istream::operator&gt;&gt;">operator&gt;&gt;</A></CODE>
are <B><A NAME="formatted input functions">formatted input functions</A></B>.
They follow the pattern:</P>

<PRE>    iostate state = goodbit;
    const sentry ok(*this);
    if (ok)
        {try
            {&lt;extract elements and convert
            accumulate flags in state
            store a successful conversion&gt; }
        catch (...)
            {try
                {setstate(badbit); }
            catch (...)
                {}
            if ((exceptions() &amp; badbit) != 0)
                throw; }}
    setstate(state);
    return (*this);</PRE>

<P>Many other member functions are
<B><A NAME="unformatted input functions">unformatted input functions</A></B>.
They follow the pattern:</P>

<PRE>    iostate state = goodbit;
    count = 0;    // the value returned by gcount
    const sentry ok(*this, true);
    if (ok)
        {try
            {&lt;extract elements and deliver
            count extracted elements in count
            accumulate flags in state&gt; }
        catch (...)
            {try
                {setstate(badbit); }
            catch (...)
                {}
            if ((exceptions() &amp; badbit) != 0)
                throw; }}
    setstate(state);</PRE>

<P>Both groups of functions call
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(eofbit)</CODE>
if they encounter end-of-file while extracting elements.</P>

<P>An object of class <CODE>istream</CODE> stores:</P>

<UL>
<LI>a public base object of class
<B><CODE><A HREF="ios.html#ios">ios</A></CODE></B></LI>

<LI>an <B><A NAME="extraction count">extraction count</A></B>
for the last unformatted input operation (called <CODE>count</CODE>
in the code above)</LI>
</UL>

<H3><A NAME="istream::istream"><CODE>istream::istream</CODE></A></H3>

<PRE>explicit <B>istream</B>(streambuf *strbuf);</PRE>

<P>The constructor initializes the base class by calling
<CODE><A HREF="ios.html#ios::init">init</A>(strbuf)</CODE>.
It also stores zero in the
<A HREF="#extraction count">extraction count</A>.</P>

<H3><A NAME="istream::gcount"><CODE>istream::gcount</CODE></A></H3>

<PRE>streamsize <B>gcount</B>() const;</PRE>

<P>The member function returns the
<A HREF="#extraction count">extraction count</A>.</P>

<H3><A NAME="istream::get"><CODE>istream::get</CODE></A></H3>

<PRE>int_type <B><A HREF="#istream::get">get</A></B>();
istream&amp; <B>get</B>(char_type&amp; ch);
istream&amp; <B>get</B>(char_type *str, streamsize count);
istream&amp; <B>get</B>(char_type *str, streamsize count,
    char_type delim);
istream&amp; <B>get</B>(streambuf&amp; strbuf);
istream&amp; <B>get</B>(streambuf&amp; strbuf, char_type delim);</PRE>

<P>The first of these
<A HREF="#unformatted input functions">unformatted input functions</A>
extracts an element, if possible, as if by returning
<CODE>rdbuf()-&gt;<A HREF="streambu.html#streambuf::sbumpc">sbumpc</A>()</CODE>.
Otherwise, it returns
<CODE>traits_type::<A HREF="string2.html#char_traits::eof">eof</A>()</CODE>.
If the function extracts no element, it calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.</P>

<P>The second function extracts the
<A HREF="ios.html#ios::int_type"><CODE>int_type</CODE></A> element
<CODE>meta</CODE> the same way. If <CODE>meta</CODE> compares equal to
<CODE>traits_type::<A HREF="string2.html#char_traits::eof">eof</A>()</CODE>,
the function calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
Otherwise, it stores
<CODE>traits_type::<A HREF="string2.html#char_traits::to_char_type">to_char_type</A>(meta)</CODE>
in <CODE>ch</CODE>. The function returns <CODE>*this</CODE>.</P>

<P>The third function returns <CODE>get(str, count, widen('\n'))</CODE>.</P>

<P>The fourth function extracts up to <CODE>count - 1</CODE> elements
and stores them in the array beginning at <CODE>str</CODE>. It always stores
<CODE>char_type()</CODE> after
any extracted elements it stores. In order of testing, extraction stops:</P>

<OL>
<LI>at end of file</LI>

<LI>after the function extracts an element that compares equal to
<CODE>delim</CODE>, in which case the element is put back
to the controlled sequence</LI>

<LI>after the function extracts <CODE>count - 1</CODE> elements</LI>
</OL>

<P>If the function extracts no elements, it calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
In any case, it returns <CODE>*this</CODE>.</P>

<P>The fifth function returns <CODE>get(strbuf, widen('\n'))</CODE>.</P>

<P>The sixth function extracts elements and inserts them in
<CODE>strbuf</CODE>. Extraction stops on end-of-file or on an element
that compares equal to <CODE>delim</CODE> (which is not extracted).
It also stops, without extracting the element in question,
if an insertion fails or throws an exception (which is caught
but not rethrown). If the function extracts no elements, it calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
In any case, the function returns <CODE>*this</CODE>.</P>

<H3><A NAME="istream::getline"><CODE>istream::getline</CODE></A></H3>

<PRE>istream&amp; <B>getline</B>(char_type *str, streamsize count);
istream&amp; <B>getline</B>(char_type *str, streamsize count,
    char_type delim);</PRE>

<P>The first of these
<A HREF="#unformatted input functions">unformatted input functions</A>
returns <CODE>getline(str, count, widen('\n'))</CODE>.</P>

<P>The second function extracts up to <CODE>count - 1</CODE> elements
and stores them in the array beginning at <CODE>str</CODE>. It always stores
<CODE>char_type()</CODE> after
any extracted elements it stores. In order of testing, extraction stops:</P>

<OL>
<LI>at end of file</LI>

<LI>after the function extracts an element that compares equal to
<CODE>delim</CODE>, in which case the element is neither put back nor
appended to the controlled sequence</LI>

<LI>after the function extracts <CODE>count - 1</CODE> elements</LI>
</OL>

<P>If the function extracts no elements or <CODE>count - 1</CODE> elements, it calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
In any case, it returns <CODE>*this</CODE>.</P>

<H3><A NAME="istream::ignore"><CODE>istream::ignore</CODE></A></H3>

<PRE>istream&amp; <B>ignore</B>(streamsize count = 1,
    int_type delim = traits_type::eof());</PRE>

<P>The <A HREF="#unformatted input functions">unformatted input function</A>
extracts up to <CODE>count</CODE> elements and discards them.
If <CODE>count</CODE> equals
<CODE><A HREF="limits.html#INT_MAX">INT_MAX</A></CODE>,
however, it is taken as arbitrarily large.
Extraction stops early on end-of-file or
on an element <CODE>ch</CODE> such that
<CODE>traits_type::<A HREF="string2.html#char_traits::to_int_type">to_int_type</A>(ch)</CODE>
compares equal to <CODE>delim</CODE> (which is also extracted).
The function returns <CODE>*this</CODE>.</P>

<H3><A NAME="istream::operator&gt;&gt;"><CODE>istream::operator&gt;&gt;</CODE></A></H3>

<PRE>istream&amp; <B>operator&gt;&gt;</B>(
    istream&amp; (*pfn)(istream&amp;));
istream&amp; <B>operator&gt;&gt;</B>(
    ios_base&amp; (*pfn)(ios_base&amp;));
istream&amp; <B>operator&gt;&gt;</B>(
    ios&amp; (*pfn)(ios&amp;));
istream&amp; <B>operator&gt;&gt;</B>(
    streambuf *strbuf);
istream&amp; <B>operator&gt;&gt;</B>(bool&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(short&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(unsigned short&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(int&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(unsigned int&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(long&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(unsigned long&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(void *&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(float&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(double&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(long double&amp; val);</PRE>

<P>The first member function ensures that an expression of the
form <CODE>istr &gt;&gt; ws</CODE> calls
<CODE><A HREF="#ws">ws</A>(istr)</CODE>, then returns <CODE>*this</CODE>.
The second and third functions ensure that other
<A HREF="ios.html#manipulators">manipulators</A>,
such as <CODE><A HREF="ios.html#hex">hex</A></CODE> behave
similarly. The remaining functions constitute the
<A HREF="#formatted input functions">formatted input functions</A>.</P>

<P>The function:</P>

<PRE>istream&amp; <B>operator&gt;&gt;</B>(
    streambuf *strbuf);</PRE>

<P>extracts elements, if <CODE>strbuf</CODE> is not a null pointer,
and inserts them in <CODE>strbuf</CODE>. Extraction stops on end-of-file.
It also stops, without extracting the element in question,
if an insertion fails or throws an exception (which is caught
but not rethrown).
If the function extracts no elements, it calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
In any case, the function returns <CODE>*this</CODE>.</P>

<P>The function:</P>

<PRE>istream&amp; <B>operator&gt;&gt;</B>(bool&amp; val);</PRE>

<P>extracts a field and converts it to a boolean value.
The function endeavors to match a complete, nonempty
<B><A NAME="boolean input field">boolean input field</A></B>.
If successful it converts
the boolean input field to a value of type <CODE>bool</CODE>
and stores that value in <CODE>val</CODE>.</P>

<P>A boolean input field takes one of two forms.
If <CODE><A HREF="ios.html#ios_base::flags">flags</A>() &amp;
ios_base::<A HREF="ios.html#ios_base::boolalpha">boolalpha</A></CODE>
is false, it is the same as an
<A HREF="#integer input field">integer input field</A>, except that the
converted value must be either 0 (for false) or 1 (for true).
Otherwise, the sequence must match either
<CODE>false</CODE> (for false), or
<CODE>true</CODE> (for true).
The function returns <CODE>*this</CODE>.</P>


<P>The functions:</P>

<PRE>istream&amp; <B>operator&gt;&gt;</B>(short&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(unsigned short&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(int&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(unsigned int&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(long&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(unsigned long&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(void *&amp; val);</PRE>

<P>each extract a field and convert it to a numeric value.
Each function endeavors to match a complete, nonempty
<B><A NAME="integer input field">integer input field</A></B>.
If successful, it stores the result in <CODE>val</CODE>.
Otherwise, the function stores nothing in <CODE>val</CODE> and calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(ios_base::failbit)</CODE>.
If the function encounters end of file, it calls
<CODE>setstate(ios_base::eofbit)</CODE>.</P>

<P>The integer input field is converted by the same rules used by the
<A HREF="lib_scan.html#Scan Functions">scan functions</A>
for matching and converting a series of <I>char</I> elements from a file.
The equivalent
<A HREF="lib_scan.html#scan conversion specification">scan conversion
specification</A> is determined as follows:</P>

<UL>
<LI>If <CODE><A HREF="ios.html#ios_base::flags">flags</A>() &amp;
ios_base::<A HREF="ios.html#ios_base::basefield">basefield</A> ==
ios_base::<A HREF="ios.html#ios_base::oct">oct</A></CODE>, the
conversion specification is <CODE>lo</CODE>.</LI>

<LI>If <CODE>flags() &amp; ios_base::basefield ==
ios_base::<A HREF="ios.html#ios_base::hex">hex</A></CODE>, the
conversion specification is <CODE>lx</CODE>.</LI>

<LI>If <CODE>flags() &amp; ios_base::basefield == 0</CODE>, the
conversion specification is <CODE>li</CODE>.</LI>

<LI>Otherwise, the conversion specification is <CODE>ld</CODE>
if <CODE>val</CODE> has a signed type, <CODE>lu</CODE> if <CODE>val</CODE>
has an unsigned type, or <CODE>p</CODE> if <CODE>val</CODE> has type
<CODE>void *</CODE>.</LI>
</UL>

<P>If the converted value cannot
be represented as the type of <CODE>val</CODE>, the function calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
In any case, the function returns <CODE>*this</CODE>.</P>

<P>The functions:</P>

<PRE>istream&amp; <B>operator&gt;&gt;</B>(float&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(double&amp; val);
istream&amp; <B>operator&gt;&gt;</B>(long double&amp; val);</PRE>

<P>each extract a field and convert it to a numeric value.
Each function endeavors to match a complete, nonempty
A period (<CODE>.</CODE>) separates the integer digits from the
fraction digits.
The equivalent scan conversion specifier is <CODE>f</CODE>
if <CODE>val</CODE> has type <I>float,</I> <CODE>lf</CODE> if <CODE>val</CODE>
has type <I>double,</I> or <CODE>Lf</CODE> if <CODE>val</CODE> has type
<I>long double.</I></P>

<P>If the converted value cannot
be represented as the type of <CODE>val</CODE>, the function calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
In any case, it returns <CODE>*this</CODE>.</P>

<H3><A NAME="istream::peek"><CODE>istream::peek</CODE></A></H3>

<PRE>int_type <B>peek</B>();</PRE>

<P>The <A HREF="#unformatted input functions">unformatted input function</A>
extracts an element, if possible, as if by returning
<CODE>rdbuf()-&gt;<A HREF="streambu.html#streambuf::sgetc">sgetc</A>()</CODE>.
Otherwise, it returns
<CODE>traits_type::<A HREF="string2.html#char_traits::eof">eof</A>()</CODE>.</P>

<H3><A NAME="istream::putback"><CODE>istream::putback</CODE></A></H3>

<PRE>istream&amp; <B>putback</B>(char_type ch);</PRE>

<P>The <A HREF="#unformatted input functions">unformatted input function</A>
puts back <CODE>ch</CODE>, if possible, as if by calling
<CODE>rdbuf()-&gt;<A HREF="streambu.html#streambuf::sputbackc">sputbackc</A>()</CODE>.
If <CODE><A HREF="ios.html#ios::rdbuf">rdbuf</A>()</CODE>
is a null pointer, or if the call to <CODE>sputbackc</CODE> returns
<CODE>traits_type::<A HREF="string2.html#char_traits::eof">eof</A>()</CODE>,
the function calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(badbit)</CODE>.
In any case, it returns <CODE>*this</CODE>.</P>

<H3><A NAME="istream::read"><CODE>istream::read</CODE></A></H3>

<PRE>istream&amp; <B>read</B>(char_type *str, streamsize count);</PRE>

<P>The <A HREF="#unformatted input functions">unformatted input function</A>
extracts up to <CODE>count</CODE> elements
and stores them in the array beginning at <CODE>str</CODE>.
Extraction stops early on end-of-file, in which case the function calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
In any case, it returns <CODE>*this</CODE>.</P>

<H3><A NAME="istream::readsome"><CODE>istream::readsome</CODE></A></H3>

<PRE>streamsize <B>readsome</B>(char_type *str, streamsize count);</PRE>

<P>The <A HREF="#unformatted input functions">unformatted input function</A>
extracts up to <CODE>count</CODE> elements
and stores them in the array beginning at <CODE>str</CODE>.
If <CODE><A HREF="ios.html#ios::good">good</A>()</CODE> is
false, the function calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
Otherwise, it assigns the value of
<CODE>rdbuf()-&gt;<A HREF="streambu.html#streambuf::in_avail">in_avail</A>()</CODE>
to <CODE>N</CODE>. If <CODE>N &lt; 0</CODE>, the function calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(eofbit)</CODE>.
Otherwise, it replaces the value stored in <CODE>N</CODE> with
the smaller of <CODE>count</CODE> and <CODE>N</CODE>, then calls
<CODE><A HREF="#istream::read">read</A>(str, N)</CODE>.
In any case, the function returns
<CODE><A HREF="#istream::gcount">gcount</A>()</CODE>.</P>

<H3><A NAME="istream::seekg"><CODE>istream::seekg</CODE></A></H3>

<PRE>istream&amp; <B>seekg</B>(pos_type pos);
istream&amp; <B>seekg</B>(off_type off,
    ios_base::seek_dir way);</PRE>

<P>If <CODE><A HREF="ios.html#ios::fail">fail</A>()</CODE> is false,
the first member function calls
<CODE>newpos = <A HREF="ios.html#ios::rdbuf">rdbuf</A>()-&gt;
<A HREF="streambu.html#streambuf::pubseekpos">pubseekpos</A>(pos,
<A HREF="ios.html#ios_base::in">in</A>)</CODE>,
for some <CODE>pos_type</CODE> temporary object <CODE>newpos</CODE>.
If <CODE>fail()</CODE> is false, the second function calls
<CODE>newpos = rdbuf()-&gt;
<A HREF="streambu.html#streambuf::pubseekoff">pubseekoff</A>(off, way,
<A HREF="ios.html#ios_base::in">in</A>)</CODE>.
In either case, if <CODE>(off_type)newpos == (off_type)(-1)</CODE>
(the positioning operation fails) the function calls
<CODE>istr.<A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
Both functions return <CODE>*this</CODE>.</P>

<H3><A NAME="istream::sentry"><CODE>istream::sentry</CODE></A></H3>

<PRE>class <B>sentry</B> {
public:
    explicit <B>sentry</B>(istream&lt;Elem, Tr&gt;&amp; istr,
        bool noskip = false);
    <B>operator bool</B>() const;
    };</PRE>

<P>The nested class describes an object whose declaration structures the
<A HREF="#formatted input functions">formatted input functions</A> and the
<A HREF="#unformatted input functions">unformatted input functions</A>.
If <CODE>istr.<A HREF="ios.html#ios::good">good</A>()</CODE>
is true, the constructor:</P>

<UL>
<LI>calls <CODE>istr.<A HREF="ios.html#ios::tie">tie</A>-&gt;
<A HREF="ostream.html#ostream::flush">flush</A>()</CODE>
if <CODE>istr.tie()</CODE> is not a null pointer</LI>

<LI>effectively calls <CODE><A HREF="#ws">ws</A>(istr)</CODE> if
<CODE>istr.<A HREF="ios.html#ios_base::flags">flags</A>() &amp;
<A HREF="ios.html#ios_base::skipws">skipws</A></CODE> is nonzero</LI>
</UL>

<P>If, after any such preparation,
<CODE>istr.good()</CODE> is false, the constructor calls
<CODE>istr.<A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
In any case, the constructor stores the value returned by <CODE>istr.good()</CODE>
in <B>status</B>.
A later call to <CODE>operator bool()</CODE> delivers this stored value.</P>

<H3><A NAME="istream::sync"><CODE>istream::sync</CODE></A></H3>

<PRE>int <B>sync</B>();</PRE>

<P>If <CODE><A HREF="ios.html#ios::rdbuf">rdbuf</A>()</CODE> is
a null pointer, the function returns -1. Otherwise, it calls
<CODE>rdbuf()-&gt;<A HREF="streambu.html#streambuf::pubsync">pubsync</A>()</CODE>.
If that returns -1, the function calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(badbit)</CODE>
and returns -1. Otherwise, the function returns zero.</P>

<H3><A NAME="istream::tellg"><CODE>istream::tellg</CODE></A></H3>

<PRE>pos_type <B>tellg</B>();</PRE>

<P>If <CODE><A HREF="ios.html#ios::fail">fail</A>()</CODE> is false,
the member function returns
<CODE><A HREF="ios.html#ios::rdbuf">rdbuf</A>()-&gt;
<A HREF="streambu.html#streambuf::pubseekoff">pubseekoff</A>(0,
<A HREF="ios.html#ios_base::cur">cur</A>,
<A HREF="ios.html#ios_base::in">in</A>)</CODE>.
Otherwise, it returns <CODE>pos_type(-1)</CODE>.</P>

<H3><A NAME="istream::unget"><CODE>istream::unget</CODE></A></H3>

<PRE>istream&amp; <B>unget</B>();</PRE>

<P>The <A HREF="#unformatted input functions">unformatted input function</A>
puts back the previous element in the stream, if possible, as if by calling
<CODE>rdbuf()-&gt;<A HREF="streambu.html#streambuf::sungetc">sungetc</A>()</CODE>.
If <CODE><A HREF="ios.html#ios::rdbuf">rdbuf</A>()</CODE>
is a null pointer, or if the call to <CODE>sungetc</CODE> returns
<CODE>traits_type::<A HREF="string2.html#char_traits::eof">eof</A>()</CODE>,
the function calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(badbit)</CODE>.
In any case, it returns <CODE>*this</CODE>.</P>


<H2><A NAME="operator&gt;&gt;"><CODE>operator&gt;&gt;</CODE></A></H2>

<PRE>istream&amp;
    <B>operator&gt;&gt;</B>(istream&amp; istr, char *str);
istream&amp;
    <B>operator&gt;&gt;</B>(istream&amp; istr, char&amp; ch);
istream&amp;
    <B>operator&gt;&gt;</B>(istream&amp; istr, signed char *str);
istream&amp;
    <B>operator&gt;&gt;</B>(istream&amp; istr, signed char&amp; ch);
istream&amp;
    <B>operator&gt;&gt;</B>(istream&amp; istr, unsigned char *str);
istream&amp;
    <B>operator&gt;&gt;</B>(istream istr, unsigned char&amp; ch);</PRE>

<P>All of these functions are
<A HREF="#formatted input functions">formatted input functions</A>.
The function:</P>

<PRE>istream&amp;
    <B>operator&gt;&gt;</B>(istream&amp; istr, char *str);</PRE>

<P>extracts up to <CODE>N - 1</CODE> elements
and stores them in the array beginning at <CODE>str</CODE>.
If <CODE>istr.<A HREF="ios.html#ios_base::width">width</A>()</CODE> is greater
than zero, <CODE>N</CODE> is <CODE>istr.width()</CODE>; otherwise it is
the size of
the largest array of <I>char</I> that can be declared.
The function always stores
<CODE>char(0)</CODE> after
any extracted elements it stores. Extraction stops early on end-of-file,
on a character with value <CODE>char(0)</CODE> (which is not extracted),
or on any element (which is not extracted) that would be discarded by
<CODE><A HREF="#ws">ws</A></CODE>.
If the function extracts no elements, it calls
<CODE>istr.<A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
In any case, it calls <CODE>istr.width(0)</CODE> and
returns <CODE>istr</CODE>.</P>

<P>The function:</P>

<PRE>istream&amp;
    <B>operator&gt;&gt;</B>(istream&amp; istr, char&amp; ch);</PRE>

<P>extracts an element, if possible, and stores it in <CODE>ch</CODE>.
Otherwise, it calls
<CODE>is.<A HREF="ios.html#ios::setstate">setstate</A>(failbit)</CODE>.
In any case, it returns <CODE>istr</CODE>.</P>

<P>The function:</P>

<PRE>istream&amp;
    <B>operator&gt;&gt;</B>(istream&amp; istr, signed char *str);</PRE>

<P>returns <CODE>istr &gt;&gt; (char *)str</CODE>.</P>

<P>The function:</P>

<PRE>istream&amp;
    <B>operator&gt;&gt;</B>(istream&amp; istr, signed char&amp; ch);</PRE>

<P>returns <CODE>istr &gt;&gt; (char&amp;)ch</CODE>.</P>

<P>The function:</P>

<PRE>istream&amp;
    <B>operator&gt;&gt;</B>(istream&amp; istr, unsigned char *str);</PRE>

<P>returns <CODE>istr &gt;&gt; (char *)str</CODE>.</P>

<P>The function:</P>

<PRE>istream&amp;
    <B>operator&gt;&gt;</B>(istream&amp; istr, unsigned char&amp; ch);</PRE>

<P>returns <CODE>istr &gt;&gt; (char&amp;)ch</CODE>.</P>


<H2><A NAME="ws"><CODE>ws</CODE></A></H2>

<PRE>istream&amp; <B>ws</B>(istream&amp; istr);</PRE>

<P>The manipulator extracts and discards any elements
<CODE>ch</CODE> for which
<CODE><A HREF="ctype.html#isspace">isspace</A>(ch)</CODE>
is true.</P>

<P>The function calls
<CODE><A HREF="ios.html#ios::setstate">setstate</A>(eofbit)</CODE>
if it encounters end-of-file while extracting elements.
It returns <CODE>istr</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2002
by P.J. Plauger. All rights reserved.</I></P>

<!--V4.02:1476--></BODY></HTML>
