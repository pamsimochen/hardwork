<HTML><HEAD><TITLE>&lt;complex&gt;</TITLE></HEAD><BODY>

<H1><A NAME="&lt;complex&gt;"><CODE>&lt;complex&gt;</CODE></A></H1><HR>

<P><B><CODE><A HREF="#abs">abs</A>
&#183; <A HREF="#arg">arg</A>
&#183; <A HREF="#complex">complex</A>
&#183; <A HREF="#conj">conj</A>
&#183; <A HREF="#cos">cos</A>
&#183; <A HREF="#cosh">cosh</A>
&#183; <A HREF="#double_complex">double_complex</A>
&#183; <A HREF="#exp">exp</A>
&#183; <A HREF="#float_complex">float_complex</A>
&#183; <A HREF="#imag">imag</A>
&#183; <A HREF="#log">log</A>
&#183; <A HREF="#log10">log10</A>
&#183; <A HREF="#norm">norm</A>
&#183; <A HREF="#operator!=">operator!=</A>
&#183; <A HREF="#operator*">operator*</A>
&#183; <A HREF="#operator+">operator+</A>
&#183; <A HREF="#operator-">operator-</A>
&#183; <A HREF="#operator/">operator/</A>
&#183; <A HREF="#operator&lt;&lt;">operator&lt;&lt;</A>
&#183; <A HREF="#operator==">operator==</A>
&#183; <A HREF="#operator&gt;&gt;">operator&gt;&gt;</A>
&#183; <A HREF="#polar">polar</A>
&#183; <A HREF="#pow">pow</A>
&#183; <A HREF="#real">real</A>
&#183; <A HREF="#sin">sin</A>
&#183; <A HREF="#sinh">sinh</A>
&#183; <A HREF="#sqrt">sqrt</A>
&#183; <A HREF="#tan">tan</A>
&#183; <A HREF="#tanh">tanh</A>
&#183; <A HREF="#__STD_COMPLEX">__STD_COMPLEX</A>
</CODE></B></P>
<HR>

<P>Include the standard header <B><CODE>&lt;complex&gt;</CODE></B>
to define classes <CODE>double_complex</CODE> and <CODE>float_complex</CODE> and a host of
supporting functions.
Unless otherwise specified,
functions that can return multiple values return an imaginary
part in the half-open interval <CODE>(-pi, pi]</CODE>.</P>

<PRE>        // DECLARATIONS
#define <B><A HREF="#__STD_COMPLEX">__STD_COMPLEX</A></B>

        // CLASSES
class double_complex;
class float_complex;

        // double_complex FUNCTIONS
double_complex <B><A HREF="#operator+">operator+</A></B>(const double_complex&amp; left,
    const double_complex&amp; right);
double_complex <B><A HREF="#operator+">operator+</A></B>(const double_complex&amp; left,
    const double&amp; right);
double_complex <B><A HREF="#operator+">operator+</A></B>(const double&amp; left,
    const double_complex&amp; right);
double_complex <B><A HREF="#operator-">operator-</A></B>(const double_complex&amp; left,
    const double_complex&amp; right);
double_complex <B><A HREF="#operator-">operator-</A></B>(const double_complex&amp; left,
    const double&amp; right);
double_complex <B><A HREF="#operator-">operator-</A></B>(const double&amp; left,
    const double_complex&amp; right);
double_complex <B><A HREF="#operator*">operator*</A></B>(const double_complex&amp; left,
    const double_complex&amp; right);
double_complex <B><A HREF="#operator*">operator*</A></B>(const double_complex&amp; left,
    const double&amp; right);
double_complex <B><A HREF="#operator*">operator*</A></B>(const double&amp; left,
    const double_complex&amp; right);
double_complex <B><A HREF="#operator/">operator/</A></B>(const double_complex&amp; left,
    const double_complex&amp; right);
double_complex <B><A HREF="#operator/">operator/</A></B>(const double_complex&amp; left,
    const double&amp; right);
double_complex <B><A HREF="#operator/">operator/</A></B>(const double&amp; left,
    const double_complex&amp; right);
double_complex <B><A HREF="#operator+">operator+</A></B>(const double_complex&amp; left);
double_complex <B><A HREF="#operator-">operator-</A></B>(const double_complex&amp; left);
bool <B><A HREF="#operator==">operator==</A></B>(const double_complex&amp; left,
    const double_complex&amp; right);
bool <B><A HREF="#operator==">operator==</A></B>(const double_complex&amp; left,
    const double&amp; right);
bool <B><A HREF="#operator==">operator==</A></B>(const double&amp; left,
    const double_complex&amp; right);
bool <B><A HREF="#operator!=">operator!=</A></B>(const double_complex&amp; left,
    const double_complex&amp; right);
bool <B><A HREF="#operator!=">operator!=</A></B>(const double_complex&amp; left,
    const double&amp; right);
bool <B><A HREF="#operator!=">operator!=</A></B>(const double&amp; left,
    const double_complex&amp; right);
istream&amp; <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(istream&amp; istr, double_complex&amp; right);
ostream&amp; <B><A HREF="#operator&lt;&lt;">operator&lt;&lt;</A></B>(ostream&amp; ostr, const double_complex&amp; right);
double <B><A HREF="#real">real</A></B>(const double_complex&amp; left);
double <B><A HREF="#imag">imag</A></B>(const double_complex&amp; left);
double <B><A HREF="#abs">abs</A></B>(const double_complex&amp; left);
double <B><A HREF="#arg">arg</A></B>(const double_complex&amp; left);
double <B><A HREF="#norm">norm</A></B>(const double_complex&amp; left);
double_complex <B><A HREF="#conj">conj</A></B>(const double_complex&amp; left);
double_complex <B><A HREF="#polar">polar</A></B>(const double&amp; rho,
    const double&amp; theta = 0);
double_complex <B><A HREF="#cos">cos</A></B>(const double_complex&amp; left);
double_complex <B><A HREF="#cosh">cosh</A></B>(const double_complex&amp; left);
double_complex <B><A HREF="#exp">exp</A></B>(const double_complex&amp; left);
double_complex <B><A HREF="#log">log</A></B>(const double_complex&amp; left);
double_complex <B><A HREF="#log10">log10</A></B>(const double_complex&amp; left);
double_complex <B><A HREF="#pow">pow</A></B>(const double_complex&amp; left, int right);
double_complex <B><A HREF="#pow">pow</A></B>(const double_complex&amp; left,
    const double&amp; right);
double_complex <B><A HREF="#pow">pow</A></B>(const double_complex&amp; left,
    const double_complex&amp; right);
double_complex <B><A HREF="#pow">pow</A></B>(const double&amp; left,
    const double_complex&amp; right);
double_complex <B><A HREF="#sin">sin</A></B>(const double_complex&amp; left);
double_complex <B><A HREF="#sinh">sinh</A></B>(const double_complex&amp; left);
double_complex <B><A HREF="#sqrt">sqrt</A></B>(const double_complex&amp; left);

        // float_complex FUNCTIONS
bool <B><A HREF="#operator==">operator==</A></B>(const float&amp; left,
    const float_complex&amp; right);
bool <B><A HREF="#operator!=">operator!=</A></B>(const float_complex&amp; left,
    const float_complex&amp; right);
bool <B><A HREF="#operator!=">operator!=</A></B>(const float_complex&amp; left,
    const float&amp; right);
bool <B><A HREF="#operator!=">operator!=</A></B>(const float&amp; left,
    const float_complex&amp; right);
istream&amp; <B><A HREF="#operator&gt;&gt;">operator&gt;&gt;</A></B>(istream&amp; istr, float_complex&amp; right);
ostream&amp; <B><A HREF="#operator&lt;&lt;">operator&lt;&lt;</A></B>(ostream&amp; ostr, const float_complex&amp; right);
float <B><A HREF="#real">real</A></B>(const float_complex&amp; left);
float <B><A HREF="#imag">imag</A></B>(const float_complex&amp; left);
float <B><A HREF="#abs">abs</A></B>(const float_complex&amp; left);
float <B><A HREF="#arg">arg</A></B>(const float_complex&amp; left);
float <B><A HREF="#norm">norm</A></B>(const float_complex&amp; left);
float_complex <B><A HREF="#conj">conj</A></B>(const float_complex&amp; left);
float_complex <B><A HREF="#polar">polar</A></B>(const float&amp; rho,
    const float&amp; theta = 0);
float_complex <B><A HREF="#cos">cos</A></B>(const float_complex&amp; left);
float_complex <B><A HREF="#cosh">cosh</A></B>(const float_complex&amp; left);
float_complex <B><A HREF="#exp">exp</A></B>(const float_complex&amp; left);
float_complex <B><A HREF="#log">log</A></B>(const float_complex&amp; left);
float_complex <B><A HREF="#log10">log10</A></B>(const float_complex&amp; left);
float_complex <B><A HREF="#pow">pow</A></B>(const float_complex&amp; left, int right);
float_complex <B><A HREF="#pow">pow</A></B>(const float_complex&amp; left,
    const float&amp; right);
float_complex <B><A HREF="#pow">pow</A></B>(const float_complex&amp; left,
    const float_complex&amp; right);
float_complex <B><A HREF="#pow">pow</A></B>(const float&amp; left,
    const float_complex&amp; right);
float_complex <B><A HREF="#sin">sin</A></B>(const float_complex&amp; left);
float_complex <B><A HREF="#sinh">sinh</A></B>(const float_complex&amp; left);
float_complex <B><A HREF="#sqrt">sqrt</A></B>(const float_complex&amp; left);
        // END OF DECLARATIONS</PRE>

<H2><A NAME="abs"><CODE>abs</CODE></A></H2>

<PRE>double <B>abs</B>(const double_complex&amp; left);
float <B>abs</B>(const float_complex&amp; left);</PRE>

<P>The function returns the magnitude of <CODE>left</CODE>.</P>

<H2><A NAME="arg"><CODE>arg</CODE></A></H2>

<PRE>double <B>arg</B>(const double_complex&amp; left);
float <B>arg</B>(const float_complex&amp; left);</PRE>

<P>The function returns the phase angle of <CODE>left</CODE>.</P>

<H2><A NAME="complex"><CODE>complex</CODE></A></H2>

<PRE>template&lt;class Ty&gt;
    class <B>complex</B> {
public:
    typedef Ty <B><A HREF="#complex::value_type">value_type</A></B>;
    Ty <B><A HREF="#complex::real">real</A></B>() const;
    Ty <B><A HREF="#complex::imag">imag</A></B>() const;
    <B><A HREF="#complex::complex">complex</A></B>(const Ty&amp; realval = 0, const Ty&amp; imagval = 0);
    <B><A HREF="#complex::complex">complex</A></B>(const complex&amp; right);
    complex&amp; <B><A HREF="#complex::operator=">operator=</A></B>(const complex&amp; right);
    complex&amp; <B><A HREF="#complex::operator+=">operator+=</A></B>(const complex&amp; right);
    complex&amp; <B><A HREF="#complex::operator-=">operator-=</A></B>(const complex&amp; right);
    complex&amp; <B><A HREF="#complex::operator*=">operator*=</A></B>(const complex&amp; right);
    complex&amp; <B><A HREF="#complex::operator/=">operator/=</A></B>(const complex&amp; right);
    complex&amp; <B><A HREF="#complex::operator=">operator=</A></B>(const Ty&amp; right);
    complex&amp; <B><A HREF="#complex::operator=">operator=</A></B>(const Ty&amp; right);
    complex&amp; <B><A HREF="#complex::operator+=">operator+=</A></B>(const Ty&amp; right);
    complex&amp; <B><A HREF="#complex::operator-=">operator-=</A></B>(const Ty&amp; right);
    complex&amp; <B><A HREF="#complex::operator*=">operator*=</A></B>(const Ty&amp; right);
    complex&amp; <B><A HREF="#complex::operator/=">operator/=</A></B>(const Ty&amp; right);
    };</PRE>

<P>The template class doesn't really exist. It is a convenient fiction
for describing the behavior common to the two types:</P>

<UL>
<LI><CODE><A HREF="#double_complex">double_complex</A></CODE> --
which behaves like <CODE>complex&lt;double&gt;</CODE></LI>

<LI><CODE><A HREF="#float_complex">float_complex</A></CODE> --
which behaves like <CODE>complex&lt;float&gt;</CODE></LI>
</UL>

<P>The template class describes an object that stores two objects
of type <B><CODE>Ty</CODE></B>, one that represents the real part
of a complex number and one that represents the imaginary part.</P>

<H3><A NAME="complex::complex"><CODE>complex::complex</CODE></A></H3>

<PRE><B>complex</B>(const Ty&amp; realval = 0, const Ty&amp; imagval = 0);
<B>complex</B>(const complex&amp; right);</PRE>

<P>The first constructor initializes the stored real part to
<CODE>realval</CODE> and the stored imaginary part to <CODE>imagval</CODE>.
The second constructor initializes the stored real part to
<CODE>right.real()</CODE> and the stored imaginary part to
<CODE>right.imag()</CODE>.</P>


<H3><A NAME="complex::imag"><CODE>complex::imag</CODE></A></H3>

<PRE>Ty <B>imag</B>() const;</PRE>

<P>The member function returns the stored imaginary part.</P>

<H3><A NAME="complex::operator*="><CODE>complex::operator*=</CODE></A></H3>

<PRE>complex&amp; <B>operator*=</B>(const complex&amp; right);
complex&amp; <B>operator*=</B>(const Ty&amp; right);</PRE>

<P>The first member function replaces the stored real and imaginary parts
with those corresponding to the complex product of <CODE>*this</CODE>
and <CODE>right</CODE>. It then returns <CODE>*this</CODE>.</P>

<P>The second member function multiplies both the stored real part
and the stored imaginary part with <CODE>right</CODE>.
It then returns <CODE>*this</CODE>.</P>


<H3><A NAME="complex::operator+="><CODE>complex::operator+=</CODE></A></H3>

<PRE>complex&amp; <B>operator+=</B>(const complex&amp; right);
complex&amp; <B>operator+=</B>(const Ty&amp; right);</PRE>

<P>The first member function replaces the stored real and imaginary parts
with those corresponding to the complex sum of <CODE>*this</CODE>
and <CODE>right</CODE>. It then returns <CODE>*this</CODE>.</P>

<P>The second member function adds <CODE>right</CODE> to the stored real part.
It then returns <CODE>*this</CODE>.</P>


<H3><A NAME="complex::operator-="><CODE>complex::operator-=</CODE></A></H3>

<PRE>complex&amp; <B>operator-=</B>(const complex&amp; right);
complex&amp; <B>operator-=</B>(const Ty&amp; right);</PRE>

<P>The first member function replaces the stored real and imaginary parts
with those corresponding to the complex difference of <CODE>*this</CODE>
and <CODE>right</CODE>. It then returns <CODE>*this</CODE>.</P>

<P>The second member function subtracts <CODE>right</CODE> from
the stored real part. It then returns <CODE>*this</CODE>.</P>


<H3><A NAME="complex::operator/="><CODE>complex::operator/=</CODE></A></H3>

<PRE>complex&amp; <B>operator/=</B>(const complex&amp; right);
complex&amp; <B>operator/=</B>(const Ty&amp; right);</PRE>

<P>The first member function replaces the stored real and imaginary parts
with those corresponding to the complex quotient of <CODE>*this</CODE>
and <CODE>right</CODE>. It then returns <CODE>*this</CODE>.</P>

<P>The second member function multiplies both the stored real part
and the stored imaginary part with <CODE>right</CODE>.
It then returns <CODE>*this</CODE>.</P>


<H3><A NAME="complex::operator="><CODE>complex::operator=</CODE></A></H3>

<PRE>complex&amp; <B>operator=</B>(const complex&amp; right);
complex&amp; <B>operator=</B>(const Ty&amp; right);</PRE>

<P>The first member function replaces the stored real part with
<CODE>right.real()</CODE> and the stored imaginary part
with <CODE>right.imag()</CODE>. It then returns <CODE>*this</CODE>.</P>

<P>The second member function replaces the stored real part with
<CODE>right</CODE> and the stored imaginary part
with zero. It then returns <CODE>*this</CODE>.</P>


<H3><A NAME="complex::real"><CODE>complex::real</CODE></A></H3>

<PRE>Ty <B>real</B>() const;</PRE>

<P>The member function returns the stored real part.</P>

<H3><A NAME="complex::value_type"><CODE>complex::value_type</CODE></A></H3>

<PRE>typedef Ty <B>value_type</B>;</PRE>

<P>The type is a synonym for the template parameter <CODE>Ty</CODE>.</P>


<H2><A NAME="conj"><CODE>conj</CODE></A></H2>

<PRE>double_complex <B>conj</B>(const double_complex&amp; left);
float_complex <B>conj</B>(const float_complex&amp; left);</PRE>

<P>The function returns the conjugate of <CODE>left</CODE>.</P>

<H2><A NAME="cos"><CODE>cos</CODE></A></H2>

<PRE>double_complex <B>cos</B>(const double_complex&amp; left);
float_complex <B>cos</B>(const float_complex&amp; left);</PRE>

<P>The function returns the cosine of <CODE>left</CODE>.</P>

<H2><A NAME="cosh"><CODE>cosh</CODE></A></H2>

<PRE>double_complex <B>cosh</B>(const double_complex&amp; left);
float_complex <B>cosh</B>(const float_complex&amp; left);</PRE>

<P>The function returns the hyperbolic cosine of <CODE>left</CODE>.</P>

<H2><A NAME="double_complex"><CODE>double_complex</CODE></A></H2>

<PRE>class <B>double_complex</B> : public complex&lt;double&gt; {
public:
    <B>double_complex</B>(double realval = 0, double imagval = 0);
    <B>double_complex</B>(const float_complex&amp; right);
    double_complex&amp; <B>operator=</B>(const double right);
    };</PRE>

<P>The class describes an object that stores two objects
of type <I>double,</I> one that represents the real part
of a complex number and one that represents the imaginary part.
The class differs from its fictitious base class
<CODE><A HREF="#complex">complex</A>&lt;double&gt;</CODE>
only in the constructors it defines.
The first constructor initializes the stored real part to
<CODE>realval</CODE> and the stored imaginary part to <CODE>imagval</CODE>.
The second constructor initializes the stored real part to
<CODE>right.real()</CODE> and the stored imaginary part to
<CODE>right.imag()</CODE>.
The assignment operator stores <CODE>right</CODE> in the stored real part
and zero in the stored imaginary part.</P>

<H2><A NAME="exp"><CODE>exp</CODE></A></H2>

<PRE>double_complex <B>exp</B>(const double_complex&amp; left);
float_complex <B>exp</B>(const float_complex&amp; left);</PRE>

<P>The function returns the exponential of <CODE>left</CODE>.</P>

<H2><A NAME="float_complex"><CODE>float_complex</CODE></A></H2>

<PRE>class <B>float_complex</B> : public complex&lt;float&gt; {
public:
    <B>float_complex</B>(float realval = 0, float imagval = 0);
    explicit <B>float_complex</B>(const double_complex&amp; right);
    float_complex&amp; <B>operator=</B>(const float right);
    };</PRE>

<P>The class describes an object that stores two objects
of type <I>float,</I> one that represents the real part
of a complex number and one that represents the imaginary part.
The class differs from its fictitious base class
<CODE><A HREF="#complex">complex</A>&lt;float&gt;</CODE>
only in the constructors it defines.
The first constructor initializes the stored real part to
<CODE>realval</CODE> and the stored imaginary part to <CODE>imagval</CODE>.
The second constructor initializes the stored real part to
<CODE>right.real()</CODE> and the stored imaginary part to
<CODE>right.imag()</CODE>.
The assignment operator stores <CODE>right</CODE> in the stored real part
and zero in the stored imaginary part.</P>

<H2><A NAME="imag"><CODE>imag</CODE></A></H2>

<PRE>double <B>imag</B>(const double_complex&amp; left);
float <B>imag</B>(const float_complex&amp; left);</PRE>

<P>The function returns the imaginary part of <CODE>left</CODE>.</P>

<H2><A NAME="log"><CODE>log</CODE></A></H2>

<PRE>double_complex <B>log</B>(const double_complex&amp; left);
float_complex <B>log</B>(const float_complex&amp; left);</PRE>

<P>The function returns the logarithm of <CODE>left</CODE>.
The branch cuts are along the negative real axis.</P>

<H2><A NAME="log10"><CODE>log10</CODE></A></H2>

<PRE>double_complex <B>log10</B>(const double_complex&amp; left);
float_complex <B>log10</B>(const float_complex&amp; left);</PRE>

<P>The function returns the base 10
logarithm of <CODE>left</CODE>.
The branch cuts are along the negative real axis.</P>

<H2><A NAME="norm"><CODE>norm</CODE></A></H2>

<PRE>double <B>norm</B>(const double_complex&amp; left);
float <B>norm</B>(const float_complex&amp; left);</PRE>

<P>The function returns the squared magnitude of <CODE>left</CODE>.</P>

<H2><A NAME="operator!="><CODE>operator!=</CODE></A></H2>

<PRE>bool <B>operator!=</B>(const double_complex&amp; left,
    const double_complex&amp; right);
bool <B>operator!=</B>(const double_complex&amp; left,
    const double&amp; right);
bool <B>operator!=</B>(const double&amp; left,
    const double_complex&amp; right);
bool <B>operator!=</B>(const float_complex&amp; left,
    const float_complex&amp; right);
bool <B>operator!=</B>(const float_complex&amp; left,
    const float&amp; right);
bool <B>operator!=</B>(const float&amp; left,
    const float_complex&amp; right);</PRE>

<P>The operators each return true only if
<CODE><A HREF="#real">real</A>(left) != real(right) ||
<A HREF="#imag">imag</A>(left) != imag(right)</CODE>.</P>

<H2><A NAME="operator*"><CODE>operator*</CODE></A></H2>

<PRE>double_complex <B>operator*</B>(const double_complex&amp; left,
    const double_complex;&amp; right);
double_complex <B>operator*</B>(const double_complex&amp; left,
    const double&amp; right);
double_complex <B>operator*</B>(const double&amp; left,
    const double_complex&amp; right);
float_complex <B>operator*</B>(const float_complex&amp; left,
    const float_complex;&amp; right);
float_complex <B>operator*</B>(const float_complex&amp; left,
    const float&amp; right);
float_complex <B>operator*</B>(const float&amp; left,
    const float_complex&amp; right);</PRE>

<P>The operators each convert both operands to the return type,
then return the complex product
of the converted <CODE>left</CODE> and <CODE>right</CODE>.</P>

<H2><A NAME="operator+"><CODE>operator+</CODE></A></H2>

<PRE>double_complex <B>operator+</B>(const double_complex&amp; left,
    const double_complex;&amp; right);
double_complex <B>operator+</B>(const double_complex&amp; left,
    const double&amp; right);
double_complex <B>operator+</B>(const double&amp; left,
    const double_complex&amp; right);
double_complex <B>operator+</B>(const double_complex&amp; left);
float_complex <B>operator+</B>(const float_complex&amp; left,
    const float_complex;&amp; right);
float_complex <B>operator+</B>(const float_complex&amp; left,
    const float&amp; right);
float_complex <B>operator+</B>(const float&amp; left,
    const float_complex&amp; right);
float_complex <B>operator+</B>(const float_complex&amp; left);</PRE>

<P>The binary operators each convert both operands to the return type,
then return the complex sum
of the converted <CODE>left</CODE> and <CODE>right</CODE>.</P>

<P>The unary operator returns <CODE>left</CODE>.</P>

<H2><A NAME="operator-"><CODE>operator-</CODE></A></H2>

<PRE>double_complex <B>operator-</B>(const double_complex&amp; left,
    const double_complex;&amp; right);
double_complex <B>operator-</B>(const double_complex&amp; left,
    const double&amp; right);
double_complex <B>operator-</B>(const double&amp; left,
    const double_complex&amp; right);
double_complex <B>operator-</B>(const double_complex&amp; left);
float_complex <B>operator-</B>(const float_complex&amp; left,
    const float_complex;&amp; right);
float_complex <B>operator-</B>(const float_complex&amp; left,
    const float&amp; right);
float_complex <B>operator-</B>(const float&amp; left,
    const float_complex&amp; right);
float_complex <B>operator-</B>(const float_complex&amp; left);</PRE>

<P>The binary operators each convert both operands to the return type,
then return the complex difference
of the converted <CODE>left</CODE> and <CODE>right</CODE>.</P>

<P>The unary operator returns a value whose real part is
<CODE>-<A HREF="#real">real</A>(left)</CODE> and whose imaginary part is
<CODE>-<A HREF="#imag">imag</A>(left)</CODE>.</P>

<H2><A NAME="operator/"><CODE>operator/</CODE></A></H2>

<PRE>double_complex <B>operator/</B>(const double_complex&amp; left,
    const double_complex;&amp; right);
double_complex <B>operator/</B>(const double_complex&amp; left,
    const double&amp; right);
double_complex <B>operator/</B>(const double&amp; left,
    const double_complex&amp; right);
float_complex <B>operator/</B>(const float_complex&amp; left,
    const float_complex;&amp; right);
float_complex <B>operator/</B>(const float_complex&amp; left,
    const float&amp; right);
float_complex <B>operator/</B>(const float&amp; left,
    const float_complex&amp; right);</PRE>

<P>The operators each convert both operands to the return type,
then return the complex quotient
of the converted <CODE>left</CODE> and <CODE>right</CODE>.</P>

<H2><A NAME="operator&lt;&lt;"><CODE>operator&lt;&lt;</CODE></A></H2>

<PRE>ostream&amp; <B><A HREF="#operator&lt;&lt;">operator&lt;&lt;</A></B>(ostream&amp; ostr,
    const double_complex&amp; right);
ostream&amp; <B><A HREF="#operator&lt;&lt;">operator&lt;&lt;</A></B>(ostream&amp; ostr,
    const float_complex&amp; right);</PRE>

<P>The template function inserts the complex value <CODE>right</CODE>
in the output stream <CODE>ostr</CODE>, effectively by executing:</P>

<PRE>ostringstream osstr;
osstr.flags(ostr.flags());
osstr.precision(ostr.precision());
osstr &lt;&lt; '(' &lt;&lt; real(right) &lt;&lt; ','
    &lt;&lt; imag(right) &lt;&lt; ')';
ostr &lt;&lt; osstr.str().c_str();</PRE>

<P>Thus, if
<CODE>ostr.<A HREF="ios.html#ios_base::width">width</A>()</CODE> is
greater than zero, any padding occurs either before or after the
parenthesized pair of values, which itself contains no padding.
The function returns <CODE>ostr</CODE>.</P>

<H2><A NAME="operator=="><CODE>operator==</CODE></A></H2>

<PRE>bool <B>operator==</B>(const double_complex&amp; left,
    const double_complex&amp; right);
bool <B>operator==</B>(const double_complex&amp; left,
    const double&amp; right);
bool <B>operator==</B>(const double&amp; left,
    const double_complex&amp; right);
bool <B>operator==</B>(const float_complex&amp; left,
    const float_complex&amp; right);
bool <B>operator==</B>(const float_complex&amp; left,
    const float&amp; right);
bool <B>operator==</B>(const float&amp; left,
    const float_complex&amp; right);</PRE>

<P>The operators each return true only if
<CODE><A HREF="#real">real</A>(left) == real(right) &amp;&amp;
<A HREF="#imag">imag</A>(left) == imag(right)</CODE>.</P>

<H2><A NAME="operator&gt;&gt;"><CODE>operator&gt;&gt;</CODE></A></H2>

<PRE>istream&amp; <B>operator&gt;&gt;</B>(istream&amp; istr,
    double_complex&amp; right);
istream&amp; <B>operator&gt;&gt;</B>(istream&amp; istr,
    float_complex&amp; right);</PRE>

<P>The template function attempts to extract a complex value
from the input stream <CODE>istr</CODE>, effectively by executing:</P>

<PRE>istr &gt;&gt; ch &amp;&amp; ch == '('
    &amp;&amp; istr &gt;&gt; re &gt;&gt; ch &amp;&amp; ch == ','
    &amp;&amp; istr &gt;&gt; im &gt;&gt; ch &amp;&amp; ch == ')'</PRE>

<P>Here, <CODE>ch</CODE> is an object of type <I>char,</I>
and <CODE>re</CODE> and <CODE>im</CODE> are objects of the same type
as <CODE>right.real()</CODE>.</P>

<P>If the result of this expression is true, the function stores
<CODE>re</CODE> in the real part and <CODE>im</CODE> in the
imaginary part of <CODE>right</CODE>. In any event, the function
returns <CODE>istr</CODE>.</P>

<H2><A NAME="polar"><CODE>polar</CODE></A></H2>

<PRE>double_complex <B>polar</B>(const double&amp; rho,
    const double&amp; theta = 0);
float_complex <B>polar</B>(const float&amp; rho,
    const float&amp; theta);</PRE>

<P>The function returns the complex value whose magnitude
is <CODE>rho</CODE> and whose phase angle is <CODE>theta</CODE>.</P>

<H2><A NAME="pow"><CODE>pow</CODE></A></H2>

<PRE>double_complex <B>pow</B>(const double_complex&amp; left, int right);
double_complex <B>pow</B>(const double_complex&amp; left, const Ty&amp; right);
double_complex <B>pow</B>(const double_complex&amp; left,
    const double_complex&amp; right);
double_complex <B>pow</B>(const Ty&amp; left, const double_complex&amp; right);
float_complex <B>pow</B>(const float_complex&amp; left, int right);
float_complex <B>pow</B>(const float_complex&amp; left, const Ty&amp; right);
float_complex <B>pow</B>(const float_complex&amp; left,
    const float_complex&amp; right);
float_complex <B>pow</B>(const Ty&amp; left, const float_complex&amp; right);</PRE>

<P>The functions each effectively convert both operands to
the return type, then return the converted
<CODE>left</CODE> to the power <CODE>right</CODE>.
The branch cut for <CODE>left</CODE> is along the negative real axis.</P>

<H2><A NAME="real"><CODE>real</CODE></A></H2>

<PRE>double <B>real</B>(const double_complex&amp; left);
float <B>real</B>(const float_complex&amp; left);</PRE>

<P>The function returns the real part of <CODE>left</CODE>.</P>

<H2><A NAME="sin"><CODE>sin</CODE></A></H2>

<PRE>double_complex <B>sin</B>(const double_complex&amp; left);
float_complex <B>sin</B>(const float_complex&amp; left);</PRE>

<P>The function returns the sine of <CODE>left</CODE>.</P>

<H2><A NAME="sinh"><CODE>sinh</CODE></A></H2>

<PRE>double_complex <B>sinh</B>(const double_complex&amp; left);
float_complex <B>sinh</B>(const float_complex&amp; left);</PRE>

<P>The function returns the hyperbolic sine of <CODE>left</CODE>.</P>

<H2><A NAME="sqrt"><CODE>sqrt</CODE></A></H2>

<PRE>double_complex <B>sqrt</B>(const double_complex&amp; left);
float_complex <B>sqrt</B>(const float_complex&amp; left);</PRE>

<P>The function returns the square root of <CODE>left</CODE>,
with phase angle in the half-open interval <CODE>(-pi/2, pi/2]</CODE>.
The branch cuts are along the negative real axis.</P>

<H2><A NAME="__STD_COMPLEX"><CODE>__STD_COMPLEX</CODE></A></H2>

<PRE>#define <B>__STD_COMPLEX</B></PRE>

<P>The macro is defined, with an unspecified expansion, to indicate
compliance with the specifications of this header.</P>

<H2><A NAME="tan"><CODE>tan</CODE></A></H2>

<PRE>double_complex <B>tan</B>(const double_complex&amp; left);
float_complex <B>tan</B>(const float_complex&amp; left);</PRE>

<P>The function returns the tangent of <CODE>left</CODE>.</P>

<H2><A NAME="tanh"><CODE>tanh</CODE></A></H2>

<PRE>double_complex <B>tanh</B>(const double_complex&amp; left);
float_complex <B>tanh</B>(const float_complex&amp; left);</PRE>

<P>The function returns the hyperbolic tangent of <CODE>left</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pjp.html">Copyright</A> &#169; 1992-2002
by P.J. Plauger. All rights reserved.</I></P>

<!--V4.02:1476--></BODY></HTML>
