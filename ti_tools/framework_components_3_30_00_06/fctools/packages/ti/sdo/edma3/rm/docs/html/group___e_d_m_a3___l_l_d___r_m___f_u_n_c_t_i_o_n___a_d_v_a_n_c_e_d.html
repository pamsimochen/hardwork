<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EDMA3 Resource Manager: EDMA3 Resource Manager Advanced APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>EDMA3 Resource Manager Advanced APIs<br/>
<small>
[<a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n.html">EDMA3 Resource Manager APIs</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_d_m_a3___r_m___gbl_xbar_to_chan_config_params.html">EDMA3_RM_GblXbarToChanConfigParams</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Init-time Configuration structure for EDMA3 controller, to provide Global SoC specific Information.  <a href="struct_e_d_m_a3___r_m___gbl_xbar_to_chan_config_params.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef EDMA3_RM_Result(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaa3446e78614a94f6a90723f79888fd33">EDMA3_RM_mapXbarEvtToChan</a> )(uint32_t eventNum, uint32_t *chanNum, const <a class="el" href="struct_e_d_m_a3___r_m___gbl_xbar_to_chan_config_params.html">EDMA3_RM_GblXbarToChanConfigParams</a> *edmaGblXbarConfig)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associates cross bar mapped event to channel.  <a href="#gaa3446e78614a94f6a90723f79888fd33"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef EDMA3_RM_Result(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga1e994f8dbd5632fa1ed4930dad03593f">EDMA3_RM_xbarConfigScr</a> )(uint32_t eventNum, uint32_t chanNum)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to the cross bar mapped event to channel to system configuration register.  <a href="#ga1e994f8dbd5632fa1ed4930dad03593f"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga349e5d31b0ff155b6d1a4052396f8dd5">EDMA3_RM_allocLogicalChannel</a> (EDMA3_RM_Handle hEdmaResMgr, <a class="el" href="struct_e_d_m_a3___r_m___res_desc.html">EDMA3_RM_ResDesc</a> *lChObj, uint32_t *pParam, uint32_t *pTcc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a DMA/QDMA/Link channel.  <a href="#ga349e5d31b0ff155b6d1a4052396f8dd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga5edfca892da0ae3320f9bf9df4bfd52f">EDMA3_RM_freeLogicalChannel</a> (EDMA3_RM_Handle hEdmaResMgr, <a class="el" href="struct_e_d_m_a3___r_m___res_desc.html">EDMA3_RM_ResDesc</a> *lChObj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This API is used to free the specified channel (DMA/QDMA/Link) and its associated resources (PaRAM Set, TCC etc).  <a href="#ga5edfca892da0ae3320f9bf9df4bfd52f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gad0690a3a5317d4d928b1d968e61ac796">EDMA3_RM_mapEdmaChannel</a> (EDMA3_RM_Handle hEdmaResMgr, uint32_t channelId, uint32_t paRAMId)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the resources DMA Channel and PaRAM Set. Both the DMA channel and the PaRAM set should be previously allocated. If they are not, this API will result in error.  <a href="#gad0690a3a5317d4d928b1d968e61ac796"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga0b893408e1d61aff5662f76ea9aac6b9">EDMA3_RM_mapQdmaChannel</a> (EDMA3_RM_Handle hEdmaResMgr, uint32_t channelId, uint32_t paRAMId, <a class="el" href="group___e_d_m_a3___l_l_d___r_m___s_y_m_b_o_l___e_n_u_m.html#gacabe6aeb4a0ce496671777e783cdb2c4">EDMA3_RM_QdmaTrigWord</a> trigWord)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bind the resources QDMA Channel and PaRAM Set. Also, Set the trigger word for the QDMA channel. Both the QDMA channel and the PaRAM set should be previously allocated. If they are not, this API will result in error.  <a href="#ga0b893408e1d61aff5662f76ea9aac6b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga3c1f70a6659baae70acd0bd5e05ce42c">EDMA3_RM_setCCRegister</a> (EDMA3_RM_Handle hEdmaResMgr, uint32_t regOffset, uint32_t newRegValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the Channel Controller (CC) Register value.  <a href="#ga3c1f70a6659baae70acd0bd5e05ce42c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga508e7ab10ea4d68b7d52777128523123">EDMA3_RM_getCCRegister</a> (EDMA3_RM_Handle hEdmaResMgr, uint32_t regOffset, uint32_t *regValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Channel Controller (CC) Register value.  <a href="#ga508e7ab10ea4d68b7d52777128523123"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga03eb291d9e4f05e66f304e0e1c09e795">EDMA3_RM_waitAndClearTcc</a> (EDMA3_RM_Handle hEdmaResMgr, uint32_t tccNo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a transfer completion interrupt to occur and clear it.  <a href="#ga03eb291d9e4f05e66f304e0e1c09e795"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaf275e3dedd2a7592eec305d18b19bbbd">EDMA3_RM_checkAndClearTcc</a> (EDMA3_RM_Handle hEdmaResMgr, uint32_t tccNo, uint16_t *tccStatus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the status of a previously initiated transfer.  <a href="#gaf275e3dedd2a7592eec305d18b19bbbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gae904366a2d8518b01bf36c4fe5e1596b">EDMA3_RM_setPaRAM</a> (EDMA3_RM_Handle hEdmaResMgr, <a class="el" href="struct_e_d_m_a3___r_m___res_desc.html">EDMA3_RM_ResDesc</a> *lChObj, const <a class="el" href="struct_e_d_m_a3___r_m___pa_r_a_m_regs.html">EDMA3_RM_PaRAMRegs</a> *newPaRAM)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the user specified PaRAM Set onto the PaRAM Set associated with the logical channel (DMA/QDMA/Link).  <a href="#gae904366a2d8518b01bf36c4fe5e1596b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga3ba432ad2e794dcce6f892e839a1c4fd">EDMA3_RM_getPaRAM</a> (EDMA3_RM_Handle hEdmaResMgr, <a class="el" href="struct_e_d_m_a3___r_m___res_desc.html">EDMA3_RM_ResDesc</a> *lChObj, <a class="el" href="struct_e_d_m_a3___r_m___pa_r_a_m_regs.html">EDMA3_RM_PaRAMRegs</a> *currPaRAM)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve existing PaRAM set associated with specified logical channel (DMA/QDMA/Link).  <a href="#ga3ba432ad2e794dcce6f892e839a1c4fd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga633e97bd8ee118260938f8e1de0af112">EDMA3_RM_getPaRAMPhyAddr</a> (EDMA3_RM_Handle hEdmaResMgr, <a class="el" href="struct_e_d_m_a3___r_m___res_desc.html">EDMA3_RM_ResDesc</a> *lChObj, uint32_t *paramPhyAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the PaRAM Set Physical Address associated with a logical channel.  <a href="#ga633e97bd8ee118260938f8e1de0af112"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga57819bbb04ee04fbc836919dc46934fa">EDMA3_RM_getBaseAddress</a> (EDMA3_RM_Handle hEdmaResMgr, <a class="el" href="group___e_d_m_a3___l_l_d___r_m___s_y_m_b_o_l___e_n_u_m.html#ga73a8a7c45f838fa372757dca388c8a4f">EDMA3_RM_Cntrlr_PhyAddr</a> controllerId, uint32_t *phyAddress)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Channel Controller or Transfer Controller (n) Physical Address.  <a href="#ga57819bbb04ee04fbc836919dc46934fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga3425ab19139bc4cc0f0383b4a881e3a8">EDMA3_RM_getGblConfigParams</a> (uint32_t phyCtrllerInstId, <a class="el" href="struct_e_d_m_a3___r_m___gbl_config_params.html">EDMA3_RM_GblConfigParams</a> *gblCfgParams)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the SoC specific configuration structure for the EDMA3 Hardware.  <a href="#ga3425ab19139bc4cc0f0383b4a881e3a8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gac3035b42aa8cbb53603cbcdc6e6ca5b8">EDMA3_RM_getInstanceInitCfg</a> (EDMA3_RM_Handle hEdmaResMgr, <a class="el" href="struct_e_d_m_a3___r_m___instance_init_config.html">EDMA3_RM_InstanceInitConfig</a> *instanceInitConfig)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the RM Instance specific configuration structure for different EDMA3 resources' usage (owned resources, reserved resources etc).  <a href="#gac3035b42aa8cbb53603cbcdc6e6ca5b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaf0e5b30b8e1d058499bcf088847484c5">EDMA3_RM_Ioctl</a> (EDMA3_RM_Handle hEdmaResMgr, <a class="el" href="group___e_d_m_a3___l_l_d___r_m___s_y_m_b_o_l___e_n_u_m.html#ga009c5aa71d396e2d6b84426709a8da7e">EDMA3_RM_IoctlCmd</a> cmd, void *cmdArg, void *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EDMA3 Resource Manager IOCTL.  <a href="#gaf0e5b30b8e1d058499bcf088847484c5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_RM_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gabc273aa6aa42d3ffcaedc0856e921c92">EDMA3_RM_initXbarEventMap</a> (EDMA3_RM_Handle hEdma, const <a class="el" href="struct_e_d_m_a3___r_m___gbl_xbar_to_chan_config_params.html">EDMA3_RM_GblXbarToChanConfigParams</a> *edmaGblXbarConfig, <a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaa3446e78614a94f6a90723f79888fd33">EDMA3_RM_mapXbarEvtToChan</a> mapXbarEvtFunc, <a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga1e994f8dbd5632fa1ed4930dad03593f">EDMA3_RM_xbarConfigScr</a> configXbarScr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the cross bar mapped event to channel function.  <a href="#gabc273aa6aa42d3ffcaedc0856e921c92"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaa3446e78614a94f6a90723f79888fd33"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_mapXbarEvtToChan" ref="gaa3446e78614a94f6a90723f79888fd33" args=")(uint32_t eventNum, uint32_t *chanNum, const EDMA3_RM_GblXbarToChanConfigParams *edmaGblXbarConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EDMA3_RM_Result(* <a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaa3446e78614a94f6a90723f79888fd33">EDMA3_RM_mapXbarEvtToChan</a>)(uint32_t eventNum, uint32_t *chanNum, const <a class="el" href="struct_e_d_m_a3___r_m___gbl_xbar_to_chan_config_params.html">EDMA3_RM_GblXbarToChanConfigParams</a> *edmaGblXbarConfig)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associates cross bar mapped event to channel. </p>
<p>This function have to be defined in the configuration file. This function will be called only if the channel requested for is beyond the maximum number of channels. This function should read from the global cross bar mapped configuration data structure and return the mapped channel number to this event.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eventNum</em>&nbsp;</td><td>[IN] Event number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chanNum</em>&nbsp;</td><td>[IN/OUT]Return the channel number to which the request event is mapped to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edmaGblXbarConfig</em>&nbsp;</td><td>[IN] This is the configuration data structure for mapping the events to the channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique event values. It is non-re-entrant for same event values. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1e994f8dbd5632fa1ed4930dad03593f"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_xbarConfigScr" ref="ga1e994f8dbd5632fa1ed4930dad03593f" args=")(uint32_t eventNum, uint32_t chanNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EDMA3_RM_Result(* <a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga1e994f8dbd5632fa1ed4930dad03593f">EDMA3_RM_xbarConfigScr</a>)(uint32_t eventNum, uint32_t chanNum)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes to the cross bar mapped event to channel to system configuration register. </p>
<p>This function have to be defined in the configuration file. This function will be called only if the event number requested for is beyond the maximum number of channels and if any channel is allocated to this event. This function should read the cross bar mapped event number and write the allocated channel number in Control Config Event Mux registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eventNum</em>&nbsp;</td><td>[IN] Event number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chanNum</em>&nbsp;</td><td>[IN/OUT]Return the channel number to which the request event is mapped to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique event values. It is non-re-entrant for same event values. </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga349e5d31b0ff155b6d1a4052396f8dd5"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_allocLogicalChannel" ref="ga349e5d31b0ff155b6d1a4052396f8dd5" args="(EDMA3_RM_Handle hEdmaResMgr, EDMA3_RM_ResDesc *lChObj, uint32_t *pParam, uint32_t *pTcc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_allocLogicalChannel </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_e_d_m_a3___r_m___res_desc.html">EDMA3_RM_ResDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>lChObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>pParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>pTcc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a DMA/QDMA/Link channel. </p>
<p>This API is used to allocate a logical channel (DMA/QDMA/Link) along with the associated resources. For DMA and QDMA channels, TCC and PaRAM Set are also allocated along with the requested channel. For Link channel, ONLY a PaRAM Set is allocated.</p>
<p>Note: To free the logical channel allocated by this API, user should call EDMA3_RM_freeLogicalChannel () ONLY to de-allocate all the allocated resources and remove certain mappings.</p>
<p>User can request a specific logical channel by passing the channel id in 'lChObj-&gt;resId' and channel type in 'lChObj-&gt;type'. Note that the channel id is the same as the actual resource id. For e.g. in the case of QDMA channels, valid channel ids are from 0 to 7 only.</p>
<p>User can also request ANY available logical channel of the type 'lChObj-&gt;type' by specifying 'lChObj-&gt;resId' as: a) EDMA3_RM_DMA_CHANNEL_ANY: For DMA channels b) EDMA3_RM_QDMA_CHANNEL_ANY: For QDMA channels, and c) EDMA3_RM_PARAM_ANY: For Link channels. Normally user should use this value to request link channels (PaRAM Sets used for linking purpose only), unless he wants to use some specific link channels (PaRAM Sets) which is also allowed.</p>
<p>This API internally uses EDMA3_RM_allocResource () to allocate the desired resources (DMA/QDMA channel, PaRAM Set and TCC).</p>
<p>For DMA/QDMA channels, after allocating all the EDMA3 resources, this API sets the TCC field of the OPT PaRAM Word with the allocated TCC.</p>
<p>For DMA channel, it also sets the DCHMAP register, if required.</p>
<p>For QDMA channel, it sets the QCHMAP register and CCNT as trigger word and enables the QDMA channel by writing to the QEESR register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lChObj</em>&nbsp;</td><td>[IN/OUT] Handle to the requested logical channel object, which needs to be allocated. It could be a specific logical channel or ANY available logical channel of the requested type. In case user passes a specific resource Id, lChObj value is left unchanged. In case user requests ANY available resource, the allocated resource id is returned in lChObj-&gt;resId.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pParam</em>&nbsp;</td><td>[IN/OUT] PaRAM Set for a particular logical (DMA/QDMA) channel. Not used if user requested for a Link channel. In case user passes a specific PaRAM Set value, pParam value is left unchanged. In case user requests ANY available PaRAM Set by passing 'EDMA3_RM_PARAM_ANY' in pParam, the allocated one is returned in pParam.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pTcc</em>&nbsp;</td><td>[IN/OUT] TCC for a particular logical (DMA/QDMA) channel. Not used if user requested for a Link channel. In case user passes a specific TCC value, pTcc value is left unchanged. In case user requests ANY available TCC by passing 'EDMA3_RM_TCC_ANY' in pTcc, the allocated one is returned in pTcc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function internally calls EDMA3_RM_allocResource (), which acquires a RM Instance specific semaphore to prevent simultaneous access to the global pool of resources. It is re-entrant for unique logical channel values, but SHOULD NOT be called from the user callback function (ISR context). </dd></dl>

</div>
</div>
<a class="anchor" id="ga5edfca892da0ae3320f9bf9df4bfd52f"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_freeLogicalChannel" ref="ga5edfca892da0ae3320f9bf9df4bfd52f" args="(EDMA3_RM_Handle hEdmaResMgr, EDMA3_RM_ResDesc *lChObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_freeLogicalChannel </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_e_d_m_a3___r_m___res_desc.html">EDMA3_RM_ResDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>lChObj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This API is used to free the specified channel (DMA/QDMA/Link) and its associated resources (PaRAM Set, TCC etc). </p>
<p>This API internally uses EDMA3_RM_freeResource () to free the desired resources.</p>
<p>For DMA/QDMA channels, it also clears the DCHMAP/QCHMAP registers</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lChObj</em>&nbsp;</td><td>[IN] Handle to the logical channel object, which needs to be freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This is a re-entrant function which internally calls EDMA3_RM_freeResource () for resource de-allocation. </dd></dl>

</div>
</div>
<a class="anchor" id="gad0690a3a5317d4d928b1d968e61ac796"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_mapEdmaChannel" ref="gad0690a3a5317d4d928b1d968e61ac796" args="(EDMA3_RM_Handle hEdmaResMgr, uint32_t channelId, uint32_t paRAMId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_mapEdmaChannel </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>paRAMId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind the resources DMA Channel and PaRAM Set. Both the DMA channel and the PaRAM set should be previously allocated. If they are not, this API will result in error. </p>
<p>This API sets the DCHMAP register for a specific DMA channel. This register is used to specify the PaRAM Set associated with that particular DMA Channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channelId</em>&nbsp;</td><td>[IN] Previously allocated DMA Channel on which Transfer will occur. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paRAMId</em>&nbsp;</td><td>[IN] Previously allocated PaRAM Set which needs to be associated with the dma channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This API is useful only for the EDMA3 Controllers which have a register for mapping a DMA Channel to a particular PaRAM Set (DCHMAP register). On platforms where this feature is not supported, this API returns error code: EDMA3_RM_E_FEATURE_UNSUPPORTED. This function is re-entrant for unique channelId. It is non-re-entrant for same channelId values. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0b893408e1d61aff5662f76ea9aac6b9"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_mapQdmaChannel" ref="ga0b893408e1d61aff5662f76ea9aac6b9" args="(EDMA3_RM_Handle hEdmaResMgr, uint32_t channelId, uint32_t paRAMId, EDMA3_RM_QdmaTrigWord trigWord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_mapQdmaChannel </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>paRAMId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___s_y_m_b_o_l___e_n_u_m.html#gacabe6aeb4a0ce496671777e783cdb2c4">EDMA3_RM_QdmaTrigWord</a>&nbsp;</td>
          <td class="paramname"> <em>trigWord</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind the resources QDMA Channel and PaRAM Set. Also, Set the trigger word for the QDMA channel. Both the QDMA channel and the PaRAM set should be previously allocated. If they are not, this API will result in error. </p>
<p>This API sets the QCHMAP register for a specific QDMA channel. This register is used to specify the PaRAM Set associated with that particular QDMA Channel along with the trigger word.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channelId</em>&nbsp;</td><td>[IN] Previously allocated QDMA Channel on which Transfer will occur. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paRAMId</em>&nbsp;</td><td>[IN] Previously allocated PaRAM Set, which needs to be associated with channelId </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trigWord</em>&nbsp;</td><td>[IN] The Trigger Word for the channel. Trigger Word is the word in the PaRAM Register Set which - when written to by CPU -will start the QDMA transfer automatically</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique channelId. It is non-re-entrant for same channelId values. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c1f70a6659baae70acd0bd5e05ce42c"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_setCCRegister" ref="ga3c1f70a6659baae70acd0bd5e05ce42c" args="(EDMA3_RM_Handle hEdmaResMgr, uint32_t regOffset, uint32_t newRegValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_setCCRegister </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>newRegValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the Channel Controller (CC) Register value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regOffset</em>&nbsp;</td><td>[IN] CC Register offset whose value needs to be set. It should be word-aligned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newRegValue</em>&nbsp;</td><td>[IN] New CC Register Value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is non re-entrant for users using the same Resource Manager handle. Before modifying a register, it tries to acquire a semaphore (RM instance specific), to protect simultaneous modification of the same register by two different users. After the successful change, it releases the semaphore. For users using different RM handles, this function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga508e7ab10ea4d68b7d52777128523123"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_getCCRegister" ref="ga508e7ab10ea4d68b7d52777128523123" args="(EDMA3_RM_Handle hEdmaResMgr, uint32_t regOffset, uint32_t *regValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_getCCRegister </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>regValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Channel Controller (CC) Register value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regOffset</em>&nbsp;</td><td>[IN] CC Register offset whose value is needed. It should be word-aligned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regValue</em>&nbsp;</td><td>[IN/OUT] Fetched CC Register Value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga03eb291d9e4f05e66f304e0e1c09e795"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_waitAndClearTcc" ref="ga03eb291d9e4f05e66f304e0e1c09e795" args="(EDMA3_RM_Handle hEdmaResMgr, uint32_t tccNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_waitAndClearTcc </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tccNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for a transfer completion interrupt to occur and clear it. </p>
<p>This is a blocking function that returns when the IPR/IPRH bit corresponding to the tccNo specified, is SET. It clears the corresponding bit while returning also.</p>
<p>This function waits for the specific bit indefinitely in a tight loop, with out any delay in between. USE IT CAUTIOUSLY.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tccNo</em>&nbsp;</td><td>[IN] TCC, specific to which the function waits on a IPR/IPRH bit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for different tccNo. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf275e3dedd2a7592eec305d18b19bbbd"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_checkAndClearTcc" ref="gaf275e3dedd2a7592eec305d18b19bbbd" args="(EDMA3_RM_Handle hEdmaResMgr, uint32_t tccNo, uint16_t *tccStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_checkAndClearTcc </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tccNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&nbsp;</td>
          <td class="paramname"> <em>tccStatus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the status of a previously initiated transfer. </p>
<p>This is a non-blocking function that returns the status of a previously initiated transfer, based on the IPR/IPRH bit. This bit corresponds to the tccNo specified by the user. It clears the corresponding bit, if SET, while returning also.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tccNo</em>&nbsp;</td><td>[IN] TCC, specific to which the function checks the status of the IPR/IPRH bit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tccStatus</em>&nbsp;</td><td>[IN/OUT] Status of the transfer is returned here. Returns "TRUE" if the transfer has completed (IPR/IPRH bit SET), "FALSE" if the transfer has not completed successfully (IPR/IPRH bit NOT SET).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for different tccNo. </dd></dl>

</div>
</div>
<a class="anchor" id="gae904366a2d8518b01bf36c4fe5e1596b"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_setPaRAM" ref="gae904366a2d8518b01bf36c4fe5e1596b" args="(EDMA3_RM_Handle hEdmaResMgr, EDMA3_RM_ResDesc *lChObj, const EDMA3_RM_PaRAMRegs *newPaRAM)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_setPaRAM </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_e_d_m_a3___r_m___res_desc.html">EDMA3_RM_ResDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>lChObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_e_d_m_a3___r_m___pa_r_a_m_regs.html">EDMA3_RM_PaRAMRegs</a> *&nbsp;</td>
          <td class="paramname"> <em>newPaRAM</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the user specified PaRAM Set onto the PaRAM Set associated with the logical channel (DMA/QDMA/Link). </p>
<p>This API takes a PaRAM Set as input and copies it onto the actual PaRAM Set associated with the logical channel. OPT field of the PaRAM Set is written first and the CCNT field is written last.</p>
<p>Caution: It should be used carefully when programming the QDMA channels whose trigger words are not CCNT field.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lChObj</em>&nbsp;</td><td>[IN] Logical Channel object for which new PaRAM set is specified. User should pass the resource type and id in this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPaRAM</em>&nbsp;</td><td>[IN] PaRAM set to be copied onto existing one</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lChObj values. It is non- re-entrant for same lChObj value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3ba432ad2e794dcce6f892e839a1c4fd"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_getPaRAM" ref="ga3ba432ad2e794dcce6f892e839a1c4fd" args="(EDMA3_RM_Handle hEdmaResMgr, EDMA3_RM_ResDesc *lChObj, EDMA3_RM_PaRAMRegs *currPaRAM)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_getPaRAM </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_e_d_m_a3___r_m___res_desc.html">EDMA3_RM_ResDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>lChObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_e_d_m_a3___r_m___pa_r_a_m_regs.html">EDMA3_RM_PaRAMRegs</a> *&nbsp;</td>
          <td class="paramname"> <em>currPaRAM</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve existing PaRAM set associated with specified logical channel (DMA/QDMA/Link). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lChObj</em>&nbsp;</td><td>[IN] Logical Channel object for which the PaRAM set is requested. User should pass the resource type and id in this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currPaRAM</em>&nbsp;</td><td>[IN/OUT] User gets the existing PaRAM here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga633e97bd8ee118260938f8e1de0af112"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_getPaRAMPhyAddr" ref="ga633e97bd8ee118260938f8e1de0af112" args="(EDMA3_RM_Handle hEdmaResMgr, EDMA3_RM_ResDesc *lChObj, uint32_t *paramPhyAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_getPaRAMPhyAddr </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_e_d_m_a3___r_m___res_desc.html">EDMA3_RM_ResDesc</a> *&nbsp;</td>
          <td class="paramname"> <em>lChObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>paramPhyAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the PaRAM Set Physical Address associated with a logical channel. </p>
<p>This function returns the PaRAM Set Phy Address (unsigned 32 bits). The returned address could be used by the advanced users to program the PaRAM Set directly without using any APIs.</p>
<p>Least significant 16 bits of this address could be used to program the LINK field in the PaRAM Set. Users which program the LINK field directly SHOULD use this API to get the associated PaRAM Set address with the LINK channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lChObj</em>&nbsp;</td><td>[IN] Logical Channel object for which the PaRAM set physical address is required. User should pass the resource type and id in this object. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paramPhyAddr</em>&nbsp;</td><td>[IN/OUT] PaRAM Set physical address is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga57819bbb04ee04fbc836919dc46934fa"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_getBaseAddress" ref="ga57819bbb04ee04fbc836919dc46934fa" args="(EDMA3_RM_Handle hEdmaResMgr, EDMA3_RM_Cntrlr_PhyAddr controllerId, uint32_t *phyAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_getBaseAddress </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___s_y_m_b_o_l___e_n_u_m.html#ga73a8a7c45f838fa372757dca388c8a4f">EDMA3_RM_Cntrlr_PhyAddr</a>&nbsp;</td>
          <td class="paramname"> <em>controllerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>phyAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Channel Controller or Transfer Controller (n) Physical Address. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>controllerId</em>&nbsp;</td><td>[IN] Channel Controller or Transfer Controller (n) for which the physical address is required. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>phyAddress</em>&nbsp;</td><td>[IN/OUT] Physical address is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3425ab19139bc4cc0f0383b4a881e3a8"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_getGblConfigParams" ref="ga3425ab19139bc4cc0f0383b4a881e3a8" args="(uint32_t phyCtrllerInstId, EDMA3_RM_GblConfigParams *gblCfgParams)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_getGblConfigParams </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>phyCtrllerInstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_e_d_m_a3___r_m___gbl_config_params.html">EDMA3_RM_GblConfigParams</a> *&nbsp;</td>
          <td class="paramname"> <em>gblCfgParams</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the SoC specific configuration structure for the EDMA3 Hardware. </p>
<p>This API is used to fetch the global SoC specific configuration structure for the EDMA3 Hardware. It is useful for the user who has not passed this information during <a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___i_n_i_t.html#ga4ed822e8a60e9cc0d6c894f98ff2ae86" title="Create EDMA3 Resource Manager Object.">EDMA3_RM_create()</a> and taken the default configuration coming along with the package.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>phyCtrllerInstId</em>&nbsp;</td><td>[IN] EDMA3 Controller Instance Id (Hardware instance id, starting from 0). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gblCfgParams</em>&nbsp;</td><td>[IN/OUT] SoC specific configuration structure for the EDMA3 Hardware will be returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gac3035b42aa8cbb53603cbcdc6e6ca5b8"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_getInstanceInitCfg" ref="gac3035b42aa8cbb53603cbcdc6e6ca5b8" args="(EDMA3_RM_Handle hEdmaResMgr, EDMA3_RM_InstanceInitConfig *instanceInitConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_getInstanceInitCfg </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_e_d_m_a3___r_m___instance_init_config.html">EDMA3_RM_InstanceInitConfig</a> *&nbsp;</td>
          <td class="paramname"> <em>instanceInitConfig</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the RM Instance specific configuration structure for different EDMA3 resources' usage (owned resources, reserved resources etc). </p>
<p>This API is used to fetch the Resource Manager Instance specific configuration structure, for a specific shadow region. It is useful for the user who has not passed this information during EDMA3_RM_opn() and taken the default configuration coming along with the package. EDMA3 resources, owned and reserved by this RM instance, will be returned from this API.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>instanceInitConfig</em>&nbsp;</td><td>[IN/OUT] RM Instance specific configuration structure will be returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf0e5b30b8e1d058499bcf088847484c5"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_Ioctl" ref="gaf0e5b30b8e1d058499bcf088847484c5" args="(EDMA3_RM_Handle hEdmaResMgr, EDMA3_RM_IoctlCmd cmd, void *cmdArg, void *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_Ioctl </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdmaResMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___s_y_m_b_o_l___e_n_u_m.html#ga009c5aa71d396e2d6b84426709a8da7e">EDMA3_RM_IoctlCmd</a>&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cmdArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>EDMA3 Resource Manager IOCTL. </p>
<p>This function provides IOCTL functionality for EDMA3 Resource Manager</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdmaResMgr</em>&nbsp;</td><td>[IN] Handle to the previously opened Resource Manager Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd</em>&nbsp;</td><td>[IN] IOCTL command to be performed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmdArg</em>&nbsp;</td><td>[IN/OUT] IOCTL command argument (if any) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>[IN/OUT] Device/Cmd specific argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>For 'EDMA3_RM_IOCTL_GET_PARAM_CLEAR_OPTION', this function is re-entrant. For 'EDMA3_RM_IOCTL_SET_PARAM_CLEAR_OPTION', this function is re-entrant for different Resource Manager Instances (handles). </dd></dl>

</div>
</div>
<a class="anchor" id="gabc273aa6aa42d3ffcaedc0856e921c92"></a><!-- doxytag: member="edma3_rm.h::EDMA3_RM_initXbarEventMap" ref="gabc273aa6aa42d3ffcaedc0856e921c92" args="(EDMA3_RM_Handle hEdma, const EDMA3_RM_GblXbarToChanConfigParams *edmaGblXbarConfig, EDMA3_RM_mapXbarEvtToChan mapXbarEvtFunc, EDMA3_RM_xbarConfigScr configXbarScr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_RM_Result EDMA3_RM_initXbarEventMap </td>
          <td>(</td>
          <td class="paramtype">EDMA3_RM_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_e_d_m_a3___r_m___gbl_xbar_to_chan_config_params.html">EDMA3_RM_GblXbarToChanConfigParams</a> *&nbsp;</td>
          <td class="paramname"> <em>edmaGblXbarConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaa3446e78614a94f6a90723f79888fd33">EDMA3_RM_mapXbarEvtToChan</a>&nbsp;</td>
          <td class="paramname"> <em>mapXbarEvtFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___r_m___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga1e994f8dbd5632fa1ed4930dad03593f">EDMA3_RM_xbarConfigScr</a>&nbsp;</td>
          <td class="paramname"> <em>configXbarScr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the cross bar mapped event to channel function. </p>
<p>This API provides interface to associate the cross bar mapped event to edma channel in the driver. This function will called by the application during initilization. User could pass the application specific configuration structure during init-time. In case user doesn't provide it, this information could be taken from the SoC specific configuration file edma3_&lt;SOC_NAME&gt;_cfg.c, in case it is available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edmaGblXbarConfig</em>&nbsp;</td><td>[IN] This is the configuration data structure for mapping the events to the channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mapXbarEvtFunc</em>&nbsp;</td><td>[IN] This is the user defined function for mapping the cross bar event to channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_RM_SOK or EDMA3_RM Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function disables the global interrupts (by calling API edma3OsProtectEntry with protection level EDMA3_OS_PROTECT_INTERRUPT) while modifying the global data structures, to make it re-entrant. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Mon Feb 14 18:31:17 2011 for EDMA3 Resource Manager by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
