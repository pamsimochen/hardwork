/*******************************************************************************
 *                                                                             *
 * Copyright (c) 2010 Texas Instruments Incorporated - http://www.ti.com/      *
 *                        ALL RIGHTS RESERVED                                  *
 *                                                                             *
 ******************************************************************************/

/**
 * \defgroup PSP_DRV_I2C_API I2C Driver API
 *
 * @{
 */

/**
 *  \file psp_i2c.h
 *
 *  \brief I2C Driver Interface
 */

#ifndef _PSP_I2C_H_
#define _PSP_I2C_H_

/* ========================================================================== */
/*                             Include Files                                  */
/* ========================================================================== */

#include <ti/psp/devices/vps_device.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ========================================================================== */
/*                           Macros & Typedefs                                */
/* ========================================================================== */

/*
 * I2C Driver Error codes
 */

/** \brief  Returned when the I2C bus find that the bus is busy */
#define I2C_BUS_BUSY_ERR                       ((Int32) -1)

/** \brief  Returned when the I2C driver lost the bus arbitration */
#define I2C_ARBITRATION_LOSS_ERR               ((Int32) -2)

/** \brief  Returned when the I2C slave did not acknowledgement */
#define I2C_NACK_ERR                           ((Int32) -3)

/** \brief  Returned in case of an transmit underflow error */
#define I2C_TRANSMIT_UNDERFLOW_ERR             ((Int32) -4)

/** \brief  Returned in case of an receive overflow error */
#define I2C_RECEIVE_OVERFLOW_ERR               ((Int32) -5)

/* Note: The following flags offer the user maximum flexibility in terms
 * of making the right I2C transaction. In case the user does not want
 * to set the flags on his own, the default read/write flag can be specified
 */

/** \brief  Read from I2C bus (device) */
#define I2C_READ                (0x0001u)

/** \brief   Write to I2C bus (device) */
#define I2C_WRITE               (0x0002u)

/** \brief   Configure I2C in Master mode */
#define I2C_MASTER              (0x0004u)

/** \brief   Configure I2C in Slave mode (currently not supported) */
#define I2C_SLAVE               (0x0008u)

/** \brief   Generate Start - valid in master mode only */
#define I2C_START               (0x0010u)

/** \brief   Generate Stop - valid in master mode only */
#define I2C_STOP                (0x0020u)

/** \brief   Re-Start is generated by Master */
#define I2C_RESTART             (0x0040u)

/** \brief   Repeat mode */
#define I2C_REPEAT              (0x0080u)

/** \brief   Ignore Bus Busy condition */
#define I2C_IGNORE_BUS_BUSY     (0x0100u)

/** \brief   Ignore NAK */
#define I2C_M_IGNORE_NAK        (0x0200u)

/* Use these flags for simple MASTER read/write transactions on the I2C bus */
/** \brief  Default read flag */
#define I2C_DEFAULT_READ \
               (I2C_READ | I2C_MASTER | I2C_START | I2C_STOP)
/** \brief  Default write flag */
#define I2C_DEFAULT_WRITE \
               (I2C_WRITE | I2C_MASTER | I2C_START | I2C_STOP)


/** \brief I2C Driver handle */
typedef Ptr PSP_I2cHandle;

/**
 *  \brief I2C driver operating mode
 */
typedef enum
{
    I2C_OPMODE_POLLED = 0,
    /**< Polled operation mode */

    I2C_OPMODE_INTERRUPT,
    /**< Interrupt mode of operation */

    I2C_OPMODE_DMA
    /**< DMA mode of operation */
} PSP_I2cOpMode;

/**
 *  \brief I2C Instance Configuration Object
 *
 *  This structure provides various configuration options for I2C controller.
 *  It needs to be passed while creating the specific I2C instance object.
 */
typedef struct
{
    UInt32                  opMode;
    /**< Driver operating mode - polled or interrupt. Currently only polled
         mode is supported.
         For valid values see #PSP_I2cOpMode */

    UInt32                  isMasterMode;
    /**< Operating in Master/Slave mode:
         0: Slave mode
         1: Master mode
         Currently only slave mode is supported. */

    UInt32                  is10BitAddr;
    /**< Addressing mode:
         0: 7 bit addressing mode
         1: 10 bit addressing mode */

    UInt32                  i2cBusFreq;
    /**< I2C Bus Frequency (in KHz) */

    UInt32                  i2cOwnAddr;
    /**< Own address (7 or 10 bits) */

    Ptr                     i2cRegs;
    /**< I2C peripheral base address */

    UInt32                  i2cIntNum;
    /**< Interrupt number */
} PSP_I2cInitParams;

/**
 *  \brief I2C Transfer Params
 *
 *  This structure holds the information needed to carry out a transaction on
 *  I2C bus to a slave device.
 */
typedef struct
{
    UInt8           slaveAddr;
    /**< Address of the slave to talk to, not valid in Slave mode */

    UInt8           *buffer;
    /**< Data buffer */

    UInt32          bufLen;
    /**< Length of buffer */

    UInt32          flags;
    /**< Flags to indicate the various modes of operation */

    UInt32          timeout;
    /**< Timeout value */

    Ptr             param;
    /**< Extra parameter for future use */
} PSP_I2cXferParams;

/**
 *  \brief CallBack function for I2C. Please note that this is not supported
 *  currently as driver does not support async mode of operation.
 *
 *  This function will be called when a transaction gets completed when I2C
 *  driver is operating in async mode.
 *
 *  \param  appHandle [OUT] Registered by application and will be returned along
 *                          with callback.
 *  \param  event [OUT]     Event associated for which callback has been called
 *  \param  param [OUT]     Any parameter returned from driver
 */
typedef void (*PSP_I2cAppCallback)(Ptr appHandle, UInt32 event, Ptr param);


/**
 *  \brief Initialize I2C controller(s)
 *
 *  Initializes I2C controller(s) with the initParams structure. User should pass
 *  configuration information for numInstance controllers.
 *  This function should be called before calling any of driver APIs and
 *  should be called only once.
 *
 *  \param  numInstance [IN]        Number of I2C controllers need to be
 *                                  initialized
 *  \param  initParams  [IN]        Configuration for numInstance controllers.
 *
 *  \return FVID2_SOK on success else appropriate error code on failure.
 */
Int32 PSP_i2cInit(UInt32 numInstance,
                PSP_I2cInitParams *initParams);

/**
 *  \brief De-initializes I2C Instances
 *
 *  De-initializes the I2C controllers. If there are open handles,
 *  they are invalidated. It should be called only after calling PSP_i2cInit
 *  and in the end when I2C driver is no more required by any user.
 *
 *  \param args         [IN] Not used currently. Meant for future purpose.
 *
 *  \return FVID2_SOK on success else appropriate error code on failure.
 */
void PSP_i2cDeinit(Ptr args);

/**
 *  \brief Create I2C driver object for the specific I2C controller
 *
 *  Creates an I2C driver object and returns handle for the same. Multiple driver
 *  objects can be created. Maximum number of driver objects which can be created
 *  per I2C controller is configurable.
 *
 *  \param  instanceId  [IN]    I2C controller number
 *  \param  callback    [IN]    Callback function for events notification. It is
 *                              used in async mode of operation. It is not used
 *                              currently.
 *  \param  appData     [IN]    Application specific data which is returned in
 *                              the callback function as it is. This could be
 *                              set to NULL if not used.
 *
 *  \return PSP_I2cHandle [OUT] If successful, non-null driver object handle
 *                              is returned, else NULL.
 */
PSP_I2cHandle PSP_i2cCreate(UInt32 instanceId,
                            PSP_I2cAppCallback callback,
                            Ptr appData);

/**
 *  \brief Deletes I2C driver object
 *
 *  Deletes the I2C driver object, previously created with PSP_i2cCreate.
 *
 *  \param  handle      [IN]    I2C Driver Object Handle
 *
 *  \return FVID2_SOK on success else appropriate error code on failure.
 */
Int32 PSP_i2cDelete(PSP_I2cHandle handle);

/**
 *  \brief Read/write from/to a specific slave device
 *
 *  This function reads/writes user specified bytes of data from/to a specific
 *  slave.
 *  It is a blocking call if polled mode of I2C is used. For other modes, it
 *  is a non-blocking call.
 *  In polled mode, I2C driver will try to read/write data untill a timeout
 *  occurs.
 *
 *  \param  handle          [IN]    I2C Driver Instance Handle
 *  \param  i2cXferParams   [IN]    Pointer to the transfer params structure.
 *                                  It holds information like slave address,
 *                                  number of bytes to read/write, command etc.
 *
 *  \return FVID2_SOK on success else appropriate error code on failure.
 */
Int32 PSP_i2cTransfer(PSP_I2cHandle handle,
                        PSP_I2cXferParams *i2cXferParams);

/**
 *  \brief Probe a specific slave on a I2C bus
 *
 *  This function tries to probe a specific slave on the specified I2C bus.
 *  It is a blocking call and should be called only after calling PSP_i2cCreate()
 *  for that particular I2C instance.
 *
 *  \param  instanceId  [IN]    I2C controller number
 *  \param  slaveAddr   [IN]    Slave address which needs to be probed
 *
 *  \return FVID2_SOK on success (slave is present) else appropriate error code.
 */
int PSP_i2cProbe (UInt32 instanceId, UInt8 slaveAddr);


#ifdef __cplusplus
}
#endif

#endif  /*  _PSP_I2C_H_  */

/* @} */

