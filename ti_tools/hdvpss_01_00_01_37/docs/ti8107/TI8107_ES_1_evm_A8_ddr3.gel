/*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Project     : DM385
File        : DM385_v1.gel
Owner       : DM385 AVV
Purpose     : DM385 Silicon Bring up gel file
Desciption  : Contains intilization routines for DDR,HDVICP2,UART,TIMER,DUCATI etc. ****This is not for customer release****
Version Hystory
---------------
Version     Date            Who             Description
-------     -----------     ------          -----------
V1.0        19-Dec-2011     raj@ti.com      Initial Version.
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*/


/********************************************************************************************/

    #define WR_MEM_32(addr, data)    *(unsigned int*)(addr) =(unsigned int)(data)
    #define RD_MEM_32(addr)          *(unsigned int*)(addr)
    #define UWORD32                  unsigned int
    #define RD_M_WR_MEM_32(addr,data,mask) WR_MEM_32(addr, (RD_MEM_32(addr)& mask)| data)



OnTargetConnect()
{
	TI8107HdvpssInit();
}

menuitem "TI8107 System Initialization"
/********************************************************************************************/
    /***** For GP Device *************/
    hotmenu DM385_System_Initialisation_GP_device()
    {
        GEL_TextOut("\t ****  DM385 System_Initialisation IS in progress .......... \n","Output",1,1,1);
        ALL_ADPLL_CLOCKS_ENABLE_API();
        DucatiClkEnable();
        GEMSSClkEnable();
        GEL_TextOut("\t ****  DM385 System_Initialisation IS Done ****************** \n","Output",1,1,1);
    }

    hotmenu TI8107HdvpssInit()
    {
	ALL_ADPLL_CLOCKS_ENABLE_API();
	EVM_DDR3_EMIF0_400MHz_Config();
	DucatiClkEnable();
	HDMI_PLL_Config_145();
	HdvpssClkEnable();
	DssConfigHDMI();
    }
 
    hotmenu mmr_unlock_API()
    {
        mmr_unlock();
    }

    hotmenu IS_DEVICE_GP_TEST_API()
    {
        IS_DEVICE_GP_TEST();

    }

    hotmenu ALL_ADPLL_CLOCKS_ENABLE_API()
    {
        GEL_TextOut("\t ****  DM385 ALL ADPLL INIT IS In Progress ......... \n","Output",1,1,1);
        PLL_SETUP();
        GEL_TextOut("\t ****  DM385 ALL ADPLL INIT IS  Done ************** \n","Output",1,1,1);
    }

/********************************************************************************************
    //Note: By default the Values of ADPLL are set using "ALL_ADPLL_CLOCKS_ENABLE" function if called.

    //CONFIGURE ADPLL TO GET REQUIRED CLKOUTS  with your required values of N,M,M2

    //RUN THE HOTMENU of the REQUIRED CHANGED PLL
*********************************************************************************************/

    /***********************************************************************************
        Change the values of N,M,M2 to get the Required ADPLL Clockout
        cmdxxxxPLL(int CLKIN,int N, int M, int M2)

        ****   REF_CLK       = (CLKIP)/N+1  [  REF_CLK < 2.5MHz      ]
        ****   DCOCLK_HS2    = (REF_CLK)*M     [500  < DCOCLK < 1000MHz ]
        ****   DCOCLK_HS1    = (REF_CLK)*M     [1000 < DCOCLK < 2000MHz ]--used for HDMI CLKDCO
        ****   CLKOUT        =  DCOCLK/M2      [10   < CLKOUT < 2000MHz ]
        ****   N+1                             [1..256]
        ****   M                               [2..4095]
        ****   M2                              [1..127]
        ****
    *****************************************************************************************/



/********************************************************************************************/

    /*****************************************************************************************
    CONTROL MODULE,ADPLL,HDVICP,DUCATI,GPMC Clock ENABLES
    *****************************************************************************************/
    menuitem "DM385 CORE_CLKS Configuration"

    /************ Enable the Ducati Clocks ***************/
    hotmenu DucatiClkEnable_API()
    {
        DucatiClkEnable();
    }

    /************ Enable the HDVICP Clocks ***************/
    hotmenu HDVICPClkEnable_API()
    {
        HDVICPClkEnable();
    }

    hotmenu SecM3_GP_ModeEnable()
    {
        WR_MEM_32(0x411F2004,0x0);
        WR_MEM_32(0x411F2000,0x01E03);
        WR_MEM_32(0x411F4008,0x01E03);
        GEL_TextOut("\t ****  User Can now connect to Secure M3 in GP mode *** \n");
    }




   /********************************************************************************
                        PERIPHERAL CLOCK ENABLES
                        EMAC,UART,ISS_A8,DSS,MLB,DCAN
   *********************************************************************************/
   /*** ADD Here if any required Module clocks *************/

    menuitem "DM385 Peripheral Clock Init"

    hotmenu ControlModule_ClkEnable_API()
    {
        ControlModule_ClkEnable();
    }

    hotmenu PrcmOCMCClkEnable_API()
    {
        PrcmOCMCClkEnable();
    }

    hotmenu EMAC_SATA0_Clkenable_API()
    {
        EMAC_SATA0_Clkenable();
    }
    hotmenu EMAC_SATA1_Clkenable_API()
    {
        EMAC_SATA1_Clkenable();
    }

    hotmenu Clockout_Enable_API()
    {
        Clockout_Enable();
    }

    hotmenu UARTClkEnable_API()
    {
        UARTClkEnable();
    }

    hotmenu ISS_ClkEnable_API()
    {
        ISS_ClkEnable();
    }

    hotmenu DSSClkEnable_API()
    {
        DSSClkEnable();
    }

    hotmenu MLBClkEnable_API()
    {
        MLBClkEnable();
    }

    hotmenu DCANClkEnable_API()
    {
        DCANClkEnable();
    }

    hotmenu GPMC_ClkEnable_API()
    {
        GPMC_ClkEnable();
    }

/********************************************************************************/


/***************************************************************************************************************
                        CENATAURUS2  REGISTER MAP DEFINES
***************************************************************************************************************/

    #define PRCM_BASE_ADDR                      0x48180000
    #define DUCATI_BASE_ADDR                        0x55020000
    #define DUCATI_MMU_CFG                      0x55080000
    #define CTRL_MODULE_BASE_ADDR                   0x48140000
    #define GEM_L2RAM_BASE_ADDR                 0x40800000

    /* Control Module*/
    #define CM_CTRL_CLKCTRL                     (PRCM_BASE_ADDR + 0x15C4)

    /*EMAC*/
    #define CM_ETHERNET_CLKSTCTRL                   (PRCM_BASE_ADDR + 0x1404)
    #define CM_ALWON_ETHERNET_0_CLKCTRL                 (PRCM_BASE_ADDR + 0x15D4)

    /* Clock out */
    #define CM_CLKOUT_CTRL                      (PRCM_BASE_ADDR + 0x0100)

    /* ISS */
    #define PM_ISP_PWRSTCTRL                        (PRCM_BASE_ADDR + 0x0D00)
    #define RM_ISP_RSTCTRL                          (PRCM_BASE_ADDR + 0x0D10)
    #define CM_ISP_CLKSTCTRL                        (PRCM_BASE_ADDR + 0x0700)
    #define CM_ISP_ISP_CLKCTRL                      (PRCM_BASE_ADDR + 0x0720)
        #define CM_ISP_FDIF_CLKCTRL                     (PRCM_BASE_ADDR + 0x0724)

        /*DSS */
        #define RM_DSS_RSTCTRL                          (PRCM_BASE_ADDR + 0x0E10)
    #define CM_DSS_CLKSTCTRL                        (PRCM_BASE_ADDR + 0x0800)
    #define CM_DSS_DSS_CLKCTRL                      (PRCM_BASE_ADDR + 0x0820)
    #define CM_DSS_HDMI_CLKCTRL                     (PRCM_BASE_ADDR + 0x0824)

    /*UART*/
    #define CM_ALWON_UART_0_CLKCTRL                 (PRCM_BASE_ADDR + 0x1550)
    #define CM_ALWON_UART_1_CLKCTRL                 (PRCM_BASE_ADDR + 0x1554)
    #define CM_ALWON_UART_2_CLKCTRL                 (PRCM_BASE_ADDR + 0x1558)
    #define CM_DEFAULT_DUCATI_CLKSTCTRL             (PRCM_BASE_ADDR + 0x0518)
    #define CM_DEFAULT_DUCATI_CLKCTRL               (PRCM_BASE_ADDR + 0x0574)
    #define RM_DEFAULT_RSTCTRL                  (PRCM_BASE_ADDR + 0x0B10)
    #define RM_DEFAULT_RSTST                    (PRCM_BASE_ADDR + 0x0B14)
    #define CM_ALWON_OCMC_0_CLKSTCTRL               (PRCM_BASE_ADDR + 0x1414)
    #define CM_ALWON_OCMC_0_CLKCTRL                 (PRCM_BASE_ADDR + 0x15B4)
    #define CM_ALWON_GPMC_CLKCTRL                   (PRCM_BASE_ADDR + 0x15D0)

    /*HDVICP PRCM Definition*/
    #define CM_HDVICP_CLKSTCTRL                 (PRCM_BASE_ADDR + 0x0600)
    #define CM_HDVICP_CLKCTRL                   (PRCM_BASE_ADDR + 0x0620)
    #define CM_HDVICP_SL2_CLKCTRL                   (PRCM_BASE_ADDR + 0x0624)
    #define PM_HDVICP_PWRSTST                   (PRCM_BASE_ADDR + 0x0C04)
    #define RM_HDVICP_RSTCTRL                   (PRCM_BASE_ADDR + 0x0C10)
    #define RM_HDVICP_RSTST                         (PRCM_BASE_ADDR + 0x0C14)
    /*END OF HDVICP PRCM Definition*/



    /*GEMSS PRCEM definition*/
    #define CM_GEM_CLKSTCTRL                    (PRCM_BASE_ADDR + 0x0400)
    #define CM_ACTIVE_GEM_CLKCTRL                   (PRCM_BASE_ADDR + 0x0420)
    #define PM_ACTIVE_PWRSTST                   (PRCM_BASE_ADDR + 0x0A04)
    #define RM_ACTIVE_RSTCTRL                   (PRCM_BASE_ADDR + 0x0A10)
    #define RM_ACTIVE_RSTST                     (PRCM_BASE_ADDR + 0x0A14)
    #define CM_MMU_CLKSTCTRL                    (PRCM_BASE_ADDR + 0x140C)
    #define CM_ALWON_MMUDATA_CLKCTRL                (PRCM_BASE_ADDR + 0x159C)
    #define CM_MMUCFG_CLKSTCTRL                     (PRCM_BASE_ADDR + 0x1410)
    #define CM_ALWON_MMUCFG_CLKCTRL                 (PRCM_BASE_ADDR + 0x15A8)
    /*END OF GEMSS PRCM Definition*/


    /* TPPSS */
    #define CM_DEFAULT_TPPSS_CLKSTCTRL              (PRCM_BASE_ADDR + 0x50C)
    #define CM_DEFAULT_TPPSS_CLKCTRL                (PRCM_BASE_ADDR + 0x554)
    #define TPPIRAM_BASE_ADDR                   0x57180000

    /* Control Module Always on ClockControl */
    #define CM_ALWON_L3_SLOW_CLKSTCTRL              (PRCM_BASE_ADDR + 0x1400)
    #define CM_ALWON_MLB_CLKCTRL                    (PRCM_BASE_ADDR + 0x1574)
    #define CM_ALWON_SYSCLK5_CLKSTCTRL              (PRCM_BASE_ADDR + 0x1424)
    #define CM_ALWON_DCAN_0_1_CLKCTRL               (PRCM_BASE_ADDR + 0x1618)


/* MMR Lock */
    #define MMR_LOCK0                       (PRCM_BASE_ADDR + 0x0060)
    #define MMR_LOCK1                       (PRCM_BASE_ADDR + 0x0064)
    #define MMR_LOCK2                       (PRCM_BASE_ADDR + 0x0068)
    #define MMR_LOCK3                       (PRCM_BASE_ADDR + 0x006c)
    #define MMR_LOCK4                       (PRCM_BASE_ADDR + 0x0070)

    #define CM_TIMER0_CLKSEL                (PRCM_BASE_ADDR + 0x038C)
    #define CM_TIMER1_CLKSEL                (PRCM_BASE_ADDR + 0x0390)
    #define CM_TIMER2_CLKSEL                (PRCM_BASE_ADDR + 0x0394)
    #define CM_TIMER3_CLKSEL                (PRCM_BASE_ADDR + 0x0398)
    #define CM_TIMER4_CLKSEL                (PRCM_BASE_ADDR + 0x039C)
    #define CM_TIMER5_CLKSEL                (PRCM_BASE_ADDR + 0x03A0)
    #define CM_TIMER6_CLKSEL                (PRCM_BASE_ADDR + 0x03A4)
    #define CM_TIMER7_CLKSEL                (PRCM_BASE_ADDR + 0x03A8)



    #define OCMC0RAM_BASE_ADDR              0x40300000


    #define DMTIMER0_BASE_ADDR              0x4802C000
    #define DMTIMER1_BASE_ADDR              0x4802E000
    #define DMTIMER2_BASE_ADDR              0x48040000
    #define DMTIMER3_BASE_ADDR              0x48042000
    #define DMTIMER4_BASE_ADDR              0x48044000
    #define DMTIMER5_BASE_ADDR              0x48046000
    #define DMTIMER6_BASE_ADDR              0x48048000
    #define DMTIMER7_BASE_ADDR              0x4804A000

/*****************************************************************************/
    /*EMIF4 PRCM Defintion*/
    #define CM_DEFAULT_L3_FAST_CLKSTCTRL                (PRCM_BASE_ADDR + 0x0508)
    #define CM_DEFAULT_EMIF_0_CLKCTRL               (PRCM_BASE_ADDR + 0x0520)
    #define CM_DEFAULT_DMM_CLKCTRL                  (PRCM_BASE_ADDR + 0x0528)
    #define CM_DEFAULT_FW_CLKCTRL                   (PRCM_BASE_ADDR + 0x052C)
    /*end of EMIF4 PRCM definition*/

    #define DDR0_PHY_BASE_ADDR                  0x47C0C400
    #define DDR0_IO_CTRL                        0x48140E04
    #define VTP0_CTRL_REG                       0x48140E0C
    #define EMIF4_0_CFG_BASE_ADDR                   0x4C000000
    #define DMM_BASE_ADDR                       0x4E000000

    //-DMM & EMIF4 MMR Declaration
    #define DMM_LISA_MAP__0                     (DMM_BASE_ADDR + 0x40)
    #define DMM_LISA_MAP__1                     (DMM_BASE_ADDR + 0x44)
    #define DMM_LISA_MAP__2                     (DMM_BASE_ADDR + 0x48)
    #define DMM_LISA_MAP__3                     (DMM_BASE_ADDR + 0x4C)
    #define DMM_PAT_BASE_ADDR                   (DMM_BASE_ADDR + 0x460)

    #define EMIF4_0_SDRAM_CONFIG                    (EMIF4_0_CFG_BASE_ADDR + 0x08)
    #define EMIF4_0_SDRAM_CONFIG2                   (EMIF4_0_CFG_BASE_ADDR + 0x0C)
    #define EMIF4_0_SDRAM_REF_CTRL                  (EMIF4_0_CFG_BASE_ADDR + 0x10)
    #define EMIF4_0_SDRAM_REF_CTRL_SHADOW               (EMIF4_0_CFG_BASE_ADDR + 0x14)
    #define EMIF4_0_SDRAM_TIM_1                 (EMIF4_0_CFG_BASE_ADDR + 0x18)
    #define EMIF4_0_SDRAM_TIM_1_SHADOW              (EMIF4_0_CFG_BASE_ADDR + 0x1C)
    #define EMIF4_0_SDRAM_TIM_2                 (EMIF4_0_CFG_BASE_ADDR + 0x20)
    #define EMIF4_0_SDRAM_TIM_2_SHADOW              (EMIF4_0_CFG_BASE_ADDR + 0x24)
    #define EMIF4_0_SDRAM_TIM_3                 (EMIF4_0_CFG_BASE_ADDR + 0x28)
    #define EMIF4_0_SDRAM_TIM_3_SHADOW              (EMIF4_0_CFG_BASE_ADDR + 0x2C)
    #define EMIF4_0_DDR_PHY_CTRL_1                  (EMIF4_0_CFG_BASE_ADDR + 0xE4)
    #define EMIF4_0_DDR_PHY_CTRL_1_SHADOW               (EMIF4_0_CFG_BASE_ADDR + 0xE8)
    #define EMIF4_0_SDRAM_ZQCR                  (EMIF4_0_CFG_BASE_ADDR + 0xC8)
    #define EMIF4_0_RDWR_LVL_RMP_CTRL               (EMIF4_0_CFG_BASE_ADDR + 0xD8)
    #define EMIF4_0_RDWR_LVL_CTRL                   (EMIF4_0_CFG_BASE_ADDR + 0xDC)


    //- DDR0 Phy MMRs
    #define CMD0_REG_PHY0_CTRL_SLAVE_RATIO_0            (0x01C + DDR0_PHY_BASE_ADDR)
    #define CMD0_REG_PHY0_DLL_LOCK_DIFF_0               (0x028 + DDR0_PHY_BASE_ADDR)
    #define CMD0_REG_PHY0_INVERT_CLKOUT_0               (0x02C + DDR0_PHY_BASE_ADDR)
    #define CMD1_REG_PHY0_CTRL_SLAVE_RATIO_0            (0x050 + DDR0_PHY_BASE_ADDR)
    #define CMD1_REG_PHY0_DLL_LOCK_DIFF_0               (0x05C + DDR0_PHY_BASE_ADDR)
    #define CMD1_REG_PHY0_INVERT_CLKOUT_0               (0x060 + DDR0_PHY_BASE_ADDR)
    #define CMD2_REG_PHY0_CTRL_SLAVE_RATIO_0            (0x084 + DDR0_PHY_BASE_ADDR)
    #define CMD2_REG_PHY0_DLL_LOCK_DIFF_0               (0x090 + DDR0_PHY_BASE_ADDR)
    #define CMD2_REG_PHY0_INVERT_CLKOUT_0               (0x094 + DDR0_PHY_BASE_ADDR)

    #define DATA0_REG_PHY0_RD_DQS_SLAVE_RATIO_0         (0x0C8 + DDR0_PHY_BASE_ADDR)
    #define DATA0_REG_PHY0_WR_DQS_SLAVE_RATIO_0         (0x0DC + DDR0_PHY_BASE_ADDR)
    #define DATA0_REG_PHY0_WRLVL_INIT_RATIO_0           (0x0F0 + DDR0_PHY_BASE_ADDR)
    #define DATA0_REG_PHY0_WRLVL_INIT_MODE_0            (0x0F8 + DDR0_PHY_BASE_ADDR)
    #define DATA0_REG_PHY0_GATELVL_INIT_RATIO_0             (0x0FC + DDR0_PHY_BASE_ADDR)
    #define DATA0_REG_PHY0_GATELVL_INIT_MODE_0          (0x104 + DDR0_PHY_BASE_ADDR)
    #define DATA0_REG_PHY0_RD_DQS_GATE_SLAVE_RATIO_0            (0x108 + DDR0_PHY_BASE_ADDR)
    #define DATA0_REG_PHY0_WR_DATA_SLAVE_RATIO_0            (0x120 + DDR0_PHY_BASE_ADDR)
    #define DATA0_REG_PHY0_USE_RANK0_DELAYS             (0x134 + DDR0_PHY_BASE_ADDR)
    #define DATA0_REG_PHY0_DLL_LOCK_DIFF_0              (0x138 + DDR0_PHY_BASE_ADDR)

    #define DATA1_REG_PHY0_RD_DQS_SLAVE_RATIO_0             (0x16C + DDR0_PHY_BASE_ADDR)
    #define DATA1_REG_PHY0_WR_DQS_SLAVE_RATIO_0             (0x180 + DDR0_PHY_BASE_ADDR)
    #define DATA1_REG_PHY0_WRLVL_INIT_RATIO_0           (0x194 + DDR0_PHY_BASE_ADDR)
    #define DATA1_REG_PHY0_WRLVL_INIT_MODE_0            (0x19C + DDR0_PHY_BASE_ADDR)
    #define DATA1_REG_PHY0_GATELVL_INIT_RATIO_0             (0x1A0 + DDR0_PHY_BASE_ADDR)
    #define DATA1_REG_PHY0_GATELVL_INIT_MODE_0          (0x1A8 + DDR0_PHY_BASE_ADDR)
    #define DATA1_REG_PHY0_RD_DQS_GATE_SLAVE_RATIO_0            (0x1AC + DDR0_PHY_BASE_ADDR)
    #define DATA1_REG_PHY0_WR_DATA_SLAVE_RATIO_0            (0x1C4 + DDR0_PHY_BASE_ADDR)
    #define DATA1_REG_PHY0_USE_RANK0_DELAYS             (0x1D8 + DDR0_PHY_BASE_ADDR)
    #define DATA1_REG_PHY0_DLL_LOCK_DIFF_0              (0x1DC + DDR0_PHY_BASE_ADDR)

    #define DATA2_REG_PHY0_RD_DQS_SLAVE_RATIO_0             (0x210 + DDR0_PHY_BASE_ADDR)
    #define DATA2_REG_PHY0_WR_DQS_SLAVE_RATIO_0             (0x224 + DDR0_PHY_BASE_ADDR)
    #define DATA2_REG_PHY0_WRLVL_INIT_RATIO_0           (0x238 + DDR0_PHY_BASE_ADDR)
    #define DATA2_REG_PHY0_WRLVL_INIT_MODE_0            (0x240 + DDR0_PHY_BASE_ADDR)
    #define DATA2_REG_PHY0_GATELVL_INIT_RATIO_0             (0x244 + DDR0_PHY_BASE_ADDR)
    #define DATA2_REG_PHY0_GATELVL_INIT_MODE_0          (0x24C + DDR0_PHY_BASE_ADDR)
    #define DATA2_REG_PHY0_RD_DQS_GATE_SLAVE_RATIO_0            (0x250 + DDR0_PHY_BASE_ADDR)
    #define DATA2_REG_PHY0_WR_DATA_SLAVE_RATIO_0            (0x268 + DDR0_PHY_BASE_ADDR)
    #define DATA2_REG_PHY0_USE_RANK0_DELAYS             (0x27C + DDR0_PHY_BASE_ADDR)
    #define DATA2_REG_PHY0_DLL_LOCK_DIFF_0              (0x280 + DDR0_PHY_BASE_ADDR)

    #define DATA3_REG_PHY0_RD_DQS_SLAVE_RATIO_0             (0x2B4 + DDR0_PHY_BASE_ADDR)
    #define DATA3_REG_PHY0_WR_DQS_SLAVE_RATIO_0             (0x2C8 + DDR0_PHY_BASE_ADDR)
    #define DATA3_REG_PHY0_WRLVL_INIT_RATIO_0           (0x2DC + DDR0_PHY_BASE_ADDR)
    #define DATA3_REG_PHY0_WRLVL_INIT_MODE_0            (0x2E4 + DDR0_PHY_BASE_ADDR)
    #define DATA3_REG_PHY0_GATELVL_INIT_RATIO_0             (0x2E8 + DDR0_PHY_BASE_ADDR)
    #define DATA3_REG_PHY0_GATELVL_INIT_MODE_0          (0x2F0 + DDR0_PHY_BASE_ADDR)
    #define DATA3_REG_PHY0_RD_DQS_GATE_SLAVE_RATIO_0            (0x2F4 + DDR0_PHY_BASE_ADDR)
    #define DATA3_REG_PHY0_WR_DATA_SLAVE_RATIO_0            (0x30C + DDR0_PHY_BASE_ADDR)
    #define DATA3_REG_PHY0_USE_RANK0_DELAYS             (0x320 + DDR0_PHY_BASE_ADDR)
    #define DATA3_REG_PHY0_DLL_LOCK_DIFF_0              (0x324 + DDR0_PHY_BASE_ADDR)


    #define DATA_MACRO_0                            0
    #define DATA_MACRO_1                            1
    #define DATA_MACRO_2                            2
    #define DATA_MACRO_3                            3
    #define DDR_PHY0                        0

    #define DDR_FREQ                        800 // 400MHz

    //- Common DDR PHY parameters
    #define PHY_INVERT_CLKOUT_DEFINE                0
    #define DDR3_PHY_INVERT_CLKOUT_ON               1
    #define DDR3_PHY_INVERT_CLKOUT_OFF              0

    #define PHY_REG_USE_RANK0_DELAY_DEFINE              0
    #define mDDR_PHY_REG_USE_RANK0_DELAY_DEFINE         1
    #define PHY_DLL_LOCK_DIFF_DEFINE                    0x4
    #define PHY_CMD0_DLL_LOCK_DIFF_DEFINE               0x4

    #define PHY_GATELVL_INIT_CS0_DEFINE                     0x0
    #define PHY_WRLVL_INIT_CS0_DEFINE               0x0

    #define PHY_GATELVL_INIT_CS1_DEFINE                     0x0
    #define PHY_WRLVL_INIT_CS1_DEFINE               0x0
    #define PHY_CTRL_SLAVE_RATIO_CS1_DEFINE                 0x80

    //- DDR2 parameters

    #define    DDR2_EMIF_DDRPHYCR_DEFINE_266    0x00173205
    #define DDR2_EMIF_TIM1_DEFINE_266               0x0666A391
    #define DDR2_EMIF_TIM2_DEFINE_266               0x203631CA
    #define DDR2_EMIF_TIM3_DEFINE_266               0x5000033F
    #define DDR2_EMIF_REF_CTRL_DEFINE_266           0x0000081A
    #define DDR2_EMIF_SDRAM_CONFIG_DEFINE_266       0x41800DB2

    #define    DDR2_EMIF_DDRPHYCR_DEFINE_333    0x00173205
    #define DDR2_EMIF_TIM1_DEFINE_333               0x0888D45A
    #define DDR2_EMIF_TIM2_DEFINE_333               0x204431D2
    #define DDR2_EMIF_TIM3_DEFINE_333               0x5000040F
    #define DDR2_EMIF_REF_CTRL_DEFINE_333           0x00000A25
    #define DDR2_EMIF_SDRAM_CONFIG_DEFINE_333       0x41800DB2

    #define    DDR2_EMIF_DDRPHYCR_DEFINE_400    0x00173206
    #define DDR2_EMIF_TIM1_DEFINE_400               0x0AAAF562
    #define DDR2_EMIF_TIM2_DEFINE_400               0x205131D2
    #define DDR2_EMIF_TIM3_DEFINE_400               0x500004DF
    #define DDR2_EMIF_REF_CTRL_DEFINE_400           0x00000C30
    #define DDR2_EMIF_SDRAM_CONFIG_DEFINE_400       0x41800DB2

    #define    DDR2_EMIF_DDRPHYCR_DEFINE_450    0x00173206
    #define DDR2_EMIF_TIM1_DEFINE_450               0x0AAD162B
    #define DDR2_EMIF_TIM2_DEFINE_450               0x205C31DA
    #define DDR2_EMIF_TIM3_DEFINE_450               0x5000057F
    #define DDR2_EMIF_REF_CTRL_DEFINE_450           0x00000DB6
    #define DDR2_EMIF_SDRAM_CONFIG_DEFINE_450       0x41800DB2

    #define    DDR2_PHY_RD_DQS_CS0_DEFINE       0x34
    #define DDR2_PHY_WR_DQS_CS0_DEFINE              0x10
    #define DDR2_PHY_RD_DQS_GATE_CS0_DEFINE             0xA0
    #define DDR2_PHY_WR_DATA_CS0_DEFINE             0x50
    #define DDR2_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE            0x80

    //- DDR3 parameters

    #define    DDR3_EMIF_REF_CTRL_DEFINE1               0x00004000
    #define    DDR3_EMIF_SDRAM_ZQCR_DEFINE              0x50074BE1


    //DDR3 300 MHz - CL=5,CWL=5 , RL=CL+3
    #define    DDR3_EMIF_TIM1_DEFINE_300                0x1109783B
    #define    DDR3_EMIF_TIM2_DEFINE_300                0x20327FDA
    #define    DDR3_EMIF_TIM3_DEFINE_300                0x501F86AF
    #define    DDR3_EMIF_REF_CTRL_DEFINE2_300           0x00000924
    #define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_300        0x61C009B2
    #define    DDR3_EMIF_DDRPHYCR_DEFINE_300            0x00173207

    //DDR3 333 MHz - CL=6,CWL=5, RL=CL+3
    #define    DDR3_EMIF_TIM1_DEFINE_333                0x1109783B
    #define    DDR3_EMIF_TIM2_DEFINE_333                0x20387FDA
    #define    DDR3_EMIF_TIM3_DEFINE_333                0x501F86AF
    #define    DDR3_EMIF_REF_CTRL_DEFINE2_333           0x00000A25
    #define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_333        0x61C011B2
    #define    DDR3_EMIF_DDRPHYCR_DEFINE_333            0x00173208

    //DDR3 400 MHz - CL=6,CWL=5, RL=CL+3
    #define    DDR3_EMIF_TIM1_DEFINE_400                0x110B783B
    #define    DDR3_EMIF_TIM2_DEFINE_400                0x20437FDA
    #define    DDR3_EMIF_TIM3_DEFINE_400                0x501F86AF
    #define    DDR3_EMIF_REF_CTRL_DEFINE2_400           0x00000C30
    #define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_400        0x61C011B2
    #define    DDR3_EMIF_DDRPHYCR_DEFINE_400            0x00173208

    //DDR3 450 MHz - CL=7,CWL=6, RL=CL+3
    #define    DDR3_EMIF_TIM1_DEFINE_450                0x110D783B
    #define    DDR3_EMIF_TIM2_DEFINE_450                0x204C7FDA
    #define    DDR3_EMIF_TIM3_DEFINE_450                0x501F86AF
    #define    DDR3_EMIF_REF_CTRL_DEFINE2_450           0x00000DB6
    #define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_450        0x61C119B2
    #define    DDR3_EMIF_DDRPHYCR_DEFINE_450            0x00173209

    //DDR3 533 MHz - CL=8,CWL=6, RL=CL+3
    #define    DDR3_EMIF_TIM1_DEFINE_533                0x110F783B
    #define    DDR3_EMIF_TIM2_DEFINE_533                0x238581E6
    #define    DDR3_EMIF_TIM3_DEFINE_533                0x501F86AF
    #define    DDR3_EMIF_REF_CTRL_DEFINE2_533           0x0000103D
    #define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_533        0x61C121B2
    #define    DDR3_EMIF_DDRPHYCR_DEFINE_533            0x0017320A

    //DDR3 666 MHz - CL=9,CWL=7, RL=CL+3
    #define    DDR3_EMIF_TIM1_DEFINE_666                0x1113783C
    #define    DDR3_EMIF_TIM2_DEFINE_666                0x30611d94
    #define    DDR3_EMIF_TIM3_DEFINE_666                0x501F86AF
    #define    DDR3_EMIF_REF_CTRL_DEFINE2_666           0x0000144A
    #define    DDR3_EMIF_SDRAM_CONFIG_DEFINE_666        0x61C229B2
    #define    DDR3_EMIF_DDRPHYCR_DEFINE_666            0x0017320B

    #define    DDR3_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE         0x80

    #define    DDR3_PHY_RD_DQS_CS0_DEFINE       0x30
    #define    DDR3_PHY_WR_DQS_CS0_DEFINE               0x21
    #define    DDR3_PHY_RD_DQS_GATE_CS0_DEFINE              0xC0
    #define    DDR3_PHY_WR_DATA_CS0_DEFINE              0x44

    //- mDDR parameters
    #define    mDDR_EMIF_READ_LATENCY_DEFINE            0x5
    #define    mDDR_EMIF_TIM1_DEFINE                0x0888831B
    #define    mDDR_EMIF_TIM2_DEFINE                0x221A31C0
    #define    mDDR_EMIF_TIM3_DEFINE                0x00000157
    #define    mDDR_EMIF_REF_CTRL_DEFINE                0x10000618
    #define    mDDR_EMIF_SDRAM_CONFIG_DEFINE            0x20000EA2

    #define    mDDR_PHY_RD_DQS_CS0_DEFINE               0x42
    #define    mDDR_PHY_WR_DQS_CS0_DEFINE               0x19
    #define    mDDR_PHY_RD_DQS_GATE_CS0_DEFINE              0x128
    #define    mDDR_PHY_WR_DATA_CS0_DEFINE              0x56
    #define    mDDR_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE         0x80





    /*************************************************************************/

    //Clockout_Enable
    // CLKOUT2DIV THis  field controls the external clock divison factor
    //          0x0:      SYS_CLKOLUT2/1
    //          0x1:      SYS_CLKOUT2/2
    //          0x2:      SYS_CLKOUT2/4
    //          0x3:      SYS_CLKOUT2/8
    //          0x4:      SYS_CLKOUT2/16

    // CLKOUT2SOURCE     This field selects the external output clock source
    //          0x0:      Source clock is MAIN_PLL_CLK5
    //          0x1:      Source clock is DDR_PLL_CLK1
    //          0x2:      Source clock is VIDEO_PLL_CLK1
    //          0x3:      Source clock is AUDIO_PLL_CLK1

    #define CLKOUT2EN    1
    #define CLKOUT2DIV  0
    #define CLKOUT2SRC  0


    /**********************************************************************/
    //Pincntrl Configurations
    #define PINCNTL68                       (CTRL_MODULE_BASE_ADDR + 0x090C)
    #define PINCNTL69                       (CTRL_MODULE_BASE_ADDR + 0x0910)
    #define PINCNTL72                       (CTRL_MODULE_BASE_ADDR + 0x091C)
    #define PINCNTL73                       (CTRL_MODULE_BASE_ADDR + 0x0920)
    #define PINCNTL59                       (CTRL_MODULE_BASE_ADDR + 0x08e8)
    #define PINCNTL60                       (CTRL_MODULE_BASE_ADDR + 0x08ec)
    #define PINCNTL89                       (CTRL_MODULE_BASE_ADDR + 0x0960)
    #define PINCNTL90                       (CTRL_MODULE_BASE_ADDR + 0x0964)
    #define PINCNTL91                       (CTRL_MODULE_BASE_ADDR + 0x0968)
    #define PINCNTL92                       (CTRL_MODULE_BASE_ADDR + 0x096C)
    #define PINCNTL93                       (CTRL_MODULE_BASE_ADDR + 0x0970)
    #define PINCNTL94                       (CTRL_MODULE_BASE_ADDR + 0x0974)
    #define PINCNTL95                       (CTRL_MODULE_BASE_ADDR + 0x0978)
    #define PINCNTL96                       (CTRL_MODULE_BASE_ADDR + 0x097C)
    #define PINCNTL97                       (CTRL_MODULE_BASE_ADDR + 0x0980)
    #define PINCNTL98                       (CTRL_MODULE_BASE_ADDR + 0x0984)
    #define PINCNTL99                       (CTRL_MODULE_BASE_ADDR + 0x0988)
    #define PINCNTL100                      (CTRL_MODULE_BASE_ADDR + 0x098C)
    #define PINCNTL101                      (CTRL_MODULE_BASE_ADDR + 0x0990)
    #define PINCNTL102                      (CTRL_MODULE_BASE_ADDR + 0x0994)
    #define PINCNTL103                      (CTRL_MODULE_BASE_ADDR + 0x0998)
    #define PINCNTL104                      (CTRL_MODULE_BASE_ADDR + 0x099C)

    #define PINCNTL105                      (CTRL_MODULE_BASE_ADDR + 0x09A0)
    #define PINCNTL106                      (CTRL_MODULE_BASE_ADDR + 0x09A4)
    #define PINCNTL107                      (CTRL_MODULE_BASE_ADDR + 0x09A8)
    #define PINCNTL108                      (CTRL_MODULE_BASE_ADDR + 0x09AC)
    #define PINCNTL109                      (CTRL_MODULE_BASE_ADDR + 0x09B0)
    #define PINCNTL110                      (CTRL_MODULE_BASE_ADDR + 0x09B4)
    #define PINCNTL111                      (CTRL_MODULE_BASE_ADDR + 0x09B8)
    #define PINCNTL112                      (CTRL_MODULE_BASE_ADDR + 0x09BC)
    #define PINCNTL122                      (CTRL_MODULE_BASE_ADDR + 0x09E4)
    #define PINCNTL123                      (CTRL_MODULE_BASE_ADDR + 0x09E8)
    #define PINCNTL124                      (CTRL_MODULE_BASE_ADDR + 0x09EC)
    #define PINCNTL125                      (CTRL_MODULE_BASE_ADDR + 0x09F0)
    #define PINCNTL126                      (CTRL_MODULE_BASE_ADDR + 0x09F4)
    #define PINCNTL127                      (CTRL_MODULE_BASE_ADDR + 0x09F8)
    #define PINCNTL128                      (CTRL_MODULE_BASE_ADDR + 0x09FC)
    #define PINCNTL129                      (CTRL_MODULE_BASE_ADDR + 0x0A00)
    #define PINCNTL130                      (CTRL_MODULE_BASE_ADDR + 0x0A04)
    #define PINCNTL131                      (CTRL_MODULE_BASE_ADDR + 0x0A08)
    #define PINCNTL132                      (CTRL_MODULE_BASE_ADDR + 0x0A0C)
    #define PINCNTL133                      (CTRL_MODULE_BASE_ADDR + 0x0A10)
    #define PINCNTL235                      (CTRL_MODULE_BASE_ADDR + 0x0BA8)
    #define PINCNTL243                      (CTRL_MODULE_BASE_ADDR + 0x0BC8)
    #define PINCNTL244                      (CTRL_MODULE_BASE_ADDR + 0x0BCC)
    #define PINCNTL245                      (CTRL_MODULE_BASE_ADDR + 0x0BD0)
    #define PINCNTL246                      (CTRL_MODULE_BASE_ADDR + 0x0BD4)
    #define PINCNTL247                      (CTRL_MODULE_BASE_ADDR + 0x0BD8)
    #define PINCNTL248                      (CTRL_MODULE_BASE_ADDR + 0x0BDC)
    #define PINCNTL249                      (CTRL_MODULE_BASE_ADDR + 0x0BE0)
    #define PINCNTL250                      (CTRL_MODULE_BASE_ADDR + 0x0BE4)
    #define PINCNTL251                      (CTRL_MODULE_BASE_ADDR + 0x0BE8)
    #define PINCNTL252                      (CTRL_MODULE_BASE_ADDR + 0x0BEC)
    #define PINCNTL253                      (CTRL_MODULE_BASE_ADDR + 0x0BF0)
    #define PINCNTL254                      (CTRL_MODULE_BASE_ADDR + 0x0BF4)
    #define PINCNTL255                      (CTRL_MODULE_BASE_ADDR + 0x0BF8)
    #define PINCNTL256                      (CTRL_MODULE_BASE_ADDR + 0x0BFC)
    #define PINCNTL257                      (CTRL_MODULE_BASE_ADDR + 0x0C00)
    #define PINCNTL258                      (CTRL_MODULE_BASE_ADDR + 0x0C04)
        #define PINCNTL259                      (CTRL_MODULE_BASE_ADDR + 0x0C08)


/****************** PLL Configuration ******************************************/

      /***    PLL,Control Base Adress  Base Address   ***********/
      #define PLL_BASE_ADDRESS                           0x481C5000
      #define CONTROL_BASE_ADDRESS                       0x48140000
      #define OSC_SRC_CTRL                              (PLL_BASE_ADDRESS+0x02c0)
      #define ARM_SRC_CLK                               (PLL_BASE_ADDRESS+0x02c4)
      #define CLKOUT_MUX                                (PLL_BASE_ADDRESS + 0x02e4)

      /* Clock Out */
      #define MODENAPLL_CLKCTRL                     (PLL_BASE_ADDRESS + 0x004c)
      #define PLLSS_MMR_LOCK                        (PLL_BASE_ADDRESS + 0x0040)
      //#define CLKOUT_MUX                      (PLL_BASE_ADDRESS + 0x02e4)

      /***    Top Level ADPLLJ  Base Address   ***********/
      #define L3_PLL_BASE                               (PLL_BASE_ADDRESS+0x110)
      #define HDVICP_PLL_BASE                           (PLL_BASE_ADDRESS+0x0E0)
      #define DSS_PLL_BASE                              (PLL_BASE_ADDRESS+0x170)
      #define ISS_PLL_BASE                              (PLL_BASE_ADDRESS+0x140)
      #define USB_PLL_BASE                              (PLL_BASE_ADDRESS+0x260)
      #define AUDIO_PLL_BASE                            (PLL_BASE_ADDRESS+0x230)
      #define VIDEO_0_PLL_BASE                          (PLL_BASE_ADDRESS+0x1A0)
      #define VIDEO_1_PLL_BASE                          (PLL_BASE_ADDRESS+0x1D0)
      #define HDMI_PLL_BASE                             (PLL_BASE_ADDRESS+0x200)
      #define DDR_PLL_BASE                              (PLL_BASE_ADDRESS+0x290)

        /********** ADPLL intrnal Offset Registers  ***********/
      #define CLKCTRL                           0x4
      #define TENABLE                           0x8
      #define TENABLEDIV                            0xC
      #define M2NDIV                            0x10
      #define MN2DIV                            0x14
      #define STATUS                            0x24

        /*********** MODENA ADPLLS REGISTERS  *********/
        #define MODENAPLL_CLKCTRL                   (PLL_BASE_ADDRESS+0x04c)
      #define MODENAPLL_TENABLE                     (PLL_BASE_ADDRESS+0x050)
      #define MODENAPLL_TENABLEDIV                      (PLL_BASE_ADDRESS+0x054)
      #define MODENAPLL_M2NDIV                      (PLL_BASE_ADDRESS+0x058)
      #define MODENAPLL_MN2DIV                      (PLL_BASE_ADDRESS+0x05c)
      #define MODENAPLL_STATUS                      (PLL_BASE_ADDRESS+0x06c)

     /********   SATA0 PLL REGISTERS   **************/
      #define SATA0_PLLCFG0                             (CONTROL_BASE_ADDRESS+0x720)
      #define SATA0_PLLCFG1                             (CONTROL_BASE_ADDRESS+0x724)
      #define SATA0_PLLCFG2                             (CONTROL_BASE_ADDRESS+0x728)
      #define SATA0_PLLCFG3                             (CONTROL_BASE_ADDRESS+0x72c)
      #define SATA0_PLLCFG4                             (CONTROL_BASE_ADDRESS+0x730)
      #define SATA0_PLLSTATUS                           (CONTROL_BASE_ADDRESS+0x734)
      #define SATA0_RXSTATUS                            (CONTROL_BASE_ADDRESS+0x738)
      #define SATA0_TXSTATUS                            (CONTROL_BASE_ADDRESS+0x73c)

     /********   SATA1 PLL REGISTERS   **************/
      #define SATA1_PLLCFG0                             (CONTROL_BASE_ADDRESS+0x74C)
      #define SATA1_PLLCFG1                             (CONTROL_BASE_ADDRESS+0x750)
      #define SATA1_PLLCFG2                             (CONTROL_BASE_ADDRESS+0x754)
      #define SATA1_PLLCFG3                             (CONTROL_BASE_ADDRESS+0x758)
      #define SATA1_PLLCFG4                             (CONTROL_BASE_ADDRESS+0x75C)
      #define SATA1_PLLSTATUS                           (CONTROL_BASE_ADDRESS+0x760)
      #define SATA1_RXSTATUS                            (CONTROL_BASE_ADDRESS+0x764)
      #define SATA1_TXSTATUS                            (CONTROL_BASE_ADDRESS+0x768)


     /********   PCIE PLL REGISTERS   **************/
      #define PCIE_PLLCFG0                              (CONTROL_BASE_ADDRESS+0x6D8)
      #define PCIE_PLLCFG1                              (CONTROL_BASE_ADDRESS+0x6DC)
      #define PCIE_PLLCFG2                              (CONTROL_BASE_ADDRESS+0x6E0)
      #define PCIE_PLLCFG3                              (CONTROL_BASE_ADDRESS+0x6E4)
      #define PCIE_PLLCFG4                              (CONTROL_BASE_ADDRESS+0x6E8)
      #define PCIE_PLLSTATUS                            (CONTROL_BASE_ADDRESS+0x6EC)
      #define PCIE_RXSTATUS                             (CONTROL_BASE_ADDRESS+0x6F0)
      #define PCIE_TXSTATUS                             (CONTROL_BASE_ADDRESS+0x6F4)
      #define SERDES_REFCLK_CTL                             (CONTROL_BASE_ADDRESS+0xE24)


      #define CONTROL_STATUS                            (CTRL_MODULE_BASE_ADDR + 0x040)
      #define BANDGAP0_TRIM                             (CTRL_MODULE_BASE_ADDR + 0x44C)
      #define BANDGAP1_TRIM                         (CTRL_MODULE_BASE_ADDR + 0x454)
      #define PLL_SUBSYSTEM_BASE_ADDR                       PLL_BASE_ADDRESS
      #define HDVICPPLL_CLOCK_CONTROL                   (PLL_SUBSYSTEM_BASE_ADDR + 0x0E4)
      #define L3PLL_CLOCK_CONTROL                       (PLL_SUBSYSTEM_BASE_ADDR + 0x114)
      #define ISSPLL_CLOCK_CONTROL                      (PLL_SUBSYSTEM_BASE_ADDR + 0x144)
      #define DSSPLL_CLOCK_CONTROL                      (PLL_SUBSYSTEM_BASE_ADDR + 0x174)
      #define VID0PLL_CLOCK_CONTROL                     (PLL_SUBSYSTEM_BASE_ADDR + 0x1A4)
      #define VID1PLL_CLOCK_CONTROL                     (PLL_SUBSYSTEM_BASE_ADDR + 0x1D4)
      #define HDMIPLL_CLOCK_CONTROL                     (PLL_SUBSYSTEM_BASE_ADDR + 0x204)
      #define AUDIOPLL_CLOCK_CONTROL                    (PLL_SUBSYSTEM_BASE_ADDR + 0x234)
      #define USBPLL_CLOCK_CONTROL                      (PLL_SUBSYSTEM_BASE_ADDR + 0x264)
      #define DDRPLL_CLOCK_CONTROL                      (PLL_SUBSYSTEM_BASE_ADDR + 0x294)
      #define MODENAPLL_CLOCK_CONTROL                   (PLL_SUBSYSTEM_BASE_ADDR + 0x04C)


/*************************************************************************************************************
                                 ADPLLJ CLKCNTRL REGISTER CONFIGURATIONS

***************************************************************************************************************/
    // ADPLLJ_CLKCRTL_Register Value Configurations
    #define ADPLLJ_CLKCRTL_HS2                      0x00000801 //HS2 Mode,TINTZ =1  --used by all PLL's except HDMI
    #define ADPLLJ_CLKCRTL_HS1                      0x00001001 //HS1 Mode,TINTZ =1  --used only for HDMI
    #define ADPLLJ_CLKCRTL_CLKDCO                   0x200a0000 // Enable CLKDCOEN,CLKLDOEN,CLKDCOPWDNZ -- used for HDMI,USB





/****************************************************************************************************************
****************************************************************************************************************/



/*******************************************************************************************************
    ****
    ****                                   ********* RANGE ************
    ****   REF_CLK       = (OSC_FREQ)/N+1  [  REF_CLK < 2.5MHz      ]
    ****   DCOCLK_HS2    = (REF_CLK)*M     [500  < DCOCLK < 1000MHz ]
    ****   DCOCLK_HS1    = (REF_CLK)*M     [1000 < DCOCLK < 2000MHz ]--used for HDMI CLKDCO
    ****   CLKOUT        =  DCOCLK/M2      [10   < CLKOUT < 2000MHz ]
    ****   N+1                             [1..256]
    ****   M                               [2..4095]
    ****   M2                              [1..127]
    ****
    ****
    ******************************************************************************************************/

/***************************************************************

 **** PLEASE DONT CHANGE THE BELOW CONFIGURED VALUES OF PLL_SETUP *****

   IF NOT required do not call ALL_ADPLL_CLOCKS_ENABLE function(hotmenu)

***************************************************************/

    int HSMODE,CLKOUT = 0;

    PLL_SETUP(){
            //pll_name (CLKINP,N , M, M2);
            cmdMPUPLL(CLKIN,1, 60 ,1);

            cmdL3PLL(CLKIN,19,800,4);

            cmdDSSPLL(CLKIN,19, 800, 4);

            cmdISSPLL(CLKIN,19, 800 ,2);

            cmdHDVICPPLL(CLKIN,19, 532, 2);

            cmdUSBPLL(CLKIN,19,960,5);

            cmdVIDEO0PLL(CLKIN,19, 540,10);

            cmdVIDEO1PLL(CLKIN,19, 594,4);

            cmdHDMIPLL(CLKIN,19, 1485,10);

            cmdDDRPLL(CLKIN,19,DDR_FREQ, 2); //DDR PLL config now done as a part of DDR hotmenus

            cmdAUDIOPLL(CLKIN,19,800,4);

            //cmdSATA0_PLL();

            //cmdSATA1_PLL();

            //cmdPCIEPLL();

        }

     cmdMPUPLL(int CLKIN,int N, int M, int M2)
        {
            MODENA_PLL_Config(CLKIN,N,M,M2);
              GEL_TextOut("\t MODENA ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }

     cmdL3PLL(int CLKIN,int N, int M, int M2)
        {
            DCOCLK_COMP(CLKIN,N,M);
            if(HSMODE == 2)
            {
            PLL_Clocks_Config(L3_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
            GEL_TextOut("\t L3  ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
            }
                else if (HSMODE == 1)
                {
                PLL_Clocks_Config(L3_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
                    GEL_TextOut("\t L3  ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
                }
                else
                {
            GEL_TextOut("\t L3 PLL NOT Configured.Wrong DCOCLK Output\n");
            }

        }

    cmdDSSPLL(int CLKIN, int N, int M, int M2)
        {
                DCOCLK_COMP(CLKIN,N,M);
            if(HSMODE == 2)
            {
                PLL_Clocks_Config(DSS_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
                GEL_TextOut("\t DSS ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
            }
                else if (HSMODE == 1)
                {
                PLL_Clocks_Config(DSS_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
                GEL_TextOut("\t DSS ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
                }
                else
                {
                          GEL_TextOut("\t DSS PLL NOT Configured.Wrong DCOCLK Output\n");
                }

        }

     cmdHDVICPPLL(int CLKIN,int N, int M, int M2)
        {
                DCOCLK_COMP(CLKIN,N,M);
            if(HSMODE == 2)
            {
                PLL_Clocks_Config(HDVICP_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
                GEL_TextOut("\t HDVICP ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
            }
                    else if (HSMODE == 1)
                {
                PLL_Clocks_Config(HDVICP_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
                GEL_TextOut("\t HDVICP ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
            }
                else
                {
                    GEL_TextOut("\t HDVICP PLL NOT Configured.Wrong DCOCLK Output\n");
                }
        }

    cmdISSPLL(int CLKIN,int N, int M, int M2)
    {
            DCOCLK_COMP(CLKIN,N,M);
            if(HSMODE == 2)
            {
                PLL_Clocks_Config(ISS_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
                    GEL_TextOut("\t ISS ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
                }
                else if (HSMODE == 1)
                {
                PLL_Clocks_Config(ISS_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
                GEL_TextOut("\t ISS ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
            }
                else
                {
                    GEL_TextOut("\t ISS PLL NOT Configured.Wrong DCOCLK Output\n");
                }

    }
    // enabling the CLKOUTDCO,CLKDCOLDO
    cmdUSBPLL(int CLKIN,int N, int M, int M2)
    {
            DCOCLK_COMP(CLKIN,N,M);
            if(HSMODE == 2)
            {
                PLL_Clocks_Config(USB_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2+ADPLLJ_CLKCRTL_CLKDCO);
                GEL_TextOut("\t USB ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
            }
                else if (HSMODE == 1)
            {
                PLL_Clocks_Config(USB_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1+ADPLLJ_CLKCRTL_CLKDCO);
                GEL_TextOut("\t USB ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
            }
            else
                {
                GEL_TextOut("\t USB PLL NOT Configured.Wrong DCOCLK Output\n");
                }

    }

    cmdVIDEO0PLL(int CLKIN,int N, int M, int M2)
    {
            DCOCLK_COMP(CLKIN,N,M);
            if(HSMODE == 2)
            {
                PLL_Clocks_Config(VIDEO_0_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
                    GEL_TextOut("\t VIDEO-0 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
                }
                else if (HSMODE == 1)
                {
                PLL_Clocks_Config(VIDEO_0_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
                GEL_TextOut("\t VIDEO-0 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
                }
            else
            {
                GEL_TextOut("\t VIDEO-0 PLL NOT Configured.Wrong DCOCLK Output\n");
            }
    }

    cmdVIDEO1PLL(int CLKIN,int N, int M, int M2)
    {
            DCOCLK_COMP(CLKIN,N,M);
            if(HSMODE == 2)
            {
                PLL_Clocks_Config(VIDEO_1_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
                GEL_TextOut("\t VIDEO-1 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
            }
                else if (HSMODE == 1)
                {
                PLL_Clocks_Config(VIDEO_1_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
                    GEL_TextOut("\t VIDEO-1 ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
                }
            else
            {
                GEL_TextOut("\t VIDEO-1 PLL NOT Configured.Wrong DCOCLK Output\n");
                }

    }

    cmdHDMIPLL(int CLKIN,int N, int M, int M2)
    {
            DCOCLK_COMP(CLKIN,N,M);
            if(HSMODE == 2)
            {
                PLL_Clocks_Config(HDMI_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2+ADPLLJ_CLKCRTL_CLKDCO);
                GEL_TextOut("\t VIDEO-2/HDMI ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
            }
            else if (HSMODE == 1)
            {
                PLL_Clocks_Config(HDMI_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1+ADPLLJ_CLKCRTL_CLKDCO);
                GEL_TextOut("\t VIDEO-2/HDMI ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
            }
            else
            {
                GEL_TextOut("\t VIDEO-2/HDMI PLL NOT Configured.Wrong DCOCLK Output\n");
            }
    }

    cmdDDRPLL(int CLKIN,int N, int M, int M2)
    {
        DCOCLK_COMP(CLKIN,N,M);
        if(HSMODE == 2)
        {
            PLL_Clocks_Config(DDR_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
                GEL_TextOut("\t DDR ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
            else if (HSMODE == 1)
            {
            PLL_Clocks_Config(DDR_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
            GEL_TextOut("\t DDR ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
            else
            {
                GEL_TextOut("\t DDR PLL NOT Configured.Wrong DCOCLK Output\n");
                }

    }

    cmdAUDIOPLL(int CLKIN,int N, int M, int M2)
    {
        DCOCLK_COMP(CLKIN,N,M);
        if(HSMODE == 2)
        {
            PLL_Clocks_Config(AUDIO_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS2);
            GEL_TextOut("\t AUDIO ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else if (HSMODE == 1)
        {
            PLL_Clocks_Config(AUDIO_PLL_BASE,CLKIN,N,M,M2,ADPLLJ_CLKCRTL_HS1);
            GEL_TextOut("\t AUDIO ADPLLJ CLKOUT  value is  = %d \n",,,,,CLKOUT);
        }
        else
        {
            GEL_TextOut("\t AUDIO PLL NOT Configured.Wrong DCOCLK Output\n");
        }
    }


menuitem "DM385 INDIVIDUAL PLL Config"

int CLKIN = 20;

//cmdxxxxPLL(int CLKIN,int N, int M, int M2)
    hotmenu MPU_PLL_CONFIG()
    {
        GEL_TextOut("\t ****  DM385 MPU ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
        cmdMPUPLL(CLKIN,1,60,1);

    }

    hotmenu L3_PLL_Config()
    {
        GEL_TextOut("\t ****  DM385 L3 ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
        cmdL3PLL(CLKIN,19, 800, 4);
        //GEL_TextOut("\t ****  DM385 L3 ADPLL INIT IS Done ......... \n","Output",1,1,1);
    }

    hotmenu DSS_PLL_Config()
    {
         GEL_TextOut("\t ****  DM385 DSS ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
         cmdDSSPLL(CLKIN,19, 600, 4);
         //GEL_TextOut("\t ****  DM385 DSS ADPLL INIT IS Done ......... \n","Output",1,1,1);
    }

    hotmenu HDVICP_PLL_Config()
    {
        GEL_TextOut("\t ****  DM385 HDVICP ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
        cmdHDVICPPLL(CLKIN,19, 532, 2);
        //GEL_TextOut("\t ****  DM385 HDVICP ADPLL INIT IS Done ......... \n","Output",1,1,1);
    }
hotmenu HDMI_PLL_Config_1_485_GHz()
{
	GEL_TextOut("\t ****  CENTAURUS2 HDMI ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
	cmdHDMIPLL(CLKIN,19, 1485,10);
	//GEL_TextOut("\t ****  CENTAURUS2 HDMI ADPLL INIT IS Done ......... \n","Output",1,1,1);
}

hotmenu HDMI_PLL_Config_742_5_MHz()
{
	GEL_TextOut("\t ****  CENTAURUS2 HDMI ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
	cmdHDMIPLL(CLKIN,19, 745,10);
	//GEL_TextOut("\t ****  CENTAURUS2 HDMI ADPLL INIT IS Done ......... \n","Output",1,1,1);
}


    hotmenu ISS_PLL_Config()
    {
        GEL_TextOut("\t ****  DM385 ISS ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
        cmdISSPLL(CLKIN,19, 800 ,2);
        //GEL_TextOut("\t ****  DM385 ISS ADPLL INIT IS Done ......... \n","Output",1,1,1);
    }

    hotmenu USB_PLL_Config()
    {
        GEL_TextOut("\t ****  DM385 USB ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
        cmdUSBPLL(CLKIN,19, 960 ,5);
        //GEL_TextOut("\t ****  DM385 USB ADPLL INIT IS Done ......... \n","Output",1,1,1);
    }

    hotmenu VIDEO_0_PLL_Config()
    {
        GEL_TextOut("\t ****  DM385 VIDEO-0 ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
        cmdVIDEO0PLL(CLKIN,19, 540,10);
        //GEL_TextOut("\t ****  DM385 VIDEO-0 ADPLL INIT IS Done ......... \n","Output",1,1,1);
    }

    hotmenu VIDEO_1_PLL_Config()
    {
        GEL_TextOut("\t ****  DM385 VIDEO-1 ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
        cmdVIDEO1PLL(CLKIN,19, 600,4);
        //GEL_TextOut("\t ****  DM385 VIDEO-1 ADPLL INIT IS Done ......... \n","Output",1,1,1);
    }

    hotmenu HDMI_PLL_Config()
    {
        GEL_TextOut("\t ****  DM385 HDMI ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
        cmdHDMIPLL(CLKIN,19, 1485,10);
		GEL_TextOut("\t ****  DM385 HDMI ADPLL INIT IS Done ......... \n","Output",1,1,1);
    }

    hotmenu AUDIO_PLL_Config()
    {
        GEL_TextOut("\t ****  DM385 AUDIO ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
        cmdAUDIOPLL(CLKIN,19,800,4);
        //GEL_TextOut("\t ****  DM385 AUDIO ADPLL INIT IS Done ......... \n","Output",1,1,1);
    }

    hotmenu DDR_PLL_Config()
    {
        GEL_TextOut("\t ****  DM385 DDR ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
        cmdDDRPLL(CLKIN,19,DDR_FREQ, 2);
        //GEL_TextOut("\t ****  DM385 DDR ADPLL INIT IS Done ......... \n","Output",1,1,1);
    }
    hotmenu SATA0_PLL_Config()
    {
        GEL_TextOut("\t ****  DM385 SATA0 PLL INIT IS In Progress ......... \n","Output",1,1,1);
        cmdSATA0_PLL();
        GEL_TextOut("\t ****  DM385 SATA0 PLL INIT IS DONE  ********* \n","Output",1,1,1);

    }
    hotmenu SATA1_PLL_Config()
    {
        GEL_TextOut("\t ****  DM385 SATA1 PLL INIT IS In Progress ......... \n","Output",1,1,1);
        cmdSATA1_PLL();
        GEL_TextOut("\t ****  DM385 SATA1 PLL INIT IS DONE  ********* \n","Output",1,1,1);

    }
    hotmenu PCIE_PLL_Config(){
        GEL_TextOut("\t ****  DM385 PCIE PLL INIT IS In Progress ......... \n","Output",1,1,1);
        cmdPCIEPLL();
        GEL_TextOut("\t ****  DM385 PCIE PLL INIT IS DONE  ********* \n","Output",1,1,1);

    }

//PLL program sequence to get 125Mhz ethernet clockout.
    cmdSATA0_PLL()
    {
        GEL_TextOut("\t **** SATA0 PLL INIT IS In Progress Please wait ..... \n","Output",1,1,1);
        WR_MEM_32(SATA0_PLLCFG0, 0x00000004);   //cfgpll0
        wait_delay(35);
        WR_MEM_32(SATA0_PLLCFG1, 0xC12C003C);   //cfgpll1
        WR_MEM_32(SATA0_PLLCFG3, 0x004008E0);   //cfgpll3
        wait_delay(850);
         //wait for bias to be stable --50us
        WR_MEM_32(SATA0_PLLCFG0, 0x00000014);   //cfgpll0
        wait_delay(850);
        WR_MEM_32(SATA0_PLLCFG0, 0x00000016);   //cfgpll0
        wait_delay(60);
        WR_MEM_32(SATA0_PLLCFG0, 0xC0000016);   //cfgpll0 -----why 2 times???????
        wait_delay(2000);
        WR_MEM_32(SATA0_PLLCFG0, 0xC0000017);   //cfgpll0
        //poll the status field to check if pll lock occured.
        while ((RD_MEM_32(SATA0_PLLSTATUS) & 0x1) != 0x1);
        GEL_TextOut("\t **** SATA0 PLL INIT IS In DONE ***************** \n","Output",1,1,1);

    }


//PLL program sequence to get 125Mhz ethernet clockout.
    cmdSATA1_PLL()
    {
        GEL_TextOut("\t **** SATA1 PLL INIT IS In Progress Please wait ..... \n","Output",1,1,1);
        WR_MEM_32(SATA1_PLLCFG0, 0x00000004);   //cfgpll0
        wait_delay(35);
        WR_MEM_32(SATA1_PLLCFG1, 0xC12C003C);   //cfgpll1
        WR_MEM_32(SATA1_PLLCFG3, 0x004008E0);   //cfgpll3
        wait_delay(850);
         //wait for bias to be stable --50us
        WR_MEM_32(SATA1_PLLCFG0, 0x00000014);   //cfgpll0
        wait_delay(850);
        WR_MEM_32(SATA1_PLLCFG0, 0x00000016);   //cfgpll0
        wait_delay(60);
        WR_MEM_32(SATA1_PLLCFG0, 0xC0000016);   //cfgpll0 -----why 2 times???????
        wait_delay(2000);
        WR_MEM_32(SATA1_PLLCFG0, 0xC0000017);   //cfgpll0
        //poll the status field to check if pll lock occured.
        while ((RD_MEM_32(SATA1_PLLSTATUS) & 0x1) != 0x1);
        GEL_TextOut("\t **** SATA1 PLL INIT IS In DONE ***************** \n","Output",1,1,1);

    }

//pci express pll sequence
    cmdPCIEPLL()
    {
        GEL_TextOut("\t **** PCIE PLL INIT IS In Progress Please wait ..... \n","Output",1,1,1);
        WR_MEM_32(SERDES_REFCLK_CTL,0x00000002); //PowerDown 0x00000000-centaurus1
        WR_MEM_32(PCIE_PLLCFG0,0x00000000); //cfgpll0
        WR_MEM_32(PCIE_PLLCFG1,0x00640000); //cfgpll1
        WR_MEM_32(PCIE_PLLCFG2,0x00000000); //cfgpll2
        WR_MEM_32(PCIE_PLLCFG3,0x004008E0); //cfgpll3
        WR_MEM_32(PCIE_PLLCFG4,0x0000609C); //cfgpll4

        //WR_MEM_32(0x48141318,0x00000E7B); //pcie_serdes_cfg_misc DM385 commented
        wait_delay(3); // Wait 100 ns
        WR_MEM_32(PCIE_PLLCFG0,0x00000004); //Config PLL CFG0 bit [2] - ENBGSC_REF
        wait_delay(3); // Wait 250 ns
        WR_MEM_32(PCIE_PLLCFG0,0x00000014); //Config PLL CFG0 bit [4] - DIGLDO
        wait_delay(3); // Wait 200 ns
        WR_MEM_32(PCIE_PLLCFG0,0x00000016); //Config PLL CFG0 bit [1] - ENPLLLDO
        wait_delay(3); // Wait 200 ns
        WR_MEM_32(PCIE_PLLCFG0,0x30000016); // Configure proxy TXLDO and RXLDO enables (Centaurus ECO 3/30/10)
        wait_delay(3); // Wait 200 ns
        WR_MEM_32(PCIE_PLLCFG0,0x70007016); // Configure multiplier
        wait_delay(3); // Wait 200 ns
        WR_MEM_32(PCIE_PLLCFG0,0x70007017);  // Enable PLL
        wait_delay(3); // Wait 200 ns
         //poll the status field to check if pll lock occured.
        while ((RD_MEM_32(PCIE_PLLSTATUS) & 0x1 )!= 0x1);
        GEL_TextOut("\t **** PCIE PLL INIT IS In DONE ***************** \n","Output",1,1,1);
    }

    wait_delay(UWORD32 noopcount)
     {
     int i;
      for(i=0;i<noopcount;i++)
      {
      }
     }


    PLL_Clocks_Config(UWORD32 Base_Address,UWORD32 CLKIN,UWORD32 N,UWORD32 M,UWORD32 M2,UWORD32 CLKCTRL_VAL)
    {
        UWORD32 m2nval,mn2val,read_clkctrl,clk_out,ref_clk,clkout_dco = 0;
        m2nval = (M2<<16) | N;
        mn2val =  M;
        ref_clk     = CLKIN/(N+1);
        clkout_dco  = ref_clk*M;
        clk_out     = clkout_dco/M2;
        WR_MEM_32(Base_Address+CLKCTRL, RD_MEM_32(Base_Address+CLKCTRL)|0x00800000);
        while (( (RD_MEM_32(Base_Address+STATUS)) & 0x00000101) != 0x00000101);
        WR_MEM_32(Base_Address+CLKCTRL, RD_MEM_32(Base_Address+CLKCTRL)& 0xfffffffe);
        wait_delay(3);
        WR_MEM_32((Base_Address+M2NDIV    ),m2nval);
        WR_MEM_32((Base_Address+MN2DIV    ),mn2val);
        wait_delay(3);
        WR_MEM_32((Base_Address+TENABLEDIV),0x1);
        wait_delay(3);
        WR_MEM_32((Base_Address+TENABLEDIV),0x0);
        wait_delay(3);
        WR_MEM_32((Base_Address+TENABLE   ),0x1);
        wait_delay(3);
        WR_MEM_32((Base_Address+TENABLE   ),0x0);
        wait_delay(3);
        read_clkctrl = RD_MEM_32(Base_Address+CLKCTRL);
        //configure the TINITZ(bit0) and CLKDCO BITS IF REQUIRED
        WR_MEM_32(Base_Address+CLKCTRL,(read_clkctrl & 0xff7fe3ff) | CLKCTRL_VAL);
        read_clkctrl = RD_MEM_32(Base_Address+CLKCTRL);
        // poll for the freq,phase lock to occur
        while (( (RD_MEM_32(Base_Address+STATUS)) & 0x00000600) != 0x00000600);
        //wait fot the clocks to get stabized
        wait_delay(10);
        CLKOUT    = clk_out;
    }




     MODENA_PLL_Config(UWORD32 CLKIN,UWORD32 N,UWORD32 M,UWORD32 M2)
    {
        UWORD32 rval_ctrl,ref_clk,clk_out = 0;
        UWORD32 m2nval,mn2val = 0;
        ref_clk     = CLKIN/(N+1);
        clk_out     = (ref_clk*M)/M2;

        m2nval = (M2<<16) | N; //need to check the bit position of M2
        mn2val =  M;
        WR_MEM_32(MODENAPLL_M2NDIV      ,m2nval);
        WR_MEM_32(MODENAPLL_MN2DIV      ,mn2val);
        WR_MEM_32(MODENAPLL_TENABLEDIV  ,0x1);
        wait_delay(3);
        WR_MEM_32(MODENAPLL_TENABLEDIV  ,0x0);
        wait_delay(3);
        WR_MEM_32(MODENAPLL_TENABLE     ,0x1);
        wait_delay(3);
        WR_MEM_32(MODENAPLL_TENABLE     ,0x0);
        wait_delay(3);
        rval_ctrl = RD_MEM_32(MODENAPLL_CLKCTRL);
        WR_MEM_32(MODENAPLL_CLKCTRL,(rval_ctrl & 0xff7fffff) | 0x1);
        while (( (RD_MEM_32(MODENAPLL_STATUS)) & 0x00000600) != 0x00000600);
        wait_delay(10);
        CLKOUT = clk_out;

    }

    DCOCLK_COMP(int CLKIN,int N, int M)
    {
        int DCOCLK;
        DCOCLK = (CLKIN/(N+1))*M;

        if(DCOCLK >= 500 && DCOCLK < 1000){
                HSMODE = 2;  //HS2 Mode
        }
        else if(DCOCLK >= 1000 && DCOCLK < 2000){
                HSMODE = 1;  //HS1 Mode
        }
        else HSMODE = 0;  //wrong configuration

        //return HSMODE;
    }


    ControlModule_ClkEnable()
    {
        GEL_TextOut("\tPRCM for Control Module in Progress \n","Output",1,1,1);
        /*Enable the  Clocks*/
        WR_MEM_32(CM_CTRL_CLKCTRL,   2);
        while(((RD_MEM_32(CM_CTRL_CLKCTRL)&0x2))!=0x2);
        GEL_TextOut("\tPRCM for Control Module Done \n","Output",1,1,1);
    }

    PrcmOCMCClkEnable()
    {
        unsigned int fail=0, k=0;
        GEL_TextOut("\tPRCM for OCMCRAM0/1 Initialization in Progress \n","Output",1,1,1);
        /*Enable the OCMC0RAM Clocks*/
        WR_MEM_32(CM_ALWON_OCMC_0_CLKSTCTRL, 2);
        WR_MEM_32(CM_ALWON_OCMC_0_CLKCTRL,   2);
        while(((RD_MEM_32(CM_ALWON_OCMC_0_CLKSTCTRL) & 0x100)>>8)!=1);
        while(((RD_MEM_32(CM_ALWON_OCMC_0_CLKCTRL)&0x30000)>>17)!=0);
        GEL_TextOut("\tPRCM for OCMCRAM0 Initialization Done \n","Output",1,1,1);

    }


    /************ Enable the Ducati Clocks ***************/
DucatiClkEnable()
{
	int i;
	GEL_TextOut("\tPRCM for DucatiSS is in Progress ..... \n","Output",1,1,1);

	RD_M_WR_MEM_32(RM_DEFAULT_RSTCTRL,   0x0C, 0xFFFFFFE3); /*Enable the Ducati Logic*/
	WR_MEM_32(CM_DEFAULT_DUCATI_CLKSTCTRL, 2); /*Enable Power Domain Transition*/
	WR_MEM_32(CM_DEFAULT_DUCATI_CLKCTRL,   2); /*Enable Ducati Clocks*/

	/*Check CLKIN200TR & CLKINTR  are active*/
	while(((RD_MEM_32(CM_DEFAULT_DUCATI_CLKSTCTRL)&0x300)>>8)!=3) ;
	GEL_TextOut("\tClock is Active  \n","Output",1,1,1);

	/*Write Ducate IRAM Boot Image */
	WR_MEM_32(DUCATI_BASE_ADDR,       0x10000);
	WR_MEM_32(DUCATI_BASE_ADDR+0x4,   0x9);
	WR_MEM_32(DUCATI_BASE_ADDR+0x8,   0xE7FEE7FE);
	//  GEL_TextOut("\tAfter RAM written  \n","Output",1,1,1);

	/*Large Page Translations */
	WR_MEM_32(DUCATI_MMU_CFG+0x800,         0x40000000);
	WR_MEM_32(DUCATI_MMU_CFG+0x804,         0x80000000);
	WR_MEM_32(DUCATI_MMU_CFG+0x808,         0xA0000000);
	WR_MEM_32(DUCATI_MMU_CFG+0x80C,         0x60000000);

	WR_MEM_32(DUCATI_MMU_CFG+0x820,         0x40000000);
	WR_MEM_32(DUCATI_MMU_CFG+0x824,         0x80000000);
	WR_MEM_32(DUCATI_MMU_CFG+0x828,         0xA0000000);
	WR_MEM_32(DUCATI_MMU_CFG+0x82C,         0x60000000);

	WR_MEM_32(DUCATI_MMU_CFG+0x840,         0x00000007);
	WR_MEM_32(DUCATI_MMU_CFG+0x844,         0x000B0007);
	WR_MEM_32(DUCATI_MMU_CFG+0x848,         0x00020007);
	WR_MEM_32(DUCATI_MMU_CFG+0x84C,         0x00020007);

	/*Medium Page*/
	WR_MEM_32(DUCATI_MMU_CFG+0x860,         0x00300000);
	WR_MEM_32(DUCATI_MMU_CFG+0x864,         0x00400000);

	WR_MEM_32(DUCATI_MMU_CFG+0x8A0,         0x40300000);
	WR_MEM_32(DUCATI_MMU_CFG+0x8A4,         0x40400000);

	WR_MEM_32(DUCATI_MMU_CFG+0x8E0,         0x00000007);
	WR_MEM_32(DUCATI_MMU_CFG+0x8E4,         0x00020007);

	/*Small Page*/
	WR_MEM_32(DUCATI_MMU_CFG+0x920,         0x00000000);
	WR_MEM_32(DUCATI_MMU_CFG+0x924,         0x40000000);
	WR_MEM_32(DUCATI_MMU_CFG+0x928,         0x00004000);
	WR_MEM_32(DUCATI_MMU_CFG+0x92C,         0x00008000);
	WR_MEM_32(DUCATI_MMU_CFG+0x930,         0x0000C000);

	WR_MEM_32(DUCATI_MMU_CFG+0x9A0,         0x55020000);
	WR_MEM_32(DUCATI_MMU_CFG+0x9A4,         0x55080000);
	WR_MEM_32(DUCATI_MMU_CFG+0x9A8,         0x55024000);
	WR_MEM_32(DUCATI_MMU_CFG+0x9AC,         0x55028000);
	WR_MEM_32(DUCATI_MMU_CFG+0x9B0,         0x5502C000);

	WR_MEM_32(DUCATI_MMU_CFG+0xA20,         0x0001000B);
	WR_MEM_32(DUCATI_MMU_CFG+0xA24,         0x0000000B);
	WR_MEM_32(DUCATI_MMU_CFG+0xA28,         0x00010007);
	WR_MEM_32(DUCATI_MMU_CFG+0xA2C,         0x00000007);
	WR_MEM_32(DUCATI_MMU_CFG+0xA30,         0x00000007);
	GEL_TextOut("\tDUCATI MMU has been configured. User is advised to modify the mapping as needed...\n","Output",1,1,1);

	RD_M_WR_MEM_32(RM_DEFAULT_RSTCTRL,   0x00, 0xFFFFFFE3);
	/*Check for Ducati M3_0 & M3_1 out of Reset*/
	while(((RD_MEM_32(RM_DEFAULT_RSTST)&0x1C))!=0x1C) ;

	/*Check Module is in Functional Mode */
	while(((RD_MEM_32(CM_DEFAULT_DUCATI_CLKCTRL)&0x30000)>>16)!=0) ;

	GEL_TextOut("\tPRCM for DucatiSS is Done Successfully ******** \n","Output",1,1,1);
	GEL_TextOut("\tUser Can Connect to DUCATI M3s....\n","Output",1,1,1);

}


    HDVICPClkEnable()
    {
        GEL_TextOut("\tPRCM for HDVICP is in Progress, Please wait.....  \n","Output",1,1,1);
        WR_MEM_32(CM_HDVICP_CLKSTCTRL,      2); /*Enable Power Domain Transition*/
        while(RD_MEM_32(PM_HDVICP_PWRSTST)!=0x37);  /*Check Power is ON*/
        WR_MEM_32(CM_HDVICP_CLKCTRL,    2); /*Enable HDVICP Clocks*/
        WR_MEM_32(CM_HDVICP_SL2_CLKCTRL,    2); /*Enable HDVICP SL2 Clocks*/

        while(((RD_MEM_32(CM_HDVICP_CLKSTCTRL)&0x100))!=0x100); /*HDVICP_GCLK is Active*/

        WR_MEM_32(RM_HDVICP_RSTCTRL,    3); /*Enable HDVICP logic & SL2 */

        while((RD_MEM_32(RM_HDVICP_RSTST)&4)!=4);

        WR_MEM_32(0x58088000, 0xEAFFFFFE); /*Write Self Branch Instruction in ICONT1 ITCM 0 Location*/

        WR_MEM_32(0x58098000, 0xEAFFFFFE); /*Write Self Branch Instruction in ICONT2 ITCM 0 Location*/

        WR_MEM_32(RM_HDVICP_RSTCTRL,    0); /*Bring ICONT1 & ICONT2 out of Reset*/

        while(RD_MEM_32(RM_HDVICP_RSTST)!=7); /*ICONT1 & ICONT2 are out of Reset*/

        GEL_TextOut("\tPRCM for HDVICP is Done Successfully  \n","Output",1,1,1);
        GEL_TextOut("\tUser Can Connect to ICONT1 & ICONT2 of HDVICP  \n","Output",1,1,1);
    }

    GPMC_ClkEnable()
    {
        unsigned int i,data_fail = 0;
        GEL_TextOut("\tEnabling Clock for GPMC is in Progress, Please wait.....  \n","Output",1,1,1);
        WR_MEM_32(CM_ALWON_GPMC_CLKCTRL,    0x2); /*Enable GPMC Clock*/
        while(RD_MEM_32(CM_ALWON_GPMC_CLKCTRL)!=0x2);
        GEL_TextOut("\tGPMC Clock is Active\n","Output",1,1,1);

        GEL_TextOut("Reg default Value: %x \n",,,,,*(unsigned int *)PINCNTL105);

        GEL_TextOut("\tPINMUX configuration is in Progress, Please wait.....  \n","Output",1,1,1);

        WR_MEM_32(PINCNTL235,    RD_MEM_32(PINCNTL235)  | 0x1);
        WR_MEM_32(PINCNTL243,    RD_MEM_32(PINCNTL243)  | 0x10);
        WR_MEM_32(PINCNTL244,    RD_MEM_32(PINCNTL244)  | 0x10);
        WR_MEM_32(PINCNTL245,    RD_MEM_32(PINCNTL245)  | 0x10);
        WR_MEM_32(PINCNTL246,    RD_MEM_32(PINCNTL246)  | 0x10);
        WR_MEM_32(PINCNTL247,    RD_MEM_32(PINCNTL247)  | 0x10);
        WR_MEM_32(PINCNTL248,    RD_MEM_32(PINCNTL248)  | 0x10);
        WR_MEM_32(PINCNTL249,    RD_MEM_32(PINCNTL249)  | 0x10);
        WR_MEM_32(PINCNTL250,    RD_MEM_32(PINCNTL250)  | 0x10);
        WR_MEM_32(PINCNTL251,    RD_MEM_32(PINCNTL251)  | 0x10);
        WR_MEM_32(PINCNTL252,    RD_MEM_32(PINCNTL252)  | 0x10);
        WR_MEM_32(PINCNTL253,    RD_MEM_32(PINCNTL253)  | 0x10);
        WR_MEM_32(PINCNTL254,    RD_MEM_32(PINCNTL254)  | 0x10);
        WR_MEM_32(PINCNTL255,    RD_MEM_32(PINCNTL255)  | 0x10);
        WR_MEM_32(PINCNTL256,    RD_MEM_32(PINCNTL256)  | 0x10);
        WR_MEM_32(PINCNTL257,    RD_MEM_32(PINCNTL257)  | 0x10);
        WR_MEM_32(PINCNTL258,    RD_MEM_32(PINCNTL258)  | 0x10);

        WR_MEM_32(PINCNTL89,    RD_MEM_32(PINCNTL89)    | 0x01);
        WR_MEM_32(PINCNTL90,    RD_MEM_32(PINCNTL90)    | 0x01);
        WR_MEM_32(PINCNTL91,    RD_MEM_32(PINCNTL91)    | 0x01);
        WR_MEM_32(PINCNTL92,    RD_MEM_32(PINCNTL92)    | 0x01);
        WR_MEM_32(PINCNTL93,    RD_MEM_32(PINCNTL93)    | 0x01);
        WR_MEM_32(PINCNTL94,    RD_MEM_32(PINCNTL94)    | 0x01);
        WR_MEM_32(PINCNTL95,    RD_MEM_32(PINCNTL95)    | 0x01);
        WR_MEM_32(PINCNTL96,    RD_MEM_32(PINCNTL96)    | 0x01);
        WR_MEM_32(PINCNTL97,    RD_MEM_32(PINCNTL97)    | 0x01);
        WR_MEM_32(PINCNTL98,    RD_MEM_32(PINCNTL98)    | 0x01);
        WR_MEM_32(PINCNTL99,    RD_MEM_32(PINCNTL99)    | 0x01);
        WR_MEM_32(PINCNTL100,   RD_MEM_32(PINCNTL100)   | 0x01);
        WR_MEM_32(PINCNTL101,   RD_MEM_32(PINCNTL101)   | 0x01);
        WR_MEM_32(PINCNTL102,   RD_MEM_32(PINCNTL102)   | 0x01);
        WR_MEM_32(PINCNTL103,   RD_MEM_32(PINCNTL103)   | 0x01);
        WR_MEM_32(PINCNTL104,   RD_MEM_32(PINCNTL104)   | 0x01);

        WR_MEM_32(PINCNTL105,   RD_MEM_32(PINCNTL105)   | 0x01);
        WR_MEM_32(PINCNTL106,    RD_MEM_32(PINCNTL106)  | 0x01);
        WR_MEM_32(PINCNTL107,    RD_MEM_32(PINCNTL107)  | 0x01);
        WR_MEM_32(PINCNTL108,    RD_MEM_32(PINCNTL108)  | 0x01);
        WR_MEM_32(PINCNTL109,    RD_MEM_32(PINCNTL109)  | 0x01);
        WR_MEM_32(PINCNTL110,    RD_MEM_32(PINCNTL110)  | 0x01);
        WR_MEM_32(PINCNTL111,    RD_MEM_32(PINCNTL111)  | 0x01);
        WR_MEM_32(PINCNTL112,    RD_MEM_32(PINCNTL112)  | 0x01);

        WR_MEM_32(PINCNTL122,    RD_MEM_32(PINCNTL122)  | 0x01);
        WR_MEM_32(PINCNTL123,    RD_MEM_32(PINCNTL123)  | 0x01);
        WR_MEM_32(PINCNTL124,    RD_MEM_32(PINCNTL124)  | 0x01);
        WR_MEM_32(PINCNTL125,    RD_MEM_32(PINCNTL125)  | 0x01);
        WR_MEM_32(PINCNTL126,    RD_MEM_32(PINCNTL126)  | 0x01);
        WR_MEM_32(PINCNTL127,    RD_MEM_32(PINCNTL127)  | 0x01);
        WR_MEM_32(PINCNTL128,    RD_MEM_32(PINCNTL128)  | 0x01);
        WR_MEM_32(PINCNTL129,    RD_MEM_32(PINCNTL129)  | 0x01);
        WR_MEM_32(PINCNTL130,    RD_MEM_32(PINCNTL130)  | 0x01);
        WR_MEM_32(PINCNTL131,    RD_MEM_32(PINCNTL131)  | 0x01);
        WR_MEM_32(PINCNTL132,    RD_MEM_32(PINCNTL132)  | 0x01);
        WR_MEM_32(PINCNTL133,    RD_MEM_32(PINCNTL133)  | 0x01);

        WR_MEM_32(0x50000060,    RD_MEM_32(0x50000060) & 0xFFFFFCFF);// Bit 9:8 make 00, Non multiplex
        WR_MEM_32(0x50000078,    RD_MEM_32(0x50000078) & 0xFFFFFFFC);
        WR_MEM_32(0x50000078,    RD_MEM_32(0x50000078) | 2); // Map to 0x02000000 address

        GEL_TextOut("\tPinmux is configured for Non-Muxed 16 bit SRAM...\n","Output",1,1,1);
        GEL_TextOut("\tGPMC initialization complete...\n","Output",1,1,1);

    }

    mmr_unlock()
    {
        //*(unsigned int *)MODENAPLL_CLKCTRL |= 0x06000000;    // Configure NWELLTRIM  in MODENAPLL_CLKCTRL register
        *(unsigned int *)PLLSS_MMR_LOCK = 0x1EDA4C3D;     // Unlock PLL MMR Region

        *(unsigned int *)MMR_LOCK0 = 0x2FF1AC2B;     // Unlocking MMR lock0
        *(unsigned int *)MMR_LOCK1 = 0xF757FDC0;     // Unlocking MMR lock1
        *(unsigned int *)MMR_LOCK2 = 0xE2BC3A6D;     // Unlocking MMR lock2
        *(unsigned int *)MMR_LOCK3 = 0x1EBF131D;     // Unlocking MMR lock3
        *(unsigned int *)MMR_LOCK4 = 0x6F361E05;     // Unlocking MMR lock4
        GEL_TextOut("\tInitialized Successfully.....  \n","Output",1,1,1);
    }

    int sata_num=0;
    EMAC_SATA0_Clkenable()
    {
        GEL_TextOut("\t **** Configuring EMAC CLOCK SOURCE as SATA0 ***************** \n","Output",1,1,1);
                 WR_MEM_32(0x4814131c, 0x00000000); //cfgpll0
        GEL_TextOut("\t **** EMAC CLOCK SOURCE IS SATA0 ***************** \n","Output",1,1,1);

        GEL_TextOut("SATA Serdes should be powered up to generate the EMAC clock.. Checking..  \n\r");
        if( (RD_MEM_32(SATA0_PLLSTATUS) & 0x1) != 0x1 )
        {
            GEL_TextOut("Error!! SATA Serdes is not configured.. EMAC clocking cannot be enabled \n\r");
        }
        else
        {
            GEL_TextOut("CONFIGURE PRCM CLOCKS of EMAC in progress \n\r");
            *((unsigned int*)(CM_ETHERNET_CLKSTCTRL)) = 0x2;
            *((unsigned int*)(CM_ALWON_ETHERNET_0_CLKCTRL)) = 0x2;
            while(RD_MEM_32(CM_ETHERNET_CLKSTCTRL)!=0x0302);
            while(RD_MEM_32(CM_ALWON_ETHERNET_0_CLKCTRL)!=0x2);
            GEL_TextOut("PRCM CLOCKS of EMAC  is complete \n\r");
        }

    }

    EMAC_SATA1_Clkenable()
    {
        sata_num =1;
        GEL_TextOut("\t **** Configuring EMAC CLOCK SOURCE as SATA1 ***************** \n","Output",1,1,1);
                    WR_MEM_32(0x4814131c, 0x00000400);  //cfgpll0
        GEL_TextOut("\t **** EMAC CLOCK SOURCE IS SATA1 ***************** \n","Output",1,1,1);

        GEL_TextOut("SATA Serdes should be powered up to generate the EMAC clock.. Checking..  \n\r");
        if( (RD_MEM_32(SATA1_PLLSTATUS) & 0x1) != 0x1 )
        {
            GEL_TextOut("Error!! SATA Serdes is not configured.. EMAC clocking cannot be enabled \n\r");
        }
        else
        {
            GEL_TextOut("CONFIGURE PRCM CLOCKS of EMAC in progress \n\r");
            *((unsigned int*)(CM_ETHERNET_CLKSTCTRL)) = 0x2;
            *((unsigned int*)(CM_ALWON_ETHERNET_0_CLKCTRL)) = 0x2;
            while(RD_MEM_32(CM_ETHERNET_CLKSTCTRL)!=0x0302);
            while(RD_MEM_32(CM_ALWON_ETHERNET_0_CLKCTRL)!=0x2);
            GEL_TextOut("PRCM CLOCKS of EMAC  is complete \n\r");
        }

    }


    Clockout_Enable()
    {
        *(unsigned int *)CLKOUT_MUX =0;

        /*  CLKOUT_MUX [19:16] to select source through CLKOUT1 and [3:0] for CLKOUT0
            0000 "Source is PRCM_SYSCLK_OUT"
            0001 "Source is SATA SERDES OBS CLK"
            0010 "Source is PCIe SERDES OBS CLK"
            0011 "Source is DSS_DPLL_OUT_DIV2"
            0100 "Source is ISS_DPLL_OUT_DIV2"
            0101 "Source is L3_DPLL"
            0110 "Source is OSC0 OUT"
            0111 "Source is OSC1 OUT"
            1001 "Reserved"
            1010 "RCOSC32K OUT"
        */
        *(unsigned int *)PINCNTL127 =0x10 ;   // clkout1
        *(unsigned int *)PINCNTL259 =0x4 ;     //clkout0
        *(unsigned int *)CM_CLKOUT_CTRL = ( (CLKOUT2EN << 7) | (CLKOUT2DIV << 3) | (CLKOUT2SRC << 0) );
        GEL_TextOut("\tCentaurus CLOCKOUT pins are enabled.... \n","Output",1,1,1);
    }


    UARTClkEnable()
    {
        GEL_TextOut("\t ***** This GEL function is not yet tested....***** \n");

        GEL_TextOut("\tPRCM for UART0, UART2 and UART2 are in Progress, Please wait.....  \n","Output",1,1,1);

        WR_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Slow Domain Peripheral*/

        WR_MEM_32(CM_ALWON_UART_0_CLKCTRL,    0x2); /*Enable UART0 Clock*/
        while(RD_MEM_32(CM_ALWON_UART_0_CLKCTRL)!=0x2);

        WR_MEM_32(CM_ALWON_UART_1_CLKCTRL,    0x2); /*Enable UART1 Clock*/
        while(RD_MEM_32(CM_ALWON_UART_1_CLKCTRL)!=0x2);

        WR_MEM_32(CM_ALWON_UART_2_CLKCTRL,    0x2); /*Enable UART2 Clock*/
        while(RD_MEM_32(CM_ALWON_UART_2_CLKCTRL)!=0x2);

        while(RD_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL) & 0x2100 !=0x2100);

        GEL_TextOut("\tPRCM for UART0, UART1 and UART2 are Done Successfully.....  \n","Output",1,1,1);
    }

    ISS_ClkEnable()
    {
        WR_MEM_32(PM_ISP_PWRSTCTRL, 0x2);       //PM_ISP_PWRSTCTRL
        WR_MEM_32(RM_ISP_RSTCTRL, 0x3);     //RM_ISP_RSTCTRL
        WR_MEM_32(CM_ISP_CLKSTCTRL, 0x2);       //CM_ISP_CLKSTCTRL
        WR_MEM_32(CM_ISP_ISP_CLKCTRL, 0x2);     //CM_ISP_ISP_CLKCTRL
        WR_MEM_32(CM_ISP_FDIF_CLKCTRL, 0x2);    //CM_ISP_FDIF_CLKCTRL

        GEL_TextOut("\tPRCM for ISS Done Successfully.....  \n","Output",1,1,1);
    }

#define CM_HDVPSS_CLKSTCTRL				(PRCM_BASE_ADDR + 0x0800)
#define CM_HDVPSS_HDVPSS_CLKCTRL		(PRCM_BASE_ADDR + 0x0820)
#define CM_HDVPSS_HDMI_CLKCTRL			(PRCM_BASE_ADDR + 0x0824)

HdvpssClkEnable ()
{
	GEL_TextOut("\t Enabling the HDVPSS Clocks.... \n");
	WR_MEM_32(CM_HDVPSS_CLKSTCTRL,0x2);
	WR_MEM_32(CM_HDVPSS_HDMI_CLKCTRL,0x2);
	WR_MEM_32(CM_HDVPSS_HDVPSS_CLKCTRL,0x2);

	WR_MEM_32(0x48180E00,0x3);
	WR_MEM_32(0x48180E10, 0x0);

	GEL_TextOut("\t CM_HDVPSS_CLKSTCTRL... \n");
	while((RD_MEM_32(CM_HDVPSS_CLKSTCTRL) & 0x100)!=0x100);
	GEL_TextOut("\t CM_HDVPSS_HDMI_CLKCTRL... \n");
	while(RD_MEM_32(CM_HDVPSS_HDMI_CLKCTRL)!=0x2);
	GEL_TextOut("\t CM_HDVPSS_HDVPSS_CLKCTRL... \n");
	while(RD_MEM_32(CM_HDVPSS_HDVPSS_CLKCTRL)!=0x2);
	GEL_TextOut("\t Done Enabling HDVPSS Clock.... \n");
	
	*(unsigned int *)0x48100100 = 0x01031fff;	         // dss module enable
	*(unsigned int *)0x48100114 = (0x9000D);                //venc settings
	*(unsigned int *)0x48100118 = (0xF);
}
#define GPIO2_BASE          	(0x481AC000u)
#define CM_ALWON_GPIO_0_CLKCTRL (PRCM_BASE_ADDR + 0x155C)
#define CM_ALWON_GPIO_1_CLKCTRL (PRCM_BASE_ADDR + 0x1560)

#define GPIO2_SYSCONFIG         *(unsigned int *)(GPIO2_BASE + 0x010)
#define GPIO2_OE            	*(unsigned int *)(GPIO2_BASE + 0x134)
#define GPIO2_DATAOUT           *(unsigned int *)(GPIO2_BASE + 0x13C)

#define GP2_9               (1 << 9)

GPIO_Enable()
{
	/* Enable GPIO2 Clock in PRCM Module */
	/* No register for GPIO2 clock in PRCM Module, It uses GPIO1 clock register */
	WR_MEM_32(CM_ALWON_GPIO_1_CLKCTRL, 0x2);      // Enable GP1 Clock
	while(RD_MEM_32(CM_ALWON_GPIO_1_CLKCTRL) != 0x2); // Poll for GP1 Module Clock is functional

	/* Configure LCD_BL_EN (GP2[9]) */
	WR_MEM_32(CTRL_MODULE_BASE_ADDR + 0x0A3c, 0x00010080); /* GP2[9] */ // Receiver disabled, no pull up/down enabled, Function 8 selected

	GPIO2_SYSCONFIG = 0x00000002;   // Software Reset
	wait_delay(0x90);
	GPIO2_SYSCONFIG = 0x00000008;   // no-idle
	GPIO2_OE &= ~GP2_9; // Enable Output on GP2[5]
	GPIO2_DATAOUT |= GP2_9; // Set GP2[5] HIgh
	GEL_TextOut("\t GPIO Enabled .... \n","Output",1,1,1);
}
DSSClkEnable()
{
	*(unsigned int *)RM_DSS_RSTCTRL =0;
	GEL_TextOut("\tPower Enabled.....  \n","Output",1,1,1);
	/* Enabling DSS Clocks */
	*(unsigned int *)CM_DSS_CLKSTCTRL=2 ;
	delay();
	*(unsigned int *)CM_DSS_DSS_CLKCTRL=2 ;
	delay();
	*(unsigned int *)CM_DSS_HDMI_CLKCTRL=2 ;
	delay();
	GEL_TextOut("\tPRCM for DSS in Progress, Please wait.....  \n","Output",1,1,1);
	while ( (*(unsigned int *)CM_DSS_CLKSTCTRL & 0x100) != 0x100)
	{
	}
	/*Deasserting resets */
	*(unsigned int *)RM_DSS_RSTCTRL =0;
	GEL_TextOut("\tPRCM for DSS Done Successfully.....  \n","Output",1,1,1);
}

DssConfigHDMI()
{
	unsigned int temp , temp1;

	hdmipinmux_cec_ddc();

	GEL_TextOut("\t ****  hdmi pin mux  complete  ******* \n","Output",1,1,1);
	temp = RD_MEM_32(0x46C00010) ;
	temp1 = ((temp & 0xFFFFFFFE)| 0x1 );
	WR_MEM_32(0x46C00300, temp1);

	temp = 0;
	while (temp ++ < 20 ) {}
	GEL_TextOut("\t ****  wrapper soft reset complete  ******* \n","Output",1,1,1);
	configure_hdmi_phy();
	GEL_TextOut("\t ****  configure hdmi phy  complete  ******* \n","Output",1,1,1);

	temp = RD_MEM_32(0x46C00070) ;
	temp1 = temp | 0x00000218;
	WR_MEM_32(0x46C00070, temp1);
	GEL_TextOut("\t ****  cec clock divider config   complete  ******* \n","Output",1,1,1); 

	temp = RD_MEM_32(0x46C00044) ;
	temp1 = temp | 0x00001414;
	WR_MEM_32(0x46C00044, temp1);
	GEL_TextOut("\t ****  wrapper debounce  config   complete  ******* \n","Output",1,1,1); 

	WR_MEM_32(0x46C00080, 0x0);
	GEL_TextOut("\t ****  disable audio    complete  ******* \n","Output",1,1,1);

	WR_MEM_32(0x46C00414, 0x1); 
	WR_MEM_32(0x46C00424, 0x1);  
	GEL_TextOut("\t ****  release HDMI IP CORE reset and release power down of core complete  ******* \n","Output",1,1,1); 

	WR_MEM_32(0x46C00524, 0x0);
	GEL_TextOut("\t ****  video action  config of hdmi  complete  ******* \n","Output",1,1,1); 

	WR_MEM_32(0x46C00420, 0x7); 
	GEL_TextOut("\t ****  config input data bus width done   ******* \n","Output",1,1,1); 

	WR_MEM_32(0x46C00528, 0x0);   //VID_MODE  CONFIG
	WR_MEM_32(0x46C004CC, 0x1);  //DATA ENABLE CNTRL
	WR_MEM_32(0x46C00420, 0x37);  //ENABLE VSYNC AND HSYNC
	WR_MEM_32(0x46C004F8, 0x0);  //iadjust config to enable vsync
	WR_MEM_32(0x46C00520, 0x10); // csc is bt709 
	WR_MEM_32(0x46C009BC, 0x21);  //enable hdmi 

	WR_MEM_32(0x46C00608, 0x20);  //tmds_ctrl
	WR_MEM_32(0x46C00904, 0x0);   //disable n/cts of actrl
	WR_MEM_32(0x46C00950, 0x0);     //disable audio   
	WR_MEM_32(0x46C00414, 0x0);      //   keep audio  operation in reset state
	GEL_TextOut("\t ****  configuring AVI INFOFRAME   ******* \n","Output",1,1,1);
 
	WR_MEM_32(0x46C00A00 , 0x82);
	WR_MEM_32(0x46C00A04 , 0x2);
	WR_MEM_32(0x46C00A08 , 0xD); 
	WR_MEM_32(0x46C00A10 , 0x1);
	WR_MEM_32(0x46C00A14 , 0xA0);		
	WR_MEM_32(0x46C00A1C , 0x8F);	
	GEL_TextOut("\t ****  configuring AVI INFOFRAME done   ******* \n","Output",1,1,1);     

	WR_MEM_32(0x46C00538 , 0x3);    //DISABLE DEEP COLOR MODE IN DC PACKET 
	WR_MEM_32(0x46C009C0 , 0x10);	
	WR_MEM_32(0x46C009F8 , 0x3);	  //ENABLE AND REPEAT AVI INFOFRAM TRANSMISSON
	WR_MEM_32(0x46C009FC , 0xF);    //ENABLE AND REPEAT GENEERAL PACKET TRANSMISSION

	GEL_TextOut("\t ****  configuring hdvenc for 1080p60 complete   ******* \n","Output",1,1,1);  
}	



    MLBClkEnable()
    {
        GEL_TextOut("\tPRCM for MLB is in Progress, Please wait.....  \n","Output",1,1,1);

        WR_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Slow Domain Peripheral*/

        WR_MEM_32(CM_ALWON_MLB_CLKCTRL, 0x2); /*Enable MLB Clk domain */
        while(RD_MEM_32(CM_ALWON_MLB_CLKCTRL) != 0x2);
        //while(((RD_MEM_32(CM_ALWON_MLB_CLKCTRL)) & (0x3 << 16)) != 0);
        GEL_TextOut("\t1st while loop done...\n");

        /*Ensure the Clk domains are fully functional */

        /* SHB Clk */
        while(RD_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL) & 0x100 != 0x100);
        GEL_TextOut("\t 2nd while loop done...\n");

        /* SPB and SYS Clk Domain */
        while(RD_MEM_32(CM_ALWON_SYSCLK5_CLKSTCTRL) & 0x100 != 0x100);
        GEL_TextOut("\t 3rd while loop done ... \n");
        // mlb data pin mux
        WR_MEM_32(PINCNTL60, 0x00040001);
        /* 0000 0000 0000 0100 0000 0000 0000 0001*/
        // mlb sig pin mux
        WR_MEM_32(PINCNTL59, 0x00040001);

        GEL_TextOut("\tPRCM for MLB has been done successfully.\n","Output",1,1,1);

    }


    DCANClkEnable()
    {
        GEL_TextOut("\tPRCM for DCAN is in Progress, Please wait.....  \n","Output",1,1,1);

        WR_MEM_32(CM_ALWON_L3_SLOW_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Slow Domain Peripheral*/

        WR_MEM_32(CM_ALWON_DCAN_0_1_CLKCTRL, 0x2); /*Enable DCAN Clk domain */
        while(RD_MEM_32(CM_ALWON_DCAN_0_1_CLKCTRL) != 0x2);
        // DCAN0 RX pin mux
        WR_MEM_32(PINCNTL69, 0x00040001);
        // DCAN0 TX pin mux
        //  WR_MEM_32(PINCNTL68, 0x00000001);
        // DCAN1 RX pin mux, func4
        //  WR_MEM_32(PINCNTL73, 0x00040008);
        // DCAN1 TX pin mux, func4
        WR_MEM_32(PINCNTL72, 0x00000008);
        GEL_TextOut("\t1st while loop done...\n");

        GEL_TextOut("\tPRCM for DCAN has been done successfully.\n","Output",1,1,1);
    }



    IS_DEVICE_GP_TEST()
    {
            if( (RD_MEM_32(CONTROL_STATUS) & 0x700) ==0)  {

              GEL_TextOut("\tDevice type is TEST \n","Output",1,1,1);

            }

            else if( (RD_MEM_32(CONTROL_STATUS) & 0x700) ==0x300)  {

              GEL_TextOut("\tDevice type is GP \n","Output",1,1,1);

             }
         /*
            if( (RD_MEM_32(MODENAPLL_CLOCK_CONTROL) & 0x1F000000) == 0x06000000 )  {
               GEL_TextOut("\tModena PLL EFuse are corerct \n","Output",1,1,1);
            }
            else
            {
            GEL_TextOut("\tModena PLL EFuse are not corerct \n","Output",1,1,1);
            }
            if( (RD_MEM_32(HDVICPPLL_CLOCK_CONTROL) & 0x1F000000) == 0x09000000 )  {
               GEL_TextOut("\tHDVICP PLL EFuse are corerct \n","Output",1,1,1);
            }
            else
            {
            GEL_TextOut("\tHDVICP PLL EFuse are not corerct \n","Output",1,1,1);
            }
            if( (RD_MEM_32(L3PLL_CLOCK_CONTROL) & 0x1F000000) == 0x09000000 )  {
               GEL_TextOut("\tL3 PLL EFuse are corerct \n","Output",1,1,1);
            }
            else
            {
            GEL_TextOut("\tL3 PLL EFuse are not corerct \n","Output",1,1,1);
            }
            if( (RD_MEM_32(ISSPLL_CLOCK_CONTROL) & 0x1F000000) == 0x09000000 )  {
               GEL_TextOut("\tISS PLL EFuse are corerct \n","Output",1,1,1);
            }
            else
            {
            GEL_TextOut("\tISS PLL EFuse are not corerct \n","Output",1,1,1);
            }
            if( (RD_MEM_32(DSSPLL_CLOCK_CONTROL) & 0x1F000000) == 0x09000000 )  {
               GEL_TextOut("\tDSS PLL EFuse are corerct \n","Output",1,1,1);
            }
            else
            {
            GEL_TextOut("\tDSS PLL EFuse are not corerct \n","Output",1,1,1);
            }
            if( (RD_MEM_32(VID0PLL_CLOCK_CONTROL) & 0x1F000000) == 0x09000000 )  {
               GEL_TextOut("\tVid0 PLL EFuse are corerct \n","Output",1,1,1);
            }
            else
            {
            GEL_TextOut("\tVid0 PLL EFuse are not corerct \n","Output",1,1,1);
            }
            if( (RD_MEM_32(VID1PLL_CLOCK_CONTROL) & 0x1F000000) == 0x09000000 )  {
               GEL_TextOut("\tVID1 PLL EFuse are corerct \n","Output",1,1,1);
            }
            else
            {
            GEL_TextOut("\tVID1 PLL EFuse are not corerct \n","Output",1,1,1);
            }
            if( (RD_MEM_32(HDMIPLL_CLOCK_CONTROL) & 0x1F000000) == 0x09000000 )  {
               GEL_TextOut("\tHDMI PLL EFuse are corerct \n","Output",1,1,1);
            }
            else
            {
            GEL_TextOut("\tHDMI PLL EFuse are not corerct \n","Output",1,1,1);
            }
            if( (RD_MEM_32(AUDIOPLL_CLOCK_CONTROL) & 0x1F000000) == 0x09000000 )  {
               GEL_TextOut("\tAudio PLL EFuse are corerct \n","Output",1,1,1);
            }
            else
            {
            GEL_TextOut("\tAudio PLL EFuse are not corerct \n","Output",1,1,1);
            }
            if( (RD_MEM_32(USBPLL_CLOCK_CONTROL) & 0x1F000000) == 0x09000000 )  {
               GEL_TextOut("\tUSB PLL EFuse are corerct \n","Output",1,1,1);
            }
            else
            {
            GEL_TextOut("\tUSB PLL EFuse are not corerct \n","Output",1,1,1);
            }
           if( (RD_MEM_32(DDRPLL_CLOCK_CONTROL) & 0x1F000000) == 0x09000000 )  {

              GEL_TextOut("\tDDR PLL EFuse are corerct \n","Output",1,1,1);
           }
           else
           {
              GEL_TextOut("\tDDR PLL EFuse are not corerct \n","Output",1,1,1);
           }


           if( ((RD_MEM_32(BANDGAP0_TRIM) & 0x00FF0000) == 0x00A70000) && ((RD_MEM_32(BANDGAP1_TRIM) & 0x00FF00) == 0x00A700) )
           {

                GEL_TextOut("\tRAM LDO EFuse are corerct \n","Output",1,1,1);

            }

            else  {

              GEL_TextOut("\tRAM LDO EFuse are not corerct \n","Output",1,1,1);

             }
    */
    }

    delay()
    {
        int del_cnt;
        for(del_cnt=0;del_cnt<200;del_cnt++);
    }

/*********************************     **********************************************************************


                   EMIF/DDR FUNCTIONS

********************************************************************************************************************/
    #define ONE_GB 1
    #define TWO_GB 2
    #define ONE_256MB 3

    unsigned int DDR_SIZE;

    cmd_DDR2_EMIF0_Config(UWORD32 ddr2_phy_rd_dqs_cs0_arg,UWORD32 ddr2_phy_wr_dqs_cs0_arg,UWORD32 ddr2_phy_rd_dqs_gate_cs0_arg,UWORD32 ddr2_phy_wr_data_cs0_arg,UWORD32 ddr2_emif_read_latency_arg,UWORD32 ddr2_emif_tim1_arg,UWORD32 ddr2_emif_tim2_arg,UWORD32 ddr2_emif_tim3_arg,UWORD32 ddr2_emif_ref_ctrl_arg,UWORD32 ddr2_emif_sdram_config_arg)
    {

        GEL_TextOut("\EMIF PRCM is in progress ....... \n","Output",1,1,1);
        Emif_PRCM_Clk_Enable();
        GEL_TextOut("\tDM385 DDR,DMM PRCM configuration is Done \n");
        Cmd_Macro_Config(DDR_PHY0,PHY_INVERT_CLKOUT_DEFINE,DDR2_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE,PHY_CMD0_DLL_LOCK_DIFF_DEFINE);
        Data_Macro_Config(DATA_MACRO_0,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_rd_dqs_gate_cs0_arg,ddr2_phy_wr_data_cs0_arg);
        Data_Macro_Config(DATA_MACRO_1,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_rd_dqs_gate_cs0_arg,ddr2_phy_wr_data_cs0_arg);
        Data_Macro_Config(DATA_MACRO_2,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_rd_dqs_gate_cs0_arg,ddr2_phy_wr_data_cs0_arg);
        Data_Macro_Config(DATA_MACRO_3,DDR_PHY0,ddr2_phy_rd_dqs_cs0_arg,ddr2_phy_wr_dqs_cs0_arg,ddr2_phy_rd_dqs_gate_cs0_arg,ddr2_phy_wr_data_cs0_arg);

        GEL_TextOut("\tDM385 DDR PHY Configuration is Done \n");
        WR_MEM_32(DDR0_IO_CTRL,0x00030303);
        GEL_TextOut("\tDM385 DDR IO Control Configuration is Done \n");

        Vtp_Enable();
        GEL_TextOut("\tDM385 VTP Configuration is Done \n");

        if(DDR_SIZE==TWO_GB)
        {
            /*Program the DMM to Access EMIF0*/
            WR_MEM_32(DMM_LISA_MAP__0, 0x80700100);
            WR_MEM_32(DMM_LISA_MAP__1, 0x80700100);
            WR_MEM_32(DMM_LISA_MAP__2, 0x80700100);
            WR_MEM_32(DMM_LISA_MAP__3, 0x80700100);

            while(RD_MEM_32(DMM_LISA_MAP__0)!=0x80700100);
            while(RD_MEM_32(DMM_LISA_MAP__1)!=0x80700100);
            while(RD_MEM_32(DMM_LISA_MAP__2)!=0x80700100);
            while(RD_MEM_32(DMM_LISA_MAP__3)!=0x80700100);

            WR_MEM_32(DMM_PAT_BASE_ADDR, 0x80000000);
        }
        else if(DDR_SIZE==ONE_GB)
        {
            /*Program the DMM to Access EMIF0*/
            WR_MEM_32(DMM_LISA_MAP__0, 0x80600100);
            WR_MEM_32(DMM_LISA_MAP__1, 0x80600100);
            WR_MEM_32(DMM_LISA_MAP__2, 0x80600100);
            WR_MEM_32(DMM_LISA_MAP__3, 0x80600100);

            while(RD_MEM_32(DMM_LISA_MAP__0)!=0x80600100);
            while(RD_MEM_32(DMM_LISA_MAP__1)!=0x80600100);
            while(RD_MEM_32(DMM_LISA_MAP__2)!=0x80600100);
            while(RD_MEM_32(DMM_LISA_MAP__3)!=0x80600100);

            WR_MEM_32(DMM_PAT_BASE_ADDR, 0x80000000);
        }

        GEL_TextOut("\tDM385 DMM LISA register Configuration is done for %d GBytes \n",,,,,DDR_SIZE);

        Emif0_MMR_Config(ddr2_emif_read_latency_arg,ddr2_emif_tim1_arg,ddr2_emif_tim2_arg,ddr2_emif_tim3_arg,ddr2_emif_ref_ctrl_arg,ddr2_emif_sdram_config_arg);
    }

    cmd_DDR3_EMIF0_Config(UWORD32 ddr3_phy_rd_dqs_cs0_arg,UWORD32 ddr3_phy_wr_dqs_cs0_arg,UWORD32 ddr3_phy_rd_dqs_gate_cs0_arg,UWORD32 ddr3_phy_wr_data_cs0_arg,UWORD32 ddr3_emif_read_latency_arg,UWORD32 ddr3_emif_tim1_arg,UWORD32 ddr3_emif_tim2_arg,UWORD32 ddr3_emif_tim3_arg,UWORD32 ddr3_emif_ref_ctrl_arg,UWORD32 ddr3_emif_sdram_config_arg)
    {

        Emif_PRCM_Clk_Enable();
        GEL_TextOut("\tDM385 DDR,DMM PRCM configuration is Done \n");

        Cmd_Macro_Config(DDR_PHY0,DDR3_PHY_INVERT_CLKOUT_OFF,DDR3_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE,PHY_CMD0_DLL_LOCK_DIFF_DEFINE);
        Data_Macro_Config(DATA_MACRO_0,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_rd_dqs_gate_cs0_arg,ddr3_phy_wr_data_cs0_arg);
        Data_Macro_Config(DATA_MACRO_1,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_rd_dqs_gate_cs0_arg,ddr3_phy_wr_data_cs0_arg);
        Data_Macro_Config(DATA_MACRO_2,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_rd_dqs_gate_cs0_arg,ddr3_phy_wr_data_cs0_arg);
        Data_Macro_Config(DATA_MACRO_3,DDR_PHY0,ddr3_phy_rd_dqs_cs0_arg,ddr3_phy_wr_dqs_cs0_arg,ddr3_phy_rd_dqs_gate_cs0_arg,ddr3_phy_wr_data_cs0_arg);

        GEL_TextOut("\tDM385 DDR PHY Configuration is Done \n");

        WR_MEM_32(DDR0_IO_CTRL,0x00030303);
        GEL_TextOut("\tDM385 DDR IO Control Configuration is Done \n");

        Vtp_Enable();
        GEL_TextOut("\tDM385 VTP Configuration is Done \n");
        if(DDR_SIZE==TWO_GB)
        {
            /*Program the DMM to Access EMIF0*/
            WR_MEM_32(DMM_LISA_MAP__0, 0x80700100);
            WR_MEM_32(DMM_LISA_MAP__1, 0x80700100);
            WR_MEM_32(DMM_LISA_MAP__2, 0x80700100);
            WR_MEM_32(DMM_LISA_MAP__3, 0x80700100);

            while(RD_MEM_32(DMM_LISA_MAP__0)!=0x80700100);
            while(RD_MEM_32(DMM_LISA_MAP__1)!=0x80700100);
            while(RD_MEM_32(DMM_LISA_MAP__2)!=0x80700100);
            while(RD_MEM_32(DMM_LISA_MAP__3)!=0x80700100);

            WR_MEM_32(DMM_PAT_BASE_ADDR, 0x80000000);
        }

        else if(DDR_SIZE==ONE_GB)
        {
            /*Program the DMM to Access EMIF0*/
            WR_MEM_32(DMM_LISA_MAP__0, 0x80600100);
            WR_MEM_32(DMM_LISA_MAP__1, 0x80600100);
            WR_MEM_32(DMM_LISA_MAP__2, 0x80600100);
            WR_MEM_32(DMM_LISA_MAP__3, 0x80600100);

            while(RD_MEM_32(DMM_LISA_MAP__0)!=0x80600100);
            while(RD_MEM_32(DMM_LISA_MAP__1)!=0x80600100);
            while(RD_MEM_32(DMM_LISA_MAP__2)!=0x80600100);
            while(RD_MEM_32(DMM_LISA_MAP__3)!=0x80600100);

            WR_MEM_32(DMM_PAT_BASE_ADDR, 0x80000000);
        }

        else if(DDR_SIZE==ONE_256MB)
        {
            WR_MEM_32(DMM_LISA_MAP__0, 0);
            WR_MEM_32(DMM_LISA_MAP__1, 0);
            WR_MEM_32(DMM_LISA_MAP__2, 0x80400100);
            WR_MEM_32(DMM_LISA_MAP__3, 0xA0400100);
            

            while(RD_MEM_32(DMM_LISA_MAP__0)!=0);
            while(RD_MEM_32(DMM_LISA_MAP__1)!=0);
            while(RD_MEM_32(DMM_LISA_MAP__2)!=0x80400100);
            while(RD_MEM_32(DMM_LISA_MAP__3)!=0xA0400100);

            WR_MEM_32(DMM_PAT_BASE_ADDR, 0x80000000);
        }

        GEL_TextOut("\tDM385 DMM LISA register Configuration is done for %d GBytes \n",,,,,DDR_SIZE);

        Emif0_MMR_Config(ddr3_emif_read_latency_arg,ddr3_emif_tim1_arg,ddr3_emif_tim2_arg,ddr3_emif_tim3_arg,ddr3_emif_ref_ctrl_arg,ddr3_emif_sdram_config_arg);
    }


    cmd_mDDR_EMIF0_Config(UWORD32 mDDR_phy_rd_dqs_cs0_arg,UWORD32 mDDR_phy_wr_dqs_cs0_arg,UWORD32 mDDR_phy_rd_dqs_gate_cs0_arg,UWORD32 mDDR_phy_wr_data_cs0_arg,UWORD32 mDDR_emif_read_latency_arg,UWORD32 mDDR_emif_tim1_arg,UWORD32 mDDR_emif_tim2_arg,UWORD32 mDDR_emif_tim3_arg,UWORD32 mDDR_emif_ref_ctrl_arg,UWORD32 mDDR_emif_sdram_config_arg)
    {

        Emif_PRCM_Clk_Enable();

        Cmd_Macro_Config(DDR_PHY0,PHY_INVERT_CLKOUT_DEFINE,mDDR_PHY_CTRL_SLAVE_RATIO_CS0_DEFINE,PHY_CMD0_DLL_LOCK_DIFF_DEFINE);
        Data_Macro_Config(DATA_MACRO_0,ddr_phy0,mDDR_phy_rd_dqs_cs0_arg,mDDR_phy_wr_dqs_cs0_arg,mDDR_phy_rd_dqs_gate_cs0_arg,mDDR_phy_wr_data_cs0_arg);
        Data_Macro_Config(DATA_MACRO_1,ddr_phy0,mDDR_phy_rd_dqs_cs0_arg,mDDR_phy_wr_dqs_cs0_arg,mDDR_phy_rd_dqs_gate_cs0_arg,mDDR_phy_wr_data_cs0_arg);
        Data_Macro_Config(DATA_MACRO_2,ddr_phy0,mDDR_phy_rd_dqs_cs0_arg,mDDR_phy_wr_dqs_cs0_arg,mDDR_phy_rd_dqs_gate_cs0_arg,mDDR_phy_wr_data_cs0_arg);
        Data_Macro_Config(DATA_MACRO_3,ddr_phy0,mDDR_phy_rd_dqs_cs0_arg,mDDR_phy_wr_dqs_cs0_arg,mDDR_phy_rd_dqs_gate_cs0_arg,mDDR_phy_wr_data_cs0_arg);

        WR_MEM_32(DATA0_REG_PHY0_USE_RANK0_DELAYS,    mDDR_PHY_REG_USE_RANK0_DELAY_DEFINE);
        WR_MEM_32(DATA1_REG_PHY0_USE_RANK0_DELAYS,    mDDR_PHY_REG_USE_RANK0_DELAY_DEFINE);
        WR_MEM_32(DATA2_REG_PHY0_USE_RANK0_DELAYS,    mDDR_PHY_REG_USE_RANK0_DELAY_DEFINE);
        WR_MEM_32(DATA3_REG_PHY0_USE_RANK0_DELAYS,    mDDR_PHY_REG_USE_RANK0_DELAY_DEFINE);

        WR_MEM_32(DDR0_IO_CTRL,0x10030303);

        Vtp_Enable();

        if(DDR_SIZE==TWO_GB)
        {
            /*Program the DMM to Access EMIF0*/
            WR_MEM_32(DMM_LISA_MAP__0, 0x80700100);
            WR_MEM_32(DMM_LISA_MAP__1, 0x80700100);
            WR_MEM_32(DMM_LISA_MAP__2, 0x80700100);
            WR_MEM_32(DMM_LISA_MAP__3, 0x80700100);

            while(RD_MEM_32(DMM_LISA_MAP__0)!=0x80700100);
            while(RD_MEM_32(DMM_LISA_MAP__1)!=0x80700100);
            while(RD_MEM_32(DMM_LISA_MAP__2)!=0x80700100);
            while(RD_MEM_32(DMM_LISA_MAP__3)!=0x80700100);

            WR_MEM_32(DMM_PAT_BASE_ADDR, 0x80000000);
        }
        else if(DDR_SIZE==ONE_GB)
        {
            /*Program the DMM to Access EMIF0*/
            WR_MEM_32(DMM_LISA_MAP__0, 0x80600100);
            WR_MEM_32(DMM_LISA_MAP__1, 0x80600100);
            WR_MEM_32(DMM_LISA_MAP__2, 0x80600100);
            WR_MEM_32(DMM_LISA_MAP__3, 0x80600100);

            while(RD_MEM_32(DMM_LISA_MAP__0)!=0x80600100);
            while(RD_MEM_32(DMM_LISA_MAP__1)!=0x80600100);
            while(RD_MEM_32(DMM_LISA_MAP__2)!=0x80600100);
            while(RD_MEM_32(DMM_LISA_MAP__3)!=0x80600100);

            WR_MEM_32(DMM_PAT_BASE_ADDR, 0x80000000);
        }

        GEL_TextOut("\tDM385 DMM LISA register Configuration is done for %d GBytes \n",,,,,DDR_SIZE);

        Emif0_MMR_Config(mDDR_emif_read_latency_arg,mDDR_emif_tim1_arg,mDDR_emif_tim2_arg,mDDR_emif_tim3_arg,mDDR_emif_ref_ctrl_arg,mDDR_emif_sdram_config_arg);
    }


    Data_Macro_Config(UWORD32 dataMacroNum,UWORD32 ddr_phy_num,UWORD32 rd_dqs_cs0,UWORD32 wr_dqs_cs0,UWORD32 rd_dqs_gate_cs0,UWORD32 wr_data_cs0)
    {
    UWORD32 BaseAddrOffset;
        if(dataMacroNum == DATA_MACRO_0)
            BaseAddrOffset = 0x00;
        else if(dataMacroNum == DATA_MACRO_1)
            BaseAddrOffset = 0xA4;
        else if(dataMacroNum == DATA_MACRO_2)
            BaseAddrOffset = 0x148;
        else if(dataMacroNum == DATA_MACRO_3)
            BaseAddrOffset = 0x1EC;

        WR_MEM_32((DATA0_REG_PHY0_RD_DQS_SLAVE_RATIO_0 + BaseAddrOffset), (rd_dqs_cs0 << 10 | rd_dqs_cs0));
        WR_MEM_32((DATA0_REG_PHY0_WR_DQS_SLAVE_RATIO_0 + BaseAddrOffset), (wr_dqs_cs0 << 10 | wr_dqs_cs0));
        WR_MEM_32((DATA0_REG_PHY0_WRLVL_INIT_RATIO_0 + BaseAddrOffset),   (PHY_WRLVL_INIT_CS1_DEFINE << 10  | PHY_WRLVL_INIT_CS0_DEFINE));
        WR_MEM_32((DATA0_REG_PHY0_GATELVL_INIT_RATIO_0 + BaseAddrOffset), (PHY_GATELVL_INIT_CS1_DEFINE << 10 | PHY_GATELVL_INIT_CS0_DEFINE));
        WR_MEM_32((DATA0_REG_PHY0_RD_DQS_GATE_SLAVE_RATIO_0 + BaseAddrOffset),(rd_dqs_gate_cs0 << 10  | rd_dqs_gate_cs0));
        WR_MEM_32((DATA0_REG_PHY0_WR_DATA_SLAVE_RATIO_0 + BaseAddrOffset),(wr_data_cs0 << 10 | wr_data_cs0));
        //-WR_MEM_32((DATA0_REG_PHY0_USE_RANK0_DELAYS + BaseAddrOffset),     PHY_REG_USE_RANK0_DELAY_DEFINE);//- default is 0; for mDDR need to set as 1
        WR_MEM_32((DATA0_REG_PHY0_DLL_LOCK_DIFF_0 + BaseAddrOffset),      PHY_DLL_LOCK_DIFF_DEFINE);
    }

    Cmd_Macro_Config(UWORD32 ddr_phy_num,UWORD32 invert_clk_out,UWORD32 ctrl_slave_ratio_cs0,UWORD32 cmd_dll_lock_diff)
    {
            WR_MEM_32(CMD0_REG_PHY0_INVERT_CLKOUT_0, invert_clk_out);
            WR_MEM_32(CMD1_REG_PHY0_INVERT_CLKOUT_0, invert_clk_out);
            WR_MEM_32(CMD2_REG_PHY0_INVERT_CLKOUT_0, invert_clk_out);

            WR_MEM_32(CMD0_REG_PHY0_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0));
            WR_MEM_32(CMD1_REG_PHY0_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0));
            WR_MEM_32(CMD2_REG_PHY0_CTRL_SLAVE_RATIO_0,(ctrl_slave_ratio_cs0 << 10 | ctrl_slave_ratio_cs0));

            WR_MEM_32(CMD0_REG_PHY0_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
            WR_MEM_32(CMD1_REG_PHY0_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
            WR_MEM_32(CMD2_REG_PHY0_DLL_LOCK_DIFF_0,cmd_dll_lock_diff);
    }


    Emif0_MMR_Config(UWORD32 read_latency,UWORD32 tim1,UWORD32 tim2,UWORD32 tim3,UWORD32 ref_ctrl,UWORD32 sdram_config)
    {
        /*Program EMIF0 CFG Registers*/
        WR_MEM_32(EMIF4_0_DDR_PHY_CTRL_1, read_latency);
        WR_MEM_32(EMIF4_0_DDR_PHY_CTRL_1_SHADOW, read_latency);

        WR_MEM_32(EMIF4_0_SDRAM_TIM_1, tim1);
        WR_MEM_32(EMIF4_0_SDRAM_TIM_1_SHADOW, tim1);

        WR_MEM_32(EMIF4_0_SDRAM_TIM_2, tim2);
        WR_MEM_32(EMIF4_0_SDRAM_TIM_2_SHADOW, tim2);

        WR_MEM_32(EMIF4_0_SDRAM_TIM_3, tim3);
        WR_MEM_32(EMIF4_0_SDRAM_TIM_3_SHADOW, tim3);

        WR_MEM_32(EMIF4_0_SDRAM_CONFIG, sdram_config);

        WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL, 0x10000000|DDR3_EMIF_REF_CTRL_DEFINE1);
        WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL_SHADOW, DDR3_EMIF_REF_CTRL_DEFINE1);

        WR_MEM_32(EMIF4_0_SDRAM_ZQCR,DDR3_EMIF_SDRAM_ZQCR_DEFINE);

        WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL, DDR3_EMIF_REF_CTRL_DEFINE1);
        WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL_SHADOW, DDR3_EMIF_REF_CTRL_DEFINE1);

        WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL, ref_ctrl);
        WR_MEM_32(EMIF4_0_SDRAM_REF_CTRL_SHADOW, ref_ctrl);
    }

    Emif_PRCM_Clk_Enable()
    {
        WR_MEM_32(CM_DEFAULT_FW_CLKCTRL, 0x2);        /*Enable the EMIF FireWall Clocks*/
        WR_MEM_32(CM_DEFAULT_L3_FAST_CLKSTCTRL, 0x2); /*Enable the Power Domain Transition of L3 Fast Domain Peripheral*/
        WR_MEM_32(CM_DEFAULT_EMIF_0_CLKCTRL,    0x2); /*Enable EMIF0 Clock*/
        WR_MEM_32(CM_DEFAULT_DMM_CLKCTRL,       0x2); /*Enable DMM Clock*/
        while((RD_MEM_32(CM_DEFAULT_L3_FAST_CLKSTCTRL) & 0x300)!=0x300);    /*Poll for L3_FAST_GCLK  & DDR_GCLK  are active*/
        while(RD_MEM_32(CM_DEFAULT_EMIF_0_CLKCTRL)!=0x2);       /*Poll for Module is functional*/
        while(RD_MEM_32(CM_DEFAULT_DMM_CLKCTRL)!=0x2);          /*Poll for Module is functional*/
    }

    Vtp_Enable()
    {
        // Write 1 to ENABLE bit
        WR_MEM_32(VTP0_CTRL_REG, RD_MEM_32(VTP0_CTRL_REG) | 0x00000040 );

        // Write 0 to CLRZ bit
        WR_MEM_32(VTP0_CTRL_REG, RD_MEM_32(VTP0_CTRL_REG) & 0xfffffffe );

        // Write 1 to CLRZ bit
        WR_MEM_32(VTP0_CTRL_REG, RD_MEM_32(VTP0_CTRL_REG) | 0x00000001 );

        // Read VTP control registers & check READY bits
        while( (RD_MEM_32(VTP0_CTRL_REG) & 0x00000020) != 0x20);
    }


/*************************************************************************************************/

    /********************************************************************************
            DDR Initialization and Configurations
    *********************************************************************************/

   menuitem "TI8107 VDB DDR Configurations"

    hotmenu VDB_DDR2_EMIF0_266MHz_Config()
    {
        DDR_SIZE=TWO_GB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 266 MHz......... \n");
        cmdDDRPLL(CLKIN,19,532, 2);
        GEL_TextOut("\tDM385 DDR2 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR2_EMIF0_Config(DDR2_PHY_RD_DQS_CS0_DEFINE,DDR2_PHY_WR_DQS_CS0_DEFINE,DDR2_PHY_RD_DQS_GATE_CS0_DEFINE,DDR2_PHY_WR_DATA_CS0_DEFINE,DDR2_EMIF_DDRPHYCR_DEFINE_266,DDR2_EMIF_TIM1_DEFINE_266,DDR2_EMIF_TIM2_DEFINE_266,DDR2_EMIF_TIM3_DEFINE_266,DDR2_EMIF_REF_CTRL_DEFINE_266,DDR2_EMIF_SDRAM_CONFIG_DEFINE_266);
        GEL_TextOut("\tDM385 DDR2 EVM EMIF0 configuration is DONE. \n");
    }

    VDB_DDR2_EMIF0_333MHz_Config()
    {
        DDR_SIZE=TWO_GB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 333 MHz......... \n");
        cmdDDRPLL(CLKIN,19,666, 2);
        GEL_TextOut("\tDM385 DDR2 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR2_EMIF0_Config(DDR2_PHY_RD_DQS_CS0_DEFINE,DDR2_PHY_WR_DQS_CS0_DEFINE,DDR2_PHY_RD_DQS_GATE_CS0_DEFINE,DDR2_PHY_WR_DATA_CS0_DEFINE,DDR2_EMIF_DDRPHYCR_DEFINE_333,DDR2_EMIF_TIM1_DEFINE_333,DDR2_EMIF_TIM2_DEFINE_333,DDR2_EMIF_TIM3_DEFINE_333,DDR2_EMIF_REF_CTRL_DEFINE_333,DDR2_EMIF_SDRAM_CONFIG_DEFINE_333);
        GEL_TextOut("\tDM385 DDR2 EVM EMIF0 configuration is DONE. \n");
    }

    VDB_DDR2_EMIF0_400MHz_Config()
    {
        DDR_SIZE=TWO_GB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 400 MHz......... \n");
        cmdDDRPLL(CLKIN,19,800, 2);
        GEL_TextOut("\tDM385 DDR2 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR2_EMIF0_Config(DDR2_PHY_RD_DQS_CS0_DEFINE,DDR2_PHY_WR_DQS_CS0_DEFINE,DDR2_PHY_RD_DQS_GATE_CS0_DEFINE,DDR2_PHY_WR_DATA_CS0_DEFINE,DDR2_EMIF_DDRPHYCR_DEFINE_400,DDR2_EMIF_TIM1_DEFINE_400,DDR2_EMIF_TIM2_DEFINE_400,DDR2_EMIF_TIM3_DEFINE_400,DDR2_EMIF_REF_CTRL_DEFINE_400,DDR2_EMIF_SDRAM_CONFIG_DEFINE_400);
        GEL_TextOut("\tDM385 DDR2 EVM EMIF0 configuration is DONE. \n");
    }

    VDB_DDR2_EMIF0_450MHz_Config()
    {
        DDR_SIZE=TWO_GB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 400 MHz......... \n");
        cmdDDRPLL(CLKIN,19,900, 2);
        GEL_TextOut("\tDM385 DDR2 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR2_EMIF0_Config(DDR2_PHY_RD_DQS_CS0_DEFINE,DDR2_PHY_WR_DQS_CS0_DEFINE,DDR2_PHY_RD_DQS_GATE_CS0_DEFINE,DDR2_PHY_WR_DATA_CS0_DEFINE,DDR2_EMIF_DDRPHYCR_DEFINE_450,DDR2_EMIF_TIM1_DEFINE_450,DDR2_EMIF_TIM2_DEFINE_450,DDR2_EMIF_TIM3_DEFINE_450,DDR2_EMIF_REF_CTRL_DEFINE_450,DDR2_EMIF_SDRAM_CONFIG_DEFINE_450);
        GEL_TextOut("\tDM385 DDR2 EVM EMIF0 configuration is DONE. \n");
    }

    hotmenu  VDB_DDR3_EMIF0_300MHz_Config()
    {
        DDR_SIZE=TWO_GB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 300 MHz......... \n");
        cmdDDRPLL(CLKIN,19,600, 2);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR3_EMIF0_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_RD_DQS_GATE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_DDRPHYCR_DEFINE_300,DDR3_EMIF_TIM1_DEFINE_300,DDR3_EMIF_TIM2_DEFINE_300,DDR3_EMIF_TIM3_DEFINE_300,DDR3_EMIF_REF_CTRL_DEFINE2_300,DDR3_EMIF_SDRAM_CONFIG_DEFINE_300);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration is DONE. \n");
    }

        hotmenu  VDB_DDR3_EMIF0_333MHz_Config()
    {
        DDR_SIZE=TWO_GB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 333 MHz......... \n");
        cmdDDRPLL(CLKIN,19,666, 2);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR3_EMIF0_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_RD_DQS_GATE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_DDRPHYCR_DEFINE_333,DDR3_EMIF_TIM1_DEFINE_333,DDR3_EMIF_TIM2_DEFINE_333,DDR3_EMIF_TIM3_DEFINE_333,DDR3_EMIF_REF_CTRL_DEFINE2_333,DDR3_EMIF_SDRAM_CONFIG_DEFINE_333);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration is DONE. \n");
    }

    hotmenu  VDB_DDR3_EMIF0_400MHz_Config()
    {
        DDR_SIZE=TWO_GB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 400 MHz......... \n");
        cmdDDRPLL(CLKIN,19,800, 2);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR3_EMIF0_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_RD_DQS_GATE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_DDRPHYCR_DEFINE_400,DDR3_EMIF_TIM1_DEFINE_400,DDR3_EMIF_TIM2_DEFINE_400,DDR3_EMIF_TIM3_DEFINE_400,DDR3_EMIF_REF_CTRL_DEFINE2_400,DDR3_EMIF_SDRAM_CONFIG_DEFINE_400);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration is DONE. \n");
    }

    hotmenu  EVM_DDR3_EMIF0_400MHz_Config_256MB()
    {
        DDR_SIZE=ONE_256MB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 400 MHz......... \n");
        cmdDDRPLL(CLKIN,19,800, 2);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR3_EMIF0_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_RD_DQS_GATE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_DDRPHYCR_DEFINE_400,DDR3_EMIF_TIM1_DEFINE_400,DDR3_EMIF_TIM2_DEFINE_400,DDR3_EMIF_TIM3_DEFINE_400,DDR3_EMIF_REF_CTRL_DEFINE2_400,DDR3_EMIF_SDRAM_CONFIG_DEFINE_400);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration is DONE. \n");
    }

    hotmenu  VDB_DDR3_EMIF0_450MHz_Config()
    {
        DDR_SIZE=TWO_GB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 450 MHz......... \n");
        cmdDDRPLL(CLKIN,19,900, 2);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR3_EMIF0_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_RD_DQS_GATE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_DDRPHYCR_DEFINE_450,DDR3_EMIF_TIM1_DEFINE_450,DDR3_EMIF_TIM2_DEFINE_450,DDR3_EMIF_TIM3_DEFINE_450,DDR3_EMIF_REF_CTRL_DEFINE2_450,DDR3_EMIF_SDRAM_CONFIG_DEFINE_450);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration is DONE. \n");
    }

    hotmenu  VDB_DDR3_EMIF0_533MHz_Config()
    {
        DDR_SIZE=TWO_GB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 533 MHz......... \n");
        cmdDDRPLL(CLKIN,19,1066, 2);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR3_EMIF0_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_RD_DQS_GATE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_DDRPHYCR_DEFINE_533,DDR3_EMIF_TIM1_DEFINE_533,DDR3_EMIF_TIM2_DEFINE_533,DDR3_EMIF_TIM3_DEFINE_533,DDR3_EMIF_REF_CTRL_DEFINE2_533,DDR3_EMIF_SDRAM_CONFIG_DEFINE_533);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration is DONE. \n");
    }

//  hotmenu  VDB_DDR3_EMIF0_666MHz_Config()
//  {
//          GEL_TextOut("\t ****  Configuring DDR PLL to 666 MHz......... \n");
//      cmdDDRPLL(CLKIN,19,1332, 2);
//      GEL_TextOut("\t ****  DM385 DDR3 EVM EMIF0 configuration in progress......... \n","Output",1,1,1);
//      cmd_DDR3_EMIF0_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_RD_DQS_GATE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_DDRPHYCR_DEFINE_666,DDR3_EMIF_TIM1_DEFINE_666,DDR3_EMIF_TIM2_DEFINE_666,DDR3_EMIF_TIM3_DEFINE_666,DDR3_EMIF_REF_CTRL_DEFINE2_666,DDR3_EMIF_SDRAM_CONFIG_DEFINE_666);
//      GEL_TextOut("\t ****  DM385 DDR3 EVM EMIF0 configuration is DONE **** \n","Output",1,1,1);
//  }

   menuitem "DM385 EVM DDR Configurations"

    hotmenu  EVM_DDR3_EMIF0_400MHz_Config()
    {
        DDR_SIZE=ONE_GB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 400 MHz......... \n");
        cmdDDRPLL(CLKIN,19,800, 2);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR3_EMIF0_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_RD_DQS_GATE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_DDRPHYCR_DEFINE_400,DDR3_EMIF_TIM1_DEFINE_400,DDR3_EMIF_TIM2_DEFINE_400,DDR3_EMIF_TIM3_DEFINE_400,DDR3_EMIF_REF_CTRL_DEFINE2_400,DDR3_EMIF_SDRAM_CONFIG_DEFINE_400);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration is DONE. \n");
    }


    hotmenu  EVM_DDR3_EMIF0_533MHz_Config()
    {
        DDR_SIZE=ONE_GB;
        GEL_TextOut("\t ****  Configuring DDR PLL to 533 MHz......... \n");
        cmdDDRPLL(CLKIN,19,1066, 2);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration in progress......... \n");
        cmd_DDR3_EMIF0_Config(DDR3_PHY_RD_DQS_CS0_DEFINE,DDR3_PHY_WR_DQS_CS0_DEFINE,DDR3_PHY_RD_DQS_GATE_CS0_DEFINE,DDR3_PHY_WR_DATA_CS0_DEFINE,DDR3_EMIF_DDRPHYCR_DEFINE_533,DDR3_EMIF_TIM1_DEFINE_533,DDR3_EMIF_TIM2_DEFINE_533,DDR3_EMIF_TIM3_DEFINE_533,DDR3_EMIF_REF_CTRL_DEFINE2_533,DDR3_EMIF_SDRAM_CONFIG_DEFINE_533);
        GEL_TextOut("\tDM385 DDR3 EVM EMIF0 configuration is DONE. \n");
    }


/*************************************************************************************************/

menuitem "HDMI Configurations"

/********  HDMI Configurations  ************/

    hotmenu PLL_CLOCKS_Config_hdmi_1_48_Normal()
    {
        unsigned int temp , temp1;

        GEL_TextOut("\t PLL Configuration for HDMI is in progress,Please wait ..... \n","Output",1,1,1);
        DSS_PLL_Config();
        *(unsigned int *)0x481C52C8 = 0x00000001 ;  // VIDEO_PLL Source is VIDEO_M_PCLK
        HDMI_PLL_Config_145();
        DSSClkEnable();
        WR_MEM_32(0x48100100, 0x01031FFF);      //Enabling clocks to DSS modules
        WR_MEM_32(0x48100114, 0xC010F);         // CLKC Video Encoder Clock Select Configuration
        WR_MEM_32(0x48100118, 0xF);             // CLKC Video Encoder Enable Configuration
        *(unsigned int *)0x48100000 = 0x01000000 ;  //enable dss start of frame interrupt
        VIDEO_1_PLL_Config();
        GEL_TextOut("\t ****  PLL Configuration for HDMI is completed  ******* \n","Output",1,1,1);


        hdmipinmux_cec_ddc();
        GEL_TextOut("\t ****  hdmi pin mux  complete  ******* \n","Output",1,1,1);


        temp = RD_MEM_32(0x46C00010) ;
        temp1 = ((temp & 0xFFFFFFFE)| 0x1 );
        WR_MEM_32(0x46C00300, temp1);
        temp = 0;
        while (temp ++ < 20 ) {}
        GEL_TextOut("\t ****  wrapper soft reset complete  ******* \n","Output",1,1,1);


        configure_hdmi_phy();
        GEL_TextOut("\t ****  configure hdmi phy  complete  ******* \n","Output",1,1,1);


        temp = RD_MEM_32(0x46C00070) ;
        temp1 = temp | 0x00000218;
        WR_MEM_32(0x46C00070, temp1);
        GEL_TextOut("\t ****  cec clock divider config   complete  ******* \n","Output",1,1,1);


        temp = RD_MEM_32(0x46C00044) ;
        temp1 = temp | 0x00001414;
        WR_MEM_32(0x46C00044, temp1);
        GEL_TextOut("\t ****  wrapper debounce  config   complete  ******* \n","Output",1,1,1);


        temp = RD_MEM_32(0x46C00050) ;
        temp1 = temp | 0x105;
        WR_MEM_32(0x46C00050, temp1);
        GEL_TextOut("\t ****  packing mode configuration    complete  ******* \n","Output",1,1,1);


        WR_MEM_32(0x46C00080, 0x0);
        GEL_TextOut("\t ****  disable audio    complete  ******* \n","Output",1,1,1);

        WR_MEM_32(0x46C00414, 0x1);
        WR_MEM_32(0x46C00424, 0x1);
        GEL_TextOut("\t ****  release HDMI IP CORE reset and release power down of core complete  ******* \n","Output",1,1,1);


        WR_MEM_32(0x46C00524, 0x0);
        GEL_TextOut("\t ****  video action  config of hdmi  complete  ******* \n","Output",1,1,1);

        WR_MEM_32(0x46C00420, 0x7);
        GEL_TextOut("\t ****  config input data bus width done   ******* \n","Output",1,1,1);

        WR_MEM_32(0x46C00528, 0x0);     // VID_MODE  CONFIG
        WR_MEM_32(0x46C004CC, 0x1);     // DATA ENABLE CNTRL
        WR_MEM_32(0x46C00420, 0x37);    // ENABLE VSYNC AND HSYNC
        WR_MEM_32(0x46C004F8, 0x0);     // iadjust config to enable vsync
        WR_MEM_32(0x46C00520, 0x10);    // csc is bt709
        WR_MEM_32(0x46C009BC, 0x21);    // enable hdmi
        WR_MEM_32(0x46C00608, 0x20);    // tmds_ctrl
        WR_MEM_32(0x46C00904, 0x0);     // disable n/cts of actrl
        WR_MEM_32(0x46C00950, 0x0);     // disable audio
        WR_MEM_32(0x46C00414, 0x0);     //   keep audio  operation in reset state

        GEL_TextOut("\t ****  configuring AVI INFOFRAME   ******* \n","Output",1,1,1);
        WR_MEM_32(0x46C00A00 , 0x82);   // AVI_TYPE
        WR_MEM_32(0x46C00A04 , 0x2);    // AVI_VERS
        WR_MEM_32(0x46C00A08 , 0xD);    // AVI_CHSUM
        WR_MEM_32(0x46C00A10 , 0x1);    // AVI_DATA
        WR_MEM_32(0x46C00A14 , 0xA0);   // AVI_DATA
        WR_MEM_32(0x46C00A1C , 0x8F);   // AVI_DATA
        GEL_TextOut("\t ****  configuring AVI INFOFRAME done   ******* \n","Output",1,1,1);

        WR_MEM_32(0x46C00538 , 0x3);    //DISABLE DEEP COLOR MODE IN DC PACKET
        WR_MEM_32(0x46C009C0 , 0x10);
        WR_MEM_32(0x46C009F8 , 0x3);    //ENABLE AND REPEAT AVI INFOFRAM TRANSMISSON
        WR_MEM_32(0x46C009FC , 0xF);    //ENABLE AND REPEAT GENEERAL PACKET TRANSMISSION
        configure_hdvenc_1080p60();
        GEL_TextOut("\t ****  configuring hdvenc for 1080p60 complete   ******* \n","Output",1,1,1);
    }





    hotmenu PLL_CLOCKS_Config_hdmi_1_86_deep_color()
    {

        unsigned int temp , temp1;
        GEL_TextOut("\t PLL Configuration for HDMI is in progress,Please wait ..... \n","Output",1,1,1);
        DSS_PLL_Config();
        *(unsigned int *)0x481C52C8 = 0x00000001 ; //enable pinmux to select clock from hdmi wrapper to hdvenc
        HDMI_PLL_Config_186();
        DSSClkEnable();
        WR_MEM_32(0x48100100, 0x01031FFF);          // Enabling clocks to DSS modules
        WR_MEM_32(0x48100114, 0xC010F);             // CLKC Video Encoder Clock Select Configuration
        WR_MEM_32(0x48100118, 0xF);                 // CLKC Video Encoder Enable Configuration
        *(unsigned int *)0x48100000 = 0x01000000 ;  // Enable dss start of frame interrupt
        VIDEO_1_PLL_Config();
        GEL_TextOut("\t ****  PLL Configuration for HDMI is completed  ******* \n","Output",1,1,1);


        hdmipinmux_cec_ddc();
        GEL_TextOut("\t ****  hdmi pin mux  complete  ******* \n","Output",1,1,1);

        temp = RD_MEM_32(0x46C00010) ;
        temp1 = ((temp & 0xFFFFFFFE)| 0x1 );
        WR_MEM_32(0x46C00300, temp1);
        temp = 0;
        while (temp ++ < 20 ) {}
        GEL_TextOut("\t ****  wrapper soft reset complete  ******* \n","Output",1,1,1);

        configure_hdmi_phy_deep_color();
        GEL_TextOut("\t ****  configure hdmi phy  complete  ******* \n","Output",1,1,1);

        temp = RD_MEM_32(0x46C00070) ;
        temp1 = temp | 0x00000218;
        WR_MEM_32(0x46C00070, temp1);
        GEL_TextOut("\t ****  cec clock divider config   complete  ******* \n","Output",1,1,1);

        temp = RD_MEM_32(0x46C00044) ;
        temp1 = temp | 0x00001414;
        WR_MEM_32(0x46C00044, temp1);
        GEL_TextOut("\t ****  wrapper debounce  config   complete  ******* \n","Output",1,1,1);

        temp = RD_MEM_32(0x46C00050) ;
        temp1 = temp | 0x006;    // force slave interface
        WR_MEM_32(0x46C00050, temp1);
        GEL_TextOut("\t ****  packing mode configuration    complete  ******* \n","Output",1,1,1);

        WR_MEM_32(0x46C00080, 0x0);
        GEL_TextOut("\t ****  disable audio    complete  ******* \n","Output",1,1,1);

        WR_MEM_32(0x46C00414, 0x1);
        WR_MEM_32(0x46C00424, 0x1);
        GEL_TextOut("\t ****  release HDMI IP CORE reset and release power down of core complete  ******* \n","Output",1,1,1);

        WR_MEM_32(0x46C00524, 0x40);
        GEL_TextOut("\t ****  video action  config of hdmi  complete  ******* \n","Output",1,1,1);

        WR_MEM_32(0x46C00420, 0x37);
        GEL_TextOut("\t ****  config input data bus width done   ******* \n","Output",1,1,1);

        WR_MEM_32(0x46C00528, 0x40);    //VID_dither MODE  CONFIG
        WR_MEM_32(0x46C004CC, 0x1);     //DATA ENABLE CNTRL
        WR_MEM_32(0x46C00420, 0x37);    //ENABLE VSYNC AND HSYNC
        WR_MEM_32(0x46C004F8, 0x0);     //iadjust config to enable vsync
        WR_MEM_32(0x46C00520, 0x10);    //csc is bt709
        WR_MEM_32(0x46C009BC, 0x69);    //enable hdmi
        WR_MEM_32(0x46C00608, 0x20);    //tmds_ctrl
        WR_MEM_32(0x46C00904, 0x0);     //disable n/cts of actrl
        WR_MEM_32(0x46C00950, 0x0);     //disable audio
        WR_MEM_32(0x46C00414, 0x0);     //keep audio  operation in reset state

        GEL_TextOut("\t ****  configuring AVI INFOFRAME   ******* \n","Output",1,1,1);
        WR_MEM_32(0x46C00A00 , 0x82);   // AVI_TYPE
        WR_MEM_32(0x46C00A04 , 0x2);    // AVI_VERS
        WR_MEM_32(0x46C00A08 , 0xD);    // AVI_CHSUM
        WR_MEM_32(0x46C00A10 , 0x1);    // AVI_DATA
        WR_MEM_32(0x46C00A14 , 0xA0);   // AVI_DATA
        WR_MEM_32(0x46C00A1C , 0x8F);   // AVI_DATA
        GEL_TextOut("\t ****  configuring AVI INFOFRAME done   ******* \n","Output",1,1,1);

        WR_MEM_32(0x46C00538 , 0x3);    // DEEP COLOR dynamic phase  IN DC PACKET
        WR_MEM_32(0x46C009C0 , 0x10);
        WR_MEM_32(0x46C009F8 , 0x3);    // ENABLE AND REPEAT AVI INFOFRAM TRANSMISSON
        WR_MEM_32(0x46C009FC , 0x3);    // ENABLE AND REPEAT GENEERAL PACKET TRANSMISSION
        WR_MEM_32(0x46C00C7C , 0x10);
        configure_hdvenc_1080p60();
        GEL_TextOut("\t ****  configuring hdvenc for 1080p60 complete   ******* \n","Output",1,1,1);
    }

   HDMI_PLL_Config_145()
    {
		GEL_TextOut("\t ****  CENTAURUS2 HDMI ADPLL INIT IS in Progress ......... \n","Output",1,1,1);
		cmdHDMIPLL(CLKIN,19, 1485,10);
		GEL_TextOut("\t ****  CENTAURUS2 HDMI ADPLL INIT IS Done ......... \n","Output",1,1,1);
    }


    HDMI_PLL_Config_186()
    {
        GEL_TextOut("\t Centaurus HDMI_PLL Init is in Progress, Please wait ..... \n","Output",1,1,1);
        cmdHDMIPLL(CLKIN,9, 933,10);
        GEL_TextOut("\tCentaurus HDMI_PLL Init is Done \n","Output",1,1,1);
    }


    configure_hdvenc_1080p60()

    {
        /* Encoder CFG 0 to CFG 25 Parameters */

        WR_MEM_32(0x48106000,     0x4003A033);
        WR_MEM_32(0x48106004,     0x003F0275);
        WR_MEM_32(0x48106008,     0x1EA500BB);
        WR_MEM_32(0x4810600C,     0x1F9901C2);
        WR_MEM_32(0x48106010,     0x1FD71E67);
        WR_MEM_32(0x48106014,     0x004001C2);
        WR_MEM_32(0x48106018,     0x00200200);
        WR_MEM_32(0x4810601C,     0x1B6C0C77);
        WR_MEM_32(0x48106020,     0x1C0C0C30);
        WR_MEM_32(0x48106024,     0x1C0C0C30);
        WR_MEM_32(0x48106028,     0x84465898);
        WR_MEM_32(0x4810602C,     0x3F000028);
        WR_MEM_32(0x48106030,     0x587800BF);
        WR_MEM_32(0x48106034,     0x00000460);
        WR_MEM_32(0x48106038,     0x000C39E7);
        WR_MEM_32(0x4810603C,     0x58780118);
        WR_MEM_32(0x48106040,     0x0002A86D);
        WR_MEM_32(0x48106044,     0x00438000);
        WR_MEM_32(0x48106048,     0x05000000);
        WR_MEM_32(0x4810604C,     0x00003000);
        WR_MEM_32(0x48106050,     0x00000000);
        WR_MEM_32(0x48106054,     0x58780110);
        WR_MEM_32(0x48106058,     0x0002A86D);
        WR_MEM_32(0x4810605c,     0x00438000);
        WR_MEM_32(0x48106060,     0x05000000);
        WR_MEM_32(0x48106064,     0x00003000);
        WR_MEM_32(0x48106068,     0x00000000);
        WR_MEM_32(0x4810606c,     0x00000000);

    }

    hdmipinmux_cec_ddc()
    {
        WR_MEM_32(0x481409B8,     0x60010);         //hdmi_cec_mux0 pinmmr111[4]
        WR_MEM_32(0x48140934,     0xE0002);         //hdmi_ddc_scl_mux0 pinmmr78[1]
        WR_MEM_32(0x48140938,     0xE0002);         //hdmi_ddc_sda_mux0 pinmmr79[1]
        WR_MEM_32(0x481409BC,     0x40010);         //hdmi_hpd_mux0 pinmmr112[4]
    }


    configure_hdmi_phy_deep_color()         // PHY configuration for deep colour mode of operation
    {
        unsigned int temp , temp1;
        GEL_TextOut("\tinitialise hdmi phy  config... \n","Output",1,1,1);

        *(unsigned int *)(0x481815B0) =  0x2;
        GEL_TextOut("\t 48 Mhz Clock input to HDMI ie SDIO clock output from PRCM done... \n","Output",1,1,1);

        WR_MEM_32(0x46C00040, 0x8);
        while((RD_MEM_32(0x46C00040) & 0x00000003) != 2);
        GEL_TextOut("\tHDMI PLL CONTROL MODULE IN on STAE DONE... \n","Output",1,1,1);

        WR_MEM_32(0x46C00040, 0x4A);
        while((RD_MEM_32(0x46C00040) & 0x000000FF )  != 0x5A);
        WR_MEM_32(0x46C00040, 0x8A);
        GEL_TextOut("\tinse hdmi reg  config... \n","Output",1,1,1);

        while((RD_MEM_32(0x46C00040) & 0xFF)  != 0xAA);
        GEL_TextOut("\tinitialise   config... \n","Output",1,1,1);

        GEL_TextOut("\tHDMI PHY  IN on STAE DONE... \n","Output",1,1,1);
        temp =   RD_MEM_32(0x46C00300);         /* Dummy read to PHY base to complete the SCP reset process HDMI_PHY_U_BAS*/
        temp = RD_MEM_32(0x46C00300) ;
        temp1 = ((temp & 0x3FFFFFFF)| 0x80000000 );
        WR_MEM_32(0x46C00300, temp1);
        temp = RD_MEM_32(0x46C0030C) ;
        temp1 = ((temp & 0x000FFFFF)| 0x85400000 );
        WR_MEM_32(0x46C0030C, temp1);
        WR_MEM_32(0x46C00304, 0xF0000000);
        GEL_TextOut("\tHDMI PHY  TMDS CLOCK ENABLE DONE ... \n","Output",1,1,1);

        temp = 0;
        while (temp ++ < 20 ) {}

        GEL_TextOut("\tinitialise  hdmi phy  done  \n","Output",1,1,1);
    }


    configure_hdmi_phy()                // PHY configuration for Normal mode of operation
    {
        unsigned int temp , temp1;
        GEL_TextOut("\tinitialise hdmi phy  config... \n","Output",1,1,1);


        *(unsigned int *)(0x481815B0) =  0x2;
        GEL_TextOut("\t48 Mhz Clock input to HDMI ie SDIO clock output from PRCM done... \n","Output",1,1,1);

        WR_MEM_32(0x46C00040, 0x8);


        while((RD_MEM_32(0x46C00040) & 0x00000003) != 2);

        GEL_TextOut("\tHDMI PLL CONTROL MODULE IN on STAE DONE... \n","Output",1,1,1);

        WR_MEM_32(0x46C00040, 0x4A);
        while((RD_MEM_32(0x46C00040) & 0x000000FF )  != 0x5A);

        WR_MEM_32(0x46C00040, 0x8A);
        GEL_TextOut("\t inse hdmi reg  config... \n","Output",1,1,1);

        while((RD_MEM_32(0x46C00040) & 0xFF)  != 0xAA);
        GEL_TextOut("\t initialise   config... \n","Output",1,1,1);


        GEL_TextOut("\tHDMI PHY  IN on STAE DONE... \n","Output",1,1,1);
        temp =   RD_MEM_32(0x46C00300);         /* Dummy read to PHY base to complete the SCP reset process HDMI_PHY_U_BAS*/


        temp = RD_MEM_32(0x46C00300) ;
        temp1 = ((temp & 0x3FFFFFFF)| 0x40000000 );
        WR_MEM_32(0x46C00300, temp1);

        temp = RD_MEM_32(0x46C0030C) ;
        temp1 = ((temp & 0x000FFFFF)| 0x85400000 );
        WR_MEM_32(0x46C0030C, temp1);


        WR_MEM_32(0x46C00304, 0xF0000000);

        GEL_TextOut("\tHDMI PHY  TMDS CLOCK ENABLE DONE ... \n","Output",1,1,1);

        temp = 0;
        while (temp ++ < 20 ) {}
        GEL_TextOut("\tinitialise  hdmi phy  done  \n","Output",1,1,1);
    }

menuitem "3PSW Packet transfer using Digital Loop Back"

    hotmenu CPSW_Transfer_Tx_port1_Rx_port2_DLBK()
    {
        #define IPCPPIBASE              0x4a102000
        #define CPSWSS_SOFT_RESET       0x4a100904
        #define CPSW_SOFT_RESET         0x4a100008
        #define SL1_SOFT_RESET          0x4a10070c
        #define SL2_SOFT_RESET          0x4a10074c
        #define TX0_HDP                 0x4a100200
        #define TX0_CP                  0x4a100240
        #define RX0_HDP                 0x4a100220
        #define STAT_PORT_EN            0x4a10000c
        #define ALE_CONTROL             0x4a100608
        #define ALE_PORTCTL0            0x4a100640
        #define ALE_PORTCTL1            0x4a100644
        #define ALE_PORTCTL2            0x4a100648
        #define SL1_MACCONTROL          0x4a100704
        #define SL2_MACCONTROL          0x4a100744
        #define RX_CONTROL              0x4a100114
        #define TX_CONTROL              0x4a100104
        #define CPSW_PORT_STATE_FORWARD 0x3
        #define RX_DESC_RAM_BASE        0x4a102000
        #define TX_DESC_RAM_BASE        0x4a103000
        #define SRC_ADDRESS             0x40302000 //Address of Source buffer
        #define DST_ADDRESS             0x40303000 //Address of destination buffer
        #define PCK_SIZE                60         //Packet size in bytes

        int i,naddr = 0;
        int temp = 0;
        int poll = 0;
        //Initialize first four words of source buffer
        int data_0 = 0x55555555;
        int data_1 = 0x44444444;
        int data_2 = 0x33333333;
        int data_3 = 0x22222222;
        int Tx_Cppi_Last   = 0xe0120000+PCK_SIZE;// forport1rx_port2tx

        int Rx_Cppi_Length = PCK_SIZE+0x4;
        int write_data = 0;
        int no_data = 0;
        int error_count =0;

        unsigned int*     src_buffer ;
        unsigned int*     dst_buffer ;
        src_buffer   = (int*) SRC_ADDRESS ;
        dst_buffer   =  (int*) DST_ADDRESS ;
        no_data = PCK_SIZE/4;
        if(sata_num == 0x0)
        {
            GEL_TextOut("EMAC source CLK is  SATA0 \n\r");
            EMAC_SATA0_Clkenable();
        }
        else
        {
            GEL_TextOut("EMAC source CLK is  SATA1 \n\r");
            EMAC_SATA1_Clkenable();
        }
        GEL_TextOut("APPLLYING  RESET to CPSW SUBSYSTEM \n\r");
        *(unsigned int *) CPSWSS_SOFT_RESET = 0x1;
        *(unsigned int *) CPSW_SOFT_RESET = 0x1;
        *(unsigned int *) SL1_SOFT_RESET = 0x1;
        *(unsigned int *) SL2_SOFT_RESET = 0x1;

        while(  (*(unsigned int*)(CPSWSS_SOFT_RESET)) != 0x0) { }
        while(  (*(unsigned int*)(CPSW_SOFT_RESET)) != 0x0) { }
        while(  (*(unsigned int*)(SL1_SOFT_RESET)) != 0x0) { }
        while(  (*(unsigned int*)(SL2_SOFT_RESET)) != 0x0) { }

        GEL_TextOut("CPSW SUBSYSTEM is OUT of  RESET \n\r");

        GEL_TextOut(" Initialize State RAM and Completion Pointers to ZERO\n\r");
        //Clear Tx,Rx and completion pointers
        naddr = TX0_HDP;
        for  (i = 1; i <= 16; i++)
        {
            WR_MEM_32(naddr,0x0);
            naddr = naddr + 0x4;
        }
        naddr = TX0_CP;
        for  (i = 1; i <= 16; i++)
        {
            WR_MEM_32(naddr,0x0);
            naddr = naddr + 0x4;
        }

        GEL_TextOut("Placing Transmit Data In Source Buffer    \n\r");
        write_data = 0x0;
        for(i =0;i<no_data;i++)
        {
            *src_buffer   = write_data;
            *src_buffer++;
            write_data = write_data + 0x1;
        }

        naddr = SRC_ADDRESS+0x0;
        WR_MEM_32(naddr,data_0);
        naddr = SRC_ADDRESS+0x4;
        WR_MEM_32(naddr,data_1);
        naddr = SRC_ADDRESS+0x8;
        WR_MEM_32(naddr,data_2);
        naddr = SRC_ADDRESS+0xc;
        WR_MEM_32(naddr,data_3);

        GEL_TextOut("Fill Receive Buffer with Zeros    \n\r");
        for(i = 0;i < no_data+4 ; i ++)
        {
            *dst_buffer   = 0;
            *dst_buffer++;
        }

        GEL_TextOut("Configure theCPSW  registers   \n\r");
        WR_MEM_32(TX_CONTROL ,0x1);
        WR_MEM_32(STAT_PORT_EN,0x7);
        WR_MEM_32(ALE_CONTROL,0x80000010);
        WR_MEM_32(ALE_PORTCTL0,CPSW_PORT_STATE_FORWARD);
        WR_MEM_32(ALE_PORTCTL1,CPSW_PORT_STATE_FORWARD);
        WR_MEM_32(ALE_PORTCTL2,CPSW_PORT_STATE_FORWARD);

        GEL_TextOut("Configure the CPGMAC SL1 registers   \n\r");

        WR_MEM_32(SL1_MACCONTROL,0x8023);
        WR_MEM_32(SL2_MACCONTROL,0x8023);

        GEL_TextOut("Configure the TX CPPI registers   \n\r");
        naddr = IPCPPIBASE+0x1000;
        WR_MEM_32(naddr,0x0);
        naddr = naddr+0x4;
        WR_MEM_32(naddr,SRC_ADDRESS);
        naddr = naddr+0x4;
        WR_MEM_32(naddr,PCK_SIZE);
        naddr = naddr+0x4;
        WR_MEM_32(naddr,Tx_Cppi_Last);

        GEL_TextOut("Configure the RX CPPI registers   \n\r");
        naddr = IPCPPIBASE;
        WR_MEM_32(naddr,0x0);
        naddr = naddr+0x4;
        WR_MEM_32(naddr,DST_ADDRESS);
        naddr = naddr+0x4;
        WR_MEM_32(naddr,Rx_Cppi_Length);
        naddr = naddr+0x4;
        WR_MEM_32(naddr,0x20000000);

        GEL_TextOut("Start Recieve and Transmit DMA  \n\r");
        WR_MEM_32(RX0_HDP,RX_DESC_RAM_BASE);
        WR_MEM_32(RX_CONTROL,0x1);
        WR_MEM_32(TX0_HDP,TX_DESC_RAM_BASE);

        GEL_TextOut("Check for TX Completion\n\r");
        poll = (*(unsigned int *)TX0_HDP);
        while(poll != 0)
        {
            poll = (*(unsigned int *)TX0_HDP);
        }
        GEL_TextOut("Transmission of Data COMPLETED  \n\r");
        GEL_TextOut("TX HDP VALUE IS : %x \n",,,,,*(unsigned int *)TX0_HDP);


        GEL_TextOut("Check for RX completion\n\r");
        poll= (*(unsigned int *)RX0_HDP);
        while(poll != 0)
        {
            poll= (*(unsigned int *)RX0_HDP);
        }

        GEL_TextOut("Receive of Data COMPLETED  \n\r");
        GEL_TextOut("RX HDP VALUE IS : %x \n",,,,,*(unsigned int *)RX0_HDP);

        GEL_TextOut("Checking Received Data with the Transmitted Data \n\r");

        src_buffer   = (int*) SRC_ADDRESS ;
        dst_buffer   =  (int*) DST_ADDRESS ;
        for(i=0;i<no_data;i ++)
        {
            if( (*(int*)(src_buffer)) != (*(int*)(dst_buffer))  )
            {
                GEL_TextOut("DATA MISMATCH \n\r");
                GEL_TextOut(" value at  = %x \n",,,,,src_buffer);
                error_count++;
            }
        *src_buffer++;
        *dst_buffer++;
        }

        if(error_count == 0)
        {
            GEL_TextOut(" ************* DATA TRANSFER TEST PASSED******************** \n\r");
        }
        else
        {
            GEL_TextOut(" ************* DATA TRANSFER TEST FAILED******************** \n\r");
        }

    }

