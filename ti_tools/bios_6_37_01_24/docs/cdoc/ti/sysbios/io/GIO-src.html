<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sysbios.io.GIO</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/*
</span>     2    <span class="comment"> * Copyright (c) 2012, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== GIO.xdc ========
</span>    34    <span class="comment"> *
</span>    35    <span class="comment"> */</span>
    36    
    37    import xdc.rov.ViewInfo;
    38    
    39    import xdc.runtime.Error;
    40    import xdc.runtime.Assert;
    41    import xdc.runtime.IHeap;
    42    import xdc.runtime.knl.Sync;
    43    import xdc.runtime.knl.ISync;
    44    
    45    import ti.sysbios.io.DEV;
    46    import ti.sysbios.knl.Queue;
    47    
    48    <span class="xdoc">/*!
</span>    49    <span class="xdoc"> *  ======== GIO ========
</span>    50    <span class="xdoc"> *  General Purpose IO Manager.
</span>    51    <span class="xdoc"> *
</span>    52    <span class="xdoc"> *  The GIO Manager offers both the issue/reclaim model and the read/write
</span>    53    <span class="xdoc"> *  model to send and receive data from drivers that implement the IOM
</span>    54    <span class="xdoc"> *  interface as provided in ti/sysbios/io/iom.h. 
</span>    55    <span class="xdoc"> *
</span>    56    <span class="xdoc"> *  In the issue/reclaim model, the client calls {<b>@link</b> #issue} when he has
</span>    57    <span class="xdoc"> *  a buffer of data.  issue() is non-blocking and returns -- it simply
</span>    58    <span class="xdoc"> *  submits the buffer to the driver for I/O.  The client calls
</span>    59    <span class="xdoc"> *  {<b>@link</b> #reclaim} to get the buffer back.  A call to reclaim() may block.
</span>    60    <span class="xdoc"> *  Upon return from reclaim(), the client can re-use the buffer. 
</span>    61    <span class="xdoc"> *
</span>    62    <span class="xdoc"> *  The client can issue many buffers before reclaiming them.
</span>    63    <span class="xdoc"> *  Buffers are always reclaimed in the order that they were issued.
</span>    64    <span class="xdoc"> *  The client can optionally pass a user argument to issue().  This argument
</span>    65    <span class="xdoc"> *  can be retrieved with reclaim().
</span>    66    <span class="xdoc"> *
</span>    67    <span class="xdoc"> *  In the read/write model, clients will call {<b>@link</b> #read} or {<b>@link</b> #write}
</span>    68    <span class="xdoc"> *  to send/receive data. Here the client may block until buffer is ready or 
</span>    69    <span class="xdoc"> *  a timeout occurs.
</span>    70    <span class="xdoc"> *
</span>    71    <span class="xdoc"> *  The GIO module also provides {<b>@link</b> #control} to send down driver specific
</span>    72    <span class="xdoc"> *  control  commands.  The {<b>@link</b> #abort} function can be used to abort any
</span>    73    <span class="xdoc"> *  pending I/O.
</span>    74    <span class="xdoc"> *
</span>    75    <span class="xdoc"> *  The {<b>@link</b> ti.sysbios.io.DEV} module maintains a name table of IOM drivers.
</span>    76    <span class="xdoc"> *  This table is used by GIO to create an IO stack. The name passed to
</span>    77    <span class="xdoc"> *  {<b>@link</b> #create} is usually of the form "/uart". This name may
</span>    78    <span class="xdoc"> *  correspond to the following IO stack.
</span>    79    <span class="xdoc"> *
</span>    80    <span class="xdoc"> *         GIO Instance
</span>    81    <span class="xdoc"> *
</span>    82    <span class="xdoc"> *              |
</span>    83    <span class="xdoc"> *              v
</span>    84    <span class="xdoc"> *
</span>    85    <span class="xdoc"> *         IOM Instance (/uart)
</span>    86    <span class="xdoc"> *
</span>    87    <span class="xdoc"> *  The GIO module uses the {<b>@link</b> xdc.runtime.knl.Sync} module for
</span>    88    <span class="xdoc"> *  synchronization.  GIO will call {<b>@link</b> xdc.runtime.knl.Sync#signal} when 
</span>    89    <span class="xdoc"> *  I/O completes and {<b>@link</b> xdc.runtime.knl.Sync#wait} to wait for I/O.
</span>    90    <span class="xdoc"> *
</span>    91    <span class="xdoc"> *  By default the I/O manager will create a semaphore for synchronization
</span>    92    <span class="xdoc"> *  if no sync handle is passed to {<b>@link</b> #create}. 
</span>    93    <span class="xdoc"> */</span>
    94    
    95    @InstanceFinalize
    96    @InstanceInitError
    97    
    98    <span class=key>module</span> GIO 
    99    {
   100        <span class="xdoc">/*! Init function type definition. */</span>
   101        <span class=key>typedef</span> Void (*InitFxn)();
   102    
   103        <span class="comment">/* these must stay in synch with modes in iom.h */</span>
   104        <span class=key>const</span> UInt INPUT  = 0x1;      <span class="xdoc">/*! mode for input */</span>
   105        <span class=key>const</span> UInt OUTPUT = 0x2;      <span class="xdoc">/*! mode for output */</span>
   106        <span class=key>const</span> UInt INOUT  = 0x3;      <span class="xdoc">/*! mode for input &amp; output */</span>
   107        
   108        <span class="xdoc">/*! 
</span>   109    <span class="xdoc">     *  Error raised when name not found in DeviceTable.
</span>   110    <span class="xdoc">     */</span>
   111        <span class=key>config</span> Error.Id E_notFound  = {
   112            msg: <span class="string">"E_notFound: %s name not found"</span>
   113        };
   114    
   115        <span class="xdoc">/*! 
</span>   116    <span class="xdoc">     *  Error raised when driver's mdCreateChan() call fails
</span>   117    <span class="xdoc">     */</span>
   118        <span class=key>config</span> Error.Id E_createFailed  = {
   119            msg: <span class="string">"E_createFailed: mdCreateChan returned error %d"</span>
   120        };
   121    
   122        <span class="xdoc">/*! 
</span>   123    <span class="xdoc">     *  Asserted in GIO_read(), GIO_write() if I/O model is not
</span>   124    <span class="xdoc">     *  STANDARD or in GIO_issue(), GIO_reclaim(), or GIO_prime() if the
</span>   125    <span class="xdoc">     *  I/O model is not ISSUERECLAIM.
</span>   126    <span class="xdoc">     */</span>
   127        <span class=key>config</span> Assert.Id A_badModel = {
   128            msg: <span class="string">"A_badModel: invalid use of API for current I/O model"</span> 
   129        };
   130        
   131        <span class="xdoc">/*!
</span>   132    <span class="xdoc">     *  ======== deviceTableSize ========
</span>   133    <span class="xdoc">     *  This configuration parameter has been deprecated.  Use DEV.tableSize.
</span>   134    <span class="xdoc">     */</span>
   135        <span class=key>config</span> Int deviceTableSize = 8;
   136    
   137        <span class=key>metaonly</span> <span class=key>struct</span> BasicView {
   138            String              label;
   139            UInt                freeCount;
   140            UInt                doneCount;
   141            UInt                submitCount;
   142            String              model;
   143            String              mode;
   144            Bool                userSuppliedSync;
   145        }
   146        
   147        @Facet
   148        <span class=key>metaonly</span> <span class=key>config</span> ViewInfo.Instance rovViewInfo = 
   149            ViewInfo.create({
   150                viewMap: [
   151                    [<span class="string">'Basic'</span>, {type: ViewInfo.INSTANCE, viewInitFxn: <span class="string">'viewInitBasic'</span>, structName: <span class="string">'BasicView'</span>}],
   152                ]
   153            });
   154    
   155        <span class="xdoc">/*! model for IO channel */</span>
   156        <span class=key>enum</span> Model {
   157            Model_STANDARD,        <span class="xdoc">/*! used for read, write, submit */</span> 
   158            Model_ISSUERECLAIM     <span class="xdoc">/*! used for issue, reclaim, prime */</span>
   159        };
   160    
   161        <span class="xdoc">/*! application callback function used with GIO_submit() */</span>
   162        <span class=key>typedef</span> Void (*TappCallBack)(Ptr, Int, Ptr, SizeT);
   163    
   164        <span class="xdoc">/*!
</span>   165    <span class="xdoc">     *  Application Callback Structure.
</span>   166    <span class="xdoc">     *
</span>   167    <span class="xdoc">     *  Used with GIO_submit() for asynchronous callback.
</span>   168    <span class="xdoc">     */</span>
   169        <span class=key>struct</span> AppCallback {
   170            TappCallBack    fxn;
   171            Ptr             arg;
   172        };
   173    
   174        <span class="xdoc">/*!
</span>   175    <span class="xdoc">     *  ======== addDevice ========
</span>   176    <span class="xdoc">     *  This API has been deprecated.  Use DEV_create().
</span>   177    <span class="xdoc">     */</span>
   178        @DirectCall
   179        Int addDevice(String name, Ptr fxns, InitFxn initFxn, Int devid, Ptr params);
   180    
   181        <span class="xdoc">/*!
</span>   182    <span class="xdoc">     *  ======== addDeviceMeta ========
</span>   183    <span class="xdoc">     *  This API has been deprecated.  Use DEV.create().
</span>   184    <span class="xdoc">     */</span>
   185        <span class=key>metaonly</span> Void addDeviceMeta(String name, String fxns, String initFxn, Int devid, String params);
   186    
   187        <span class="xdoc">/*!
</span>   188    <span class="xdoc">     *  ======== removeDevice ========
</span>   189    <span class="xdoc">     *  This API has been deprecated.  Use DEV_match() and DEV_delete().
</span>   190    <span class="xdoc">     */</span>
   191        @DirectCall
   192        Int removeDevice(String name);
   193    
   194    <span class=key>instance</span>:
   195    
   196        <span class="xdoc">/*!
</span>   197    <span class="xdoc">     *  ======== model ========
</span>   198    <span class="xdoc">     *  I/O model
</span>   199    <span class="xdoc">     *
</span>   200    <span class="xdoc">     *  Set the model to STANDARD to use read(), write() and submit() APIs.   
</span>   201    <span class="xdoc">     *  Set the model to ISSUERECLAIM to use issue(), reclaim(), and
</span>   202    <span class="xdoc">     *  prime() APIs.   
</span>   203    <span class="xdoc">     *
</span>   204    <span class="xdoc">     *  The default for this parameter is STANDARD.
</span>   205    <span class="xdoc">     */</span>
   206        <span class=key>config</span> Model model = Model_STANDARD;
   207    
   208        <span class="xdoc">/*! Number of packets to use for asynchronous I/O */</span>
   209        <span class=key>config</span> Int numPackets = 2;
   210    
   211        <span class="xdoc">/*! For blocking calls.  Default is BIOS_WAIT_FOREVER */</span>
   212        <span class=key>config</span> UInt timeout = ~(0);
   213    
   214        <span class="xdoc">/*! ISync handle used to signal IO completion */</span>
   215        <span class=key>config</span> ISync.Handle sync = <span class=key>null</span>;
   216    
   217        <span class="xdoc">/*!
</span>   218    <span class="xdoc">     *  ======== chanParams ========
</span>   219    <span class="xdoc">     *  channel parameters
</span>   220    <span class="xdoc">     *
</span>   221    <span class="xdoc">     *  The chanParams parameter is a pointer that may be used to pass device
</span>   222    <span class="xdoc">     *  or domain-specific arguments to the mini-driver. The contents at the
</span>   223    <span class="xdoc">     *  specified address are interpreted by the mini-driver in a
</span>   224    <span class="xdoc">     *  device-specific manner.  
</span>   225    <span class="xdoc">     */</span>
   226        <span class=key>config</span> Ptr chanParams = <span class=key>null</span>;
   227    
   228        <span class="xdoc">/*!
</span>   229    <span class="xdoc">     *  ======== abort ========
</span>   230    <span class="xdoc">     *  Abort all pending IO.
</span>   231    <span class="xdoc">     *
</span>   232    <span class="xdoc">     *  An application calls GIO_abort to abort all input and output from
</span>   233    <span class="xdoc">     *  the device. When this call is made, all pending calls are completed
</span>   234    <span class="xdoc">     *  with a status of GIO_ABORTED. An application uses this call to
</span>   235    <span class="xdoc">     *  return the device to its initial state. Usually this is done in
</span>   236    <span class="xdoc">     *  response to an unrecoverable error at the device level.
</span>   237    <span class="xdoc">     *
</span>   238    <span class="xdoc">     *  GIO_abort returns IOM_COMPLETED upon successfully aborting all
</span>   239    <span class="xdoc">     *  input and output requests. If an error occurs, the device returns a
</span>   240    <span class="xdoc">     *  negative value.  The list of error values are defined in the 
</span>   241    <span class="xdoc">     *  ti/sysbios/io/iom.h file.
</span>   242    <span class="xdoc">     *
</span>   243    <span class="xdoc">     *  A call to GIO_abort results in a call to the mdSubmit function of the
</span>   244    <span class="xdoc">     *  associated mini-driver. The IOM_ABORT command is passed to the
</span>   245    <span class="xdoc">     *  mdSubmit function. The mdSubmit call is typically a blocking call, so
</span>   246    <span class="xdoc">     *  calling GIO_abort can result in the thread blocking.
</span>   247    <span class="xdoc">     *
</span>   248    <span class="xdoc">     *  If using ISSUERECLAIM IO model, the the underlying device
</span>   249    <span class="xdoc">     *  connected to stream is idled as a result of calling abort and
</span>   250    <span class="xdoc">     *  all buffers are ready for reclaim().  The client needs to call
</span>   251    <span class="xdoc">     *  {<b>@link</b> #reclaim} to get back the buffers.  However the client will
</span>   252    <span class="xdoc">     *  NOT block when calling reclaim() after an abort().
</span>   253    <span class="xdoc">     *
</span>   254    <span class="xdoc">     *  <b>@b(returns)</b>         IOM_COMPLETED on success, &lt; 0 on failure  
</span>   255    <span class="xdoc">     */</span>
   256        @DirectCall
   257        Int abort();
   258    
   259        <span class="xdoc">/*!
</span>   260    <span class="xdoc">     *  ======== control ========
</span>   261    <span class="xdoc">     *  Send a control command to the driver.
</span>   262    <span class="xdoc">     *
</span>   263    <span class="xdoc">     *  An application calls GIO_control to configure or perform control
</span>   264    <span class="xdoc">     *  functionality on the communication channel.
</span>   265    <span class="xdoc">     *
</span>   266    <span class="xdoc">     *  The cmd parameter may be one of the command code constants listed in
</span>   267    <span class="xdoc">     *  ti/sysbios/io/iom.h. A mini-driver may add command codes for
</span>   268    <span class="xdoc">     *  additional functionality.
</span>   269    <span class="xdoc">     *
</span>   270    <span class="xdoc">     *  The args parameter points to a data structure defined by the device to
</span>   271    <span class="xdoc">     *  allow control information to be passed between the device and the
</span>   272    <span class="xdoc">     *  application. This structure can be generic across a domain or
</span>   273    <span class="xdoc">     *  specific to a mini-driver. In some cases, this argument may point
</span>   274    <span class="xdoc">     *  directly to a buffer holding control data. In other cases, there
</span>   275    <span class="xdoc">     *  may be a level of indirection if the mini-driver expects a data
</span>   276    <span class="xdoc">     *  structure to package many components of data required for the control
</span>   277    <span class="xdoc">     *  operation. In the simple case where no data is required, this 
</span>   278    <span class="xdoc">     *  parameter may just be a predefined command value.
</span>   279    <span class="xdoc">     *
</span>   280    <span class="xdoc">     *  GIO_control returns IOM_COMPLETED upon success. If an error occurs,
</span>   281    <span class="xdoc">     *  the device returns a negative value. For a list of error values, see 
</span>   282    <span class="xdoc">     *  ti/sysbios/io/iom.h.  A call to GIO_control results in a call to
</span>   283    <span class="xdoc">     *  the mdControl function of the associated mini-driver. The mdControl
</span>   284    <span class="xdoc">     *  call is typically a blocking call, so calling GIO_control can result
</span>   285    <span class="xdoc">     *  in blocking.
</span>   286    <span class="xdoc">     *
</span>   287    <span class="xdoc">     *  <b>@param(cmd)</b>         device specific command
</span>   288    <span class="xdoc">     *  <b>@param(args)</b>        pointer to device-specific arguments
</span>   289    <span class="xdoc">     *  <b>@b(returns)</b>         IOM_COMPLETED on success, &lt; 0 on failure  
</span>   290    <span class="xdoc">     */</span>
   291        @DirectCall
   292        Int control(UInt cmd, Ptr args);
   293    
   294        <span class="xdoc">/*!
</span>   295    <span class="xdoc">     *  ======== create ========
</span>   296    <span class="xdoc">     *  Create a GIO Instance.
</span>   297    <span class="xdoc">     *
</span>   298    <span class="xdoc">     *  An application calls GIO_create to create a GIO_Obj object and open
</span>   299    <span class="xdoc">     *  a communication channel. This function initializes the I/O channel
</span>   300    <span class="xdoc">     *  and opens the lower-level device driver channel. The GIO_create call
</span>   301    <span class="xdoc">     *  also creates the synchronization objects it uses and stores them in
</span>   302    <span class="xdoc">     *  the GIO_Obj object.
</span>   303    <span class="xdoc">     *
</span>   304    <span class="xdoc">     *  The name argument is the name specified for the device when it was
</span>   305    <span class="xdoc">     *  created in the configuration or at runtime.
</span>   306    <span class="xdoc">     *
</span>   307    <span class="xdoc">     *  The mode argument specifies the mode in which the device is to be
</span>   308    <span class="xdoc">     *  opened. This may be IOM_INPUT, IOM_OUTPUT, or IOM_INOUT.  
</span>   309    <span class="xdoc">     *
</span>   310    <span class="xdoc">     *  If the status returned by the device is non-NULL, a status value is
</span>   311    <span class="xdoc">     *  placed at the address specified by the status parameter.  
</span>   312    <span class="xdoc">     *
</span>   313    <span class="xdoc">     *  The GIO_create call allocates a list of IOM_Packet items as specified
</span>   314    <span class="xdoc">     *  by the numPackets member of the params structure and stores them in
</span>   315    <span class="xdoc">     *  the GIO_Obj object it creates.
</span>   316    <span class="xdoc">     *
</span>   317    <span class="xdoc">     *  <b>@param(name)</b>        name that identifies the IO stack
</span>   318    <span class="xdoc">     *  <b>@param(mode)</b>        mode of channel
</span>   319    <span class="xdoc">     */</span>
   320        @DirectCall
   321        create(String name, UInt mode);
   322    
   323        <span class="xdoc">/*!
</span>   324    <span class="xdoc">     *  ======== flush ========
</span>   325    <span class="xdoc">     *  Drain output buffers and discard any pending input
</span>   326    <span class="xdoc">     * 
</span>   327    <span class="xdoc">     *  An application calls GIO_flush to flush the input and output
</span>   328    <span class="xdoc">     *  channels of the device.  All input data is discarded; all pending
</span>   329    <span class="xdoc">     *  output requests are completed.  When this call is made, all pending
</span>   330    <span class="xdoc">     *  input calls are completed with a status of IOM_FLUSHED, and all
</span>   331    <span class="xdoc">     *  output calls are completed routinely.
</span>   332    <span class="xdoc">     *
</span>   333    <span class="xdoc">     *  This call returns IOM_COMPLETED upon successfully flushing all
</span>   334    <span class="xdoc">     *  input and output.  If an error occurs, the device returns a negative
</span>   335    <span class="xdoc">     *  value. For a list of error values, see ti/sysbios/io/iom.h.
</span>   336    <span class="xdoc">     *
</span>   337    <span class="xdoc">     *  A call to GIO_flush results in a call to the mdSubmit function of
</span>   338    <span class="xdoc">     *  the associated mini-driver. The IOM_FLUSH command is passed to the
</span>   339    <span class="xdoc">     *  mdSubmit function. The mdSubmit call is typically a blocking call,
</span>   340    <span class="xdoc">     *  so calling GIO_flush can result in the thread blocking while waiting
</span>   341    <span class="xdoc">     *  for output calls to be completed.
</span>   342    <span class="xdoc">     *
</span>   343    <span class="xdoc">     *  <b>@b(returns)</b>         IOM_COMPLETED on success, &lt; 0 on failure  
</span>   344    <span class="xdoc">     */</span>
   345        @DirectCall
   346        Int flush();
   347    
   348        <span class="xdoc">/*!
</span>   349    <span class="xdoc">     *  ======== issue ========
</span>   350    <span class="xdoc">     *  Issue a buffer to the stream.
</span>   351    <span class="xdoc">     *
</span>   352    <span class="xdoc">     *  This function issues a buffer to the stream for IO. This API is
</span>   353    <span class="xdoc">     *  non-blocking.
</span>   354    <span class="xdoc">     *
</span>   355    <span class="xdoc">     *  Failure of issue() indicates that the stream was not able to accept the
</span>   356    <span class="xdoc">     *  buffer being issued or that there was a error from the underlying
</span>   357    <span class="xdoc">     *  driver. Note that the error could be driver specific.
</span>   358    <span class="xdoc">     *  If issue() fails because of an underlying driver problem
</span>   359    <span class="xdoc">     *  {<b>@link</b> #abort} should be called before attempting more I/O through the 
</span>   360    <span class="xdoc">     *  stream.
</span>   361    <span class="xdoc">     *
</span>   362    <span class="xdoc">     *  The interpretation of the logical size of a buffer, is direction
</span>   363    <span class="xdoc">     *  dependent.  For a stream opened in OUTPUT mode, the logical size
</span>   364    <span class="xdoc">     *  of the buffer indicates the number of minimum addressable units of of 
</span>   365    <span class="xdoc">     *  data it contains. 
</span>   366    <span class="xdoc">     *
</span>   367    <span class="xdoc">     *  For a stream opened in INPUT mode, the logical size 
</span>   368    <span class="xdoc">     *  of a buffer indicates the number of minimum addressable units being 
</span>   369    <span class="xdoc">     *  requested by the client. In either case, the logical size of the buffer 
</span>   370    <span class="xdoc">     *  must be less than or equal to the physical size of the buffer.
</span>   371    <span class="xdoc">     *
</span>   372    <span class="xdoc">     *  issue() is used in conjunction with {<b>@link</b> #reclaim}. The issue() call 
</span>   373    <span class="xdoc">     *  sends a buffer to a stream, and reclaim() retrieves a buffer 
</span>   374    <span class="xdoc">     *  from a stream. In normal operation each issue() call is followed by an 
</span>   375    <span class="xdoc">     *  reclaim() call.
</span>   376    <span class="xdoc">     *
</span>   377    <span class="xdoc">     *  Short bursts of multiple issue() calls can be made without an
</span>   378    <span class="xdoc">     *  intervening reclaim() call followed by short bursts of reclaim() calls, 
</span>   379    <span class="xdoc">     *  but over the life of the stream issue() and reclaim() must be called 
</span>   380    <span class="xdoc">     *  the same number of times. The number of issue() calls can exceed the 
</span>   381    <span class="xdoc">     *  number of reclaim() calls by {<b>@link</b> #maxIssues}.
</span>   382    <span class="xdoc">     *
</span>   383    <span class="xdoc">     *  The client argument is not interpreted by IO or the underlying 
</span>   384    <span class="xdoc">     *  modules, but is offered as a service to the stream client. All compliant
</span>   385    <span class="xdoc">     *  device drivers preserve the value of arg and maintain its association 
</span>   386    <span class="xdoc">     *  with the data that it was issued with. arg provides a method for a 
</span>   387    <span class="xdoc">     *  client to associate additional information with a particular buffer of 
</span>   388    <span class="xdoc">     *  data. The arg is returned during reclaim().
</span>   389    <span class="xdoc">     *
</span>   390    <span class="xdoc">     *  <b>@param(buf)</b>         buffer pointer
</span>   391    <span class="xdoc">     *  <b>@param(size)</b>        size of buffer
</span>   392    <span class="xdoc">     *  <b>@param(arg)</b>         application arg
</span>   393    <span class="xdoc">     *  <b>@b(returns)</b>         IOM_COMPLETED on success, &lt; 0 on failure  
</span>   394    <span class="xdoc">     *  
</span>   395    <span class="xdoc">     */</span>
   396        @DirectCall
   397        Int issue(Ptr buf, SizeT size, UArg arg);
   398    
   399        <span class="xdoc">/*!
</span>   400    <span class="xdoc">     *  ======== reclaim ========
</span>   401    <span class="xdoc">     *  Reclaim a buffer that was previously issued by calling {<b>@link</b> #issue}.
</span>   402    <span class="xdoc">     *
</span>   403    <span class="xdoc">     *  reclaim() is used to request a buffer back from a stream. 
</span>   404    <span class="xdoc">     *
</span>   405    <span class="xdoc">     *  If a stream was created in OUTPUT mode, then reclaim() returns a
</span>   406    <span class="xdoc">     *  processed buffer, and size is zero.  If a stream was opened in
</span>   407    <span class="xdoc">     *  INPUT mode, reclaim() returns a full buffer, and size is the number
</span>   408    <span class="xdoc">     *  of minimum addressable units of data in the buffer.
</span>   409    <span class="xdoc">     *
</span>   410    <span class="xdoc">     *  reclaim() calls Sync_wait() with the timeout specified when the 
</span>   411    <span class="xdoc">     *  channel was created.  For the default SyncSem, reclaim() blocks
</span>   412    <span class="xdoc">     *  until a buffer can be returned to the caller, or until a timeout occurs.
</span>   413    <span class="xdoc">     *
</span>   414    <span class="xdoc">     *  Failure of reclaim() indicates that no buffer was returned to 
</span>   415    <span class="xdoc">     *  the  client. Therefore, if reclaim() fails, the client should 
</span>   416    <span class="xdoc">     *  not attempt to de-reference pBuf, since it is not guaranteed to contain
</span>   417    <span class="xdoc">     *  a valid buffer pointer.
</span>   418    <span class="xdoc">     *
</span>   419    <span class="xdoc">     *  reclaim() is used in conjunction with {<b>@link</b> #issue} to operate 
</span>   420    <span class="xdoc">     *  a stream. The issue() call sends a buffer to a stream, and 
</span>   421    <span class="xdoc">     *  reclaim() retrieves a  buffer from a stream. In normal operation
</span>   422    <span class="xdoc">     *  each issue call is followed by an reclaim call.
</span>   423    <span class="xdoc">     *
</span>   424    <span class="xdoc">     *  Short bursts of multiple issue() calls can be made without an
</span>   425    <span class="xdoc">     *  intervening reclaim() call followed by short bursts of reclaim() calls, 
</span>   426    <span class="xdoc">     *  but over the life of the stream issue() and reclaim() must be called 
</span>   427    <span class="xdoc">     *  the same number of times. The number of issue() calls can exceed the 
</span>   428    <span class="xdoc">     *  number of reclaim() calls by {<b>@link</b> #maxIssues}.
</span>   429    <span class="xdoc">     *
</span>   430    <span class="xdoc">     *  A reclaim() call should not be made without at least one 
</span>   431    <span class="xdoc">     *  outstanding issue() call. Calling reclaim() with no 
</span>   432    <span class="xdoc">     *  outstanding issue() calls results in an error {<b>@link</b> #E_noBuffersIssued}
</span>   433    <span class="xdoc">     *
</span>   434    <span class="xdoc">     *  reclaim() only returns buffers that were passed in using issue(). It 
</span>   435    <span class="xdoc">     *  also returns the buffers in the same order that they were issued.
</span>   436    <span class="xdoc">     *
</span>   437    <span class="xdoc">     *  reclaim() returns the size transferred in case of success.
</span>   438    <span class="xdoc">     *  It returns zero when an error is caught. In case of timeout, the error 
</span>   439    <span class="xdoc">     *  is {<b>@link</b> #E_timeout}.
</span>   440    <span class="xdoc">     *
</span>   441    <span class="xdoc">     *  <b>@param(pBuf)</b>        returned buffer pointer
</span>   442    <span class="xdoc">     *  <b>@param(pSize)</b>       pointer to size of buffer (OUTPUT parameter)
</span>   443    <span class="xdoc">     *  <b>@param(pArg)</b>        pointer to client arg. Can be null.
</span>   444    <span class="xdoc">     *  <b>@b(returns)</b>         IOM_COMPLETED on success, &lt; 0 on failure  
</span>   445    <span class="xdoc">     *  
</span>   446    <span class="xdoc">     */</span>
   447        @DirectCall
   448        Int reclaim(Ptr *pBuf, SizeT *pSize, UArg *pArg);
   449    
   450        <span class="xdoc">/*!
</span>   451    <span class="xdoc">     *  ======== read ========
</span>   452    <span class="xdoc">     *  Synchronous read command
</span>   453    <span class="xdoc">     *
</span>   454    <span class="xdoc">     *  An application calls GIO_read to read a specified number of MADUs
</span>   455    <span class="xdoc">     *  (minimum addressable data units) from the communication channel.  
</span>   456    <span class="xdoc">     *
</span>   457    <span class="xdoc">     *  The buf parameter points to a device-defined data structure for
</span>   458    <span class="xdoc">     *  passing buffer data between the device and the application. This
</span>   459    <span class="xdoc">     *  structure may be generic across a domain or specific to a single
</span>   460    <span class="xdoc">     *  mini-driver. In some cases, this parameter may point directly to a
</span>   461    <span class="xdoc">     *  buffer that holds the read data. In other cases, this parameter may
</span>   462    <span class="xdoc">     *  point to a structure that packages buffer information, size, offset
</span>   463    <span class="xdoc">     *  to be read from, and other device-dependent data. For example, for
</span>   464    <span class="xdoc">     *  video capture devices this structure may contain pointers to RGB
</span>   465    <span class="xdoc">     *  buffers, their sizes, video format, and a host of data required for
</span>   466    <span class="xdoc">     *  reading a frame from a video capture device.  Upon a successful read,
</span>   467    <span class="xdoc">     *  this argument points to the returned data. 
</span>   468    <span class="xdoc">     *
</span>   469    <span class="xdoc">     *  The pSize parameter points to the size of the buffer or data
</span>   470    <span class="xdoc">     *  structure pointed to by the buf parameter. When the function
</span>   471    <span class="xdoc">     *  returns, this parameter points to the number of MADUs read from the
</span>   472    <span class="xdoc">     *  device. This parameter is relevant only if the buf parameter points
</span>   473    <span class="xdoc">     *  to a raw data buffer. In cases where it points to a device-defined
</span>   474    <span class="xdoc">     *  structure it is redundant -- the size of the structure is known to
</span>   475    <span class="xdoc">     *  the mini-driver and the application. At most, it can be used for
</span>   476    <span class="xdoc">     *  error checking.
</span>   477    <span class="xdoc">     *
</span>   478    <span class="xdoc">     *  GIO_read returns IOM_COMPLETED upon successfully reading the
</span>   479    <span class="xdoc">     *  requested number of MADUs from the device. If an error occurs,
</span>   480    <span class="xdoc">     *  the device returns a negative value. For a list of error values,
</span>   481    <span class="xdoc">     *  see ti/sybios/io/iom.h. 
</span>   482    <span class="xdoc">     *
</span>   483    <span class="xdoc">     *  A call to GIO_read results in a call to the mdSubmit function of
</span>   484    <span class="xdoc">     *  the associated mini-driver. The IOM_READ command is passed to the
</span>   485    <span class="xdoc">     *  mdSubmit function. The mdSubmit call is typically a blocking call,
</span>   486    <span class="xdoc">     *  so calling GIO_read can result in the thread blocking.
</span>   487    <span class="xdoc">     *
</span>   488    <span class="xdoc">     *  <b>@param(buf)</b>         buffer pointer
</span>   489    <span class="xdoc">     *  <b>@param(pSize)</b>       pointer to size of buffer (INPUT/OUTPUT parameter)
</span>   490    <span class="xdoc">     *  <b>@b(returns)</b>         IOM_COMPLETED on success, &lt; 0 on failure  
</span>   491    <span class="xdoc">     */</span>
   492        @DirectCall
   493        Int read(Ptr buf, SizeT *pSize);  
   494    
   495        <span class="xdoc">/*!
</span>   496    <span class="xdoc">     *  ======== write ========
</span>   497    <span class="xdoc">     *  Synchronous write command
</span>   498    <span class="xdoc">     *
</span>   499    <span class="xdoc">     *  An application calls GIO_write to write a specified number of MADUs
</span>   500    <span class="xdoc">     *  (minimum addressable data units) from the communication channel.  
</span>   501    <span class="xdoc">     *
</span>   502    <span class="xdoc">     *  The buf parameter points to a device-defined data structure for
</span>   503    <span class="xdoc">     *  passing buffer data between the device and the application. This
</span>   504    <span class="xdoc">     *  structure may be generic across a domain or specific to a single
</span>   505    <span class="xdoc">     *  mini-driver. In some cases, this parameter may point directly to a
</span>   506    <span class="xdoc">     *  buffer that holds the write data. In other cases, this parameter may
</span>   507    <span class="xdoc">     *  point to a structure that packages buffer information, size, offset
</span>   508    <span class="xdoc">     *  to be write from, and other device-dependent data. For example, for
</span>   509    <span class="xdoc">     *  video capture devices this structure may contain pointers to RGB
</span>   510    <span class="xdoc">     *  buffers, their sizes, video format, and a host of data required for
</span>   511    <span class="xdoc">     *  reading a frame from a video capture device.
</span>   512    <span class="xdoc">     *
</span>   513    <span class="xdoc">     *  The pSize parameter points to the size of the buffer or data
</span>   514    <span class="xdoc">     *  structure pointed to by the buf parameter. When the function
</span>   515    <span class="xdoc">     *  returns, this parameter points to the number of MADUs written to the
</span>   516    <span class="xdoc">     *  device. This parameter is relevant only if the buf parameter points
</span>   517    <span class="xdoc">     *  to a raw data buffer. In cases where it points to a device-defined
</span>   518    <span class="xdoc">     *  structure it is redundant -- the size of the structure is known to
</span>   519    <span class="xdoc">     *  the mini-driver and the application. At most, it can be used for
</span>   520    <span class="xdoc">     *  error checking.
</span>   521    <span class="xdoc">     *
</span>   522    <span class="xdoc">     *  GIO_write returns IOM_COMPLETED upon successfully writing the
</span>   523    <span class="xdoc">     *  requested number of MADUs from the device. If an error occurs,
</span>   524    <span class="xdoc">     *  the device returns a negative value. For a list of error values,
</span>   525    <span class="xdoc">     *  see ti/sybios/io/iom.h. 
</span>   526    <span class="xdoc">     *
</span>   527    <span class="xdoc">     *  A call to GIO_write results in a call to the mdSubmit function of
</span>   528    <span class="xdoc">     *  the associated mini-driver. The IOM_WRITE command is passed to the
</span>   529    <span class="xdoc">     *  mdSubmit function. The mdSubmit call is typically a blocking call,
</span>   530    <span class="xdoc">     *  so calling GIO_write can result in the thread blocking.
</span>   531    <span class="xdoc">     *
</span>   532    <span class="xdoc">     *  <b>@param(buf)</b>         buffer pointer
</span>   533    <span class="xdoc">     *  <b>@param(pSize)</b>       pointer to size of buffer (INPUT/OUTPUT parameter)
</span>   534    <span class="xdoc">     *  <b>@b(returns)</b>         IOM_COMPLETED on success, &lt; 0 on failure  
</span>   535    <span class="xdoc">     */</span>
   536        @DirectCall
   537        Int write(Ptr buf, SizeT *pSize);  
   538    
   539        <span class="xdoc">/*!
</span>   540    <span class="xdoc">     *  ======== submit ========
</span>   541    <span class="xdoc">     *  Submit an IO job to the mini-driver
</span>   542    <span class="xdoc">     *
</span>   543    <span class="xdoc">     *  GIO_submit is not typically called by applications. Instead, it is
</span>   544    <span class="xdoc">     *  used internally and for user-defined extensions to the GIO module.
</span>   545    <span class="xdoc">     *
</span>   546    <span class="xdoc">     *  The cmd parameter is IOM_READ, IOM_WRITE, IOM_ABORT or IOM_FLUSH
</span>   547    <span class="xdoc">     *  when used internally.  A mini driver may add command codes for 
</span>   548    <span class="xdoc">     *  additional functionality.
</span>   549    <span class="xdoc">     *
</span>   550    <span class="xdoc">     *  The bufp parameter points to a device-defined data structure for
</span>   551    <span class="xdoc">     *  passing buffer data between the device and the application. This
</span>   552    <span class="xdoc">     *  structure may be generic across a domain or specific to a single
</span>   553    <span class="xdoc">     *  mini-driver. In some cases, this parameter may point directly to
</span>   554    <span class="xdoc">     *  a buffer that holds the data. In other cases, this parameter may
</span>   555    <span class="xdoc">     *  point to a structure that packages buffer information, size, offset
</span>   556    <span class="xdoc">     *  to be read from, and other device-dependent data.
</span>   557    <span class="xdoc">     *
</span>   558    <span class="xdoc">     *  The pSize parameter points to the size of the buffer or data structure
</span>   559    <span class="xdoc">     *  pointed to by the bufp parameter. When the function returns, this
</span>   560    <span class="xdoc">     *  parameter points to the number of MADUs transferred to or from the
</span>   561    <span class="xdoc">     *  device. This parameter is relevant only if the bufp parameter points
</span>   562    <span class="xdoc">     *  to a raw data buffer. In cases where it points to a device-defined
</span>   563    <span class="xdoc">     *  structure it is redundant -- the size of the structure is known to
</span>   564    <span class="xdoc">     *  the mini-driver and the application. At most, it can be used for
</span>   565    <span class="xdoc">     *  error checking.
</span>   566    <span class="xdoc">     *
</span>   567    <span class="xdoc">     *  The appCallback parameter points to either a callback structure that
</span>   568    <span class="xdoc">     *  contains the callback function to be called when the request completes.
</span>   569    <span class="xdoc">     *  queued request is completed, the callback routine (if specified) is
</span>   570    <span class="xdoc">     *  invoked (i.e. blocking).  If the appCallback parameter is NULL, then
</span>   571    <span class="xdoc">     *  the call to GIO_submit() will be synchronous and will not return
</span>   572    <span class="xdoc">     *  until IO is complete (or an error occurs).  
</span>   573    <span class="xdoc">     *
</span>   574    <span class="xdoc">     *  GIO_submit returns IOM_COMPLETED upon successfully carrying out
</span>   575    <span class="xdoc">     *  the requested functionality. If the request is queued, then a status of
</span>   576    <span class="xdoc">     *  IOM_PENDING is returned. If an error occurs, the device returns a
</span>   577    <span class="xdoc">     *  negative value. For a list of error values, see ti/sysbios/io/iom.h.
</span>   578    <span class="xdoc">     * 
</span>   579    <span class="xdoc">     *  A call to GIO_submit results in a call to the mdSubmit function of
</span>   580    <span class="xdoc">     *  the associated mini-driver. The specified command is passed to the
</span>   581    <span class="xdoc">     *  mdSubmit function.
</span>   582    <span class="xdoc">     *
</span>   583    <span class="xdoc">     *  <b>@param(cmd)</b>         driver specific packet command
</span>   584    <span class="xdoc">     *  <b>@param(buf)</b>         buffer pointer
</span>   585    <span class="xdoc">     *  <b>@param(pSize)</b>       pointer to size of buffer (INPUT/OUTPUT parameter)
</span>   586    <span class="xdoc">     *  <b>@param(appCallBack)</b> pointer to application callback structure
</span>   587    <span class="xdoc">     *  <b>@b(returns)</b>         IOM_COMPLETED on success, &lt; 0 on failure  
</span>   588    <span class="xdoc">     */</span>
   589        @DirectCall
   590        Int submit(UInt cmd, Ptr buf, SizeT *pSize, AppCallback *appCallback); 
   591        
   592        <span class="xdoc">/*!
</span>   593    <span class="xdoc">     *  ======== prime ========
</span>   594    <span class="xdoc">     *  Prime an OUTPUT stream instance.
</span>   595    <span class="xdoc">     *
</span>   596    <span class="xdoc">     *  This API facilitates buffering of an output channel. Consider a
</span>   597    <span class="xdoc">     *  task that constantly gets data from input channel and sends to an
</span>   598    <span class="xdoc">     *  output channel. To start with it may want to issue buffers to the
</span>   599    <span class="xdoc">     *  input channel and output channel to enable double buffering.
</span>   600    <span class="xdoc">     *  For an input channel there is no problem. For an output channel however
</span>   601    <span class="xdoc">     *  the buffer data is sent out through the peripheral and in the case of a
</span>   602    <span class="xdoc">     *  heterogenous system, the data will be sent to the other processor.
</span>   603    <span class="xdoc">     *
</span>   604    <span class="xdoc">     *  In such cases where the driver cannot handle dummy buffers,
</span>   605    <span class="xdoc">     *  IO_prime can be used to make buffers available instantly for
</span>   606    <span class="xdoc">     *  reclaim without actually sending the buffers to the driver.
</span>   607    <span class="xdoc">     *  This API is non-blocking.
</span>   608    <span class="xdoc">     *
</span>   609    <span class="xdoc">     *  The primary use of prime() is used when applications want to prime
</span>   610    <span class="xdoc">     *  an output channel at startup, without sending data to the driver.
</span>   611    <span class="xdoc">     *  This allows them to reclaim and issue in their task.
</span>   612    <span class="xdoc">     *
</span>   613    <span class="xdoc">     *  Failure of prime() indicates that the stream was not able to accept the
</span>   614    <span class="xdoc">     *  buffer being issued  due to un-avaibailibity of IO packets.
</span>   615    <span class="xdoc">     *
</span>   616    <span class="xdoc">     *  The client argument is not interpreted by IO.
</span>   617    <span class="xdoc">     *
</span>   618    <span class="xdoc">     *  <b>@param(buf)</b>         buffer pointer
</span>   619    <span class="xdoc">     *  <b>@param(size)</b>        size of buffer
</span>   620    <span class="xdoc">     *  <b>@param(arg)</b>         app arg
</span>   621    <span class="xdoc">     *  <b>@b(returns)</b>         IOM_COMPLETED on success, &lt; 0 on failure  
</span>   622    <span class="xdoc">     */</span>
   623        @DirectCall
   624        Int prime(Ptr buf, SizeT size, UArg arg);
   625    
   626    <span class=key>internal</span>:
   627    
   628        <span class="comment">/* -------- Internal Structures -------- */</span>
   629        <span class=key>struct</span> Instance_State {
   630            String              name;           <span class="comment">/* name used to create inst */</span>
   631            UInt                mode;           <span class="comment">/* input or output */</span>
   632            UInt                model;          <span class="comment">/* STANARD or ISSUERECLAIM */</span>
   633            UInt                timeout;        <span class="comment">/* STANARD or ISSUERECLAIM */</span>
   634            IHeap.Handle        packetHeap;     <span class="comment">/* heap used to alloc packets */</span>
   635            ISync.Handle        sync;           <span class="comment">/* completion sync */</span>
   636            Bool                userSync;       <span class="comment">/* user supplied sync handle*/</span>
   637            Queue.Object        doneList;       <span class="comment">/* done packets */</span>
   638            Queue.Object        freeList;       <span class="comment">/* free packets */</span>
   639            Ptr                 packets;        <span class="comment">/* allocated packet block */</span>
   640            Int                 numPackets;     <span class="comment">/* total # of packets */</span>
   641            Int                 freeCount;      <span class="comment">/* # of free packets */</span>
   642            Int                 doneCount;      <span class="comment">/* # of completed packets */</span>
   643            Int                 submitCount;    <span class="comment">/* # packets submitted to driver */</span>
   644    
   645            Ptr                 fxns;           <span class="comment">/* device function table */</span>
   646            Ptr                 mdChan;         <span class="comment">/* pointer to driver chan object */</span>
   647        };
   648    }
</pre>
</body></html>
