<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>module ti.sysbios.knl.Clock</title>
<meta name="googlebot" content="noindex,nofollow">
<link rel="stylesheet" type="text/css" href="../../../src.css"/>
</head>
<body>
<pre class=src>
     1    <span class="comment">/*
</span>     2    <span class="comment"> * Copyright (c) 2013, Texas Instruments Incorporated
</span>     3    <span class="comment"> * All rights reserved.
</span>     4    <span class="comment"> *
</span>     5    <span class="comment"> * Redistribution and use in source and binary forms, with or without
</span>     6    <span class="comment"> * modification, are permitted provided that the following conditions
</span>     7    <span class="comment"> * are met:
</span>     8    <span class="comment"> *
</span>     9    <span class="comment"> * *  Redistributions of source code must retain the above copyright
</span>    10    <span class="comment"> *    notice, this list of conditions and the following disclaimer.
</span>    11    <span class="comment"> *
</span>    12    <span class="comment"> * *  Redistributions in binary form must reproduce the above copyright
</span>    13    <span class="comment"> *    notice, this list of conditions and the following disclaimer in the
</span>    14    <span class="comment"> *    documentation and/or other materials provided with the distribution.
</span>    15    <span class="comment"> *
</span>    16    <span class="comment"> * *  Neither the name of Texas Instruments Incorporated nor the names of
</span>    17    <span class="comment"> *    its contributors may be used to endorse or promote products derived
</span>    18    <span class="comment"> *    from this software without specific prior written permission.
</span>    19    <span class="comment"> *
</span>    20    <span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
</span>    21    <span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
</span>    22    <span class="comment"> * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
</span>    23    <span class="comment"> * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
</span>    24    <span class="comment"> * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
</span>    25    <span class="comment"> * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
</span>    26    <span class="comment"> * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
</span>    27    <span class="comment"> * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
</span>    28    <span class="comment"> * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
</span>    29    <span class="comment"> * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
</span>    30    <span class="comment"> * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
</span>    31    <span class="comment"> */</span>
    32    <span class="comment">/*
</span>    33    <span class="comment"> *  ======== Clock.xdc ========
</span>    34    <span class="comment"> *
</span>    35    <span class="comment"> *
</span>    36    <span class="comment"> */</span>
    37    
    38    <span class=key>package</span> ti.sysbios.knl;
    39    
    40    import xdc.rov.ViewInfo;
    41    
    42    import xdc.runtime.Assert;
    43    import xdc.runtime.Diags;
    44    import xdc.runtime.Log;
    45    
    46    import ti.sysbios.hal.Timer;
    47    
    48    <span class="xdoc">/*!
</span>    49    <span class="xdoc"> *  ======== Clock ========
</span>    50    <span class="xdoc"> *  System Clock Manager
</span>    51    <span class="xdoc"> *
</span>    52    <span class="xdoc"> *  The System Clock Manager is responsible for all timing services in
</span>    53    <span class="xdoc"> *  SYS/BIOS.
</span>    54    <span class="xdoc"> *  It generates the periodic system tick. The tick period is configurable.
</span>    55    <span class="xdoc"> *  The timeout and period for all Clock Instances and timeout values in
</span>    56    <span class="xdoc"> *  other SYS/BIOS modules are specified in terms of Clock ticks.
</span>    57    <span class="xdoc"> *
</span>    58    <span class="xdoc"> *  The Clock Manager supports two tick "modes": a periodic mode with an
</span>    59    <span class="xdoc"> *  interrupt on each tick (TickMode_PERIODIC), and a tick suppression
</span>    60    <span class="xdoc"> *  mode (TickMode_DYNAMIC), which reduces the number of timer interrupts to
</span>    61    <span class="xdoc"> *  the minimum required to support the scheduled timeouts.  For devices that
</span>    62    <span class="xdoc"> *  support it (e.g., MSP430 devices), TickMode_DYNAMIC may be the default
</span>    63    <span class="xdoc"> *  mode if one is not specified in the application configuration; otherwise,
</span>    64    <span class="xdoc"> *  the default mode will be TickMode_PERIODIC.  The following example shows
</span>    65    <span class="xdoc"> *  how the tick mode  can be specified in the application configuration:
</span>    66    <span class="xdoc"> *
</span>    67    <span class="xdoc"> *  <b>@p(code)</b>
</span>    68    <span class="xdoc"> *  var Clock = xdc.useModule('ti.sysbios.knl.Clock');
</span>    69    <span class="xdoc"> *
</span>    70    <span class="xdoc"> *  // Tell the Clock module to use TickMode_PERIODIC
</span>    71    <span class="xdoc"> *  Clock.tickMode = Clock.TickMode_PERIODIC;
</span>    72    <span class="xdoc"> *  <b>@p</b>
</span>    73    <span class="xdoc"> *
</span>    74    <span class="xdoc"> *  Clock Instances are functions that can be scheduled to run after a
</span>    75    <span class="xdoc"> *  certain number of Clock ticks.
</span>    76    <span class="xdoc"> *  Clock instances are either one-shot or periodic. Instances are started
</span>    77    <span class="xdoc"> *  when created or they are started later using the Clock_start()function.
</span>    78    <span class="xdoc"> *  Instances can be stopped using the Clock_stop() function. All Clock
</span>    79    <span class="xdoc"> *  Instances are executed when they expire in the context of a software
</span>    80    <span class="xdoc"> *  interrupt.
</span>    81    <span class="xdoc"> *
</span>    82    <span class="xdoc"> *  Clock objects are placed in the Clock object service list when
</span>    83    <span class="xdoc"> *  created/constructed and remain there until deleted/destructed.
</span>    84    <span class="xdoc"> *  To minimize processing overhead, unused or expired Clock objects
</span>    85    <span class="xdoc"> *  should be deleted or destructed.
</span>    86    <span class="xdoc"> *
</span>    87    <span class="xdoc"> *  The getTicks() function returns number of clock ticks since startup.
</span>    88    <span class="xdoc"> *
</span>    89    <span class="xdoc"> *  By default, the Clock module statically configures a
</span>    90    <span class="xdoc"> *  {<b>@link</b> ti.sysbios.hal.Timer}
</span>    91    <span class="xdoc"> *  timer instance to provide the periodic 1 ms tick interrupt. If you
</span>    92    <span class="xdoc"> *  want to use a custom configured timer for the Clock module's tick source,
</span>    93    <span class="xdoc"> *  use the following example configuration as a guide:
</span>    94    <span class="xdoc"> *
</span>    95    <span class="xdoc"> *  <b>@p(code)</b>
</span>    96    <span class="xdoc"> *  var Clock = xdc.useModule('ti.sysbios.knl.Clock');
</span>    97    <span class="xdoc"> *
</span>    98    <span class="xdoc"> *  // Tell the Clock module that YOU are providing the periodic interrupt
</span>    99    <span class="xdoc"> *  Clock.tickSource = Clock.TickSource_USER;
</span>   100    <span class="xdoc"> *
</span>   101    <span class="xdoc"> *  // this example uses the ti.sysbios.timers.dmtimer.Timer module
</span>   102    <span class="xdoc"> *  var Timer = xdc.useModule('ti.sysbios.timers.dmtimer.Timer');
</span>   103    <span class="xdoc"> *
</span>   104    <span class="xdoc"> *  // create a dmtimer config parameter object
</span>   105    <span class="xdoc"> *  var timerParams = new Timer.Params();
</span>   106    <span class="xdoc"> *
</span>   107    <span class="xdoc"> *  // make sure you set the period to 1000 us (1ms)
</span>   108    <span class="xdoc"> *  timerParams.period = 1000;
</span>   109    <span class="xdoc"> *
</span>   110    <span class="xdoc"> *  // custom dmtimer config parameters here...
</span>   111    <span class="xdoc"> *  timerParams.twer.ovf_wup_ena = 1;
</span>   112    <span class="xdoc"> *
</span>   113    <span class="xdoc"> *  // Create the timer.
</span>   114    <span class="xdoc"> *  // This example uses timer id 3.
</span>   115    <span class="xdoc"> *  // Provide your own timer interrupt handler function.
</span>   116    <span class="xdoc"> *  Timer.create(3, '&amp;myTimerTick', timerParams);
</span>   117    <span class="xdoc"> *  <b>@p</b>
</span>   118    <span class="xdoc"> *
</span>   119    <span class="xdoc"> *  In your 'C' code, add your timer interrupt handler and have it
</span>   120    <span class="xdoc"> *  call Clock_tick(), which will perform all of the Clock module
</span>   121    <span class="xdoc"> *  tick duties:
</span>   122    <span class="xdoc"> *
</span>   123    <span class="xdoc"> *  <b>@p(code)</b>
</span>   124    <span class="xdoc"> *  #include &lt;ti/sysbios/knl/Clock.h&gt;
</span>   125    <span class="xdoc"> *
</span>   126    <span class="xdoc"> *  Void myTimerTick(UArg arg)
</span>   127    <span class="xdoc"> *  {
</span>   128    <span class="xdoc"> *       Clock_tick();
</span>   129    <span class="xdoc"> *       ...
</span>   130    <span class="xdoc"> *  }
</span>   131    <span class="xdoc"> *  <b>@p</b>
</span>   132    <span class="xdoc"> *
</span>   133    <span class="xdoc"> *  <b>@p(html)</b>
</span>   134    <span class="xdoc"> *  &lt;h3&gt; Calling Context &lt;/h3&gt;
</span>   135    <span class="xdoc"> *  &lt;table border="1" cellpadding="3"&gt;
</span>   136    <span class="xdoc"> *    &lt;colgroup span="1"&gt;&lt;/colgroup&gt; &lt;colgroup span="5" align="center"&gt;
</span>   137    <span class="xdoc"> *    &lt;/colgroup&gt;
</span>   138    <span class="xdoc"> *
</span>   139    <span class="xdoc"> *    &lt;tr&gt;&lt;th&gt; Function                &lt;/th&gt;&lt;th&gt;  Hwi   &lt;/th&gt;&lt;th&gt;  Swi   &lt;/th&gt;
</span>   140    <span class="xdoc"> *    &lt;th&gt;  Task  &lt;/th&gt;&lt;th&gt;  Main  &lt;/th&gt;&lt;th&gt;  Startup  &lt;/th&gt;&lt;/tr&gt;
</span>   141    <span class="xdoc"> *    &lt;!--                                                                --&gt;
</span>   142    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #construct}      &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   143    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   144    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #create}         &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   145    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   146    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #delete}         &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   147    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   148    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #destruct}       &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;
</span>   149    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   150    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTicks}       &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   151    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   152    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTimerHandle} &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   153    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   154    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #Params_init}    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   155    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;/tr&gt;
</span>   156    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tick}           &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   157    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   158    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tickReconfig}   &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   159    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   160    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tickStart}      &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   161    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   162    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #tickStop}       &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   163    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   164    <span class="xdoc"> *
</span>   165    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #getTimeout}     &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   166    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   167    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #isActive}       &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   168    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   169    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setFunc}        &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   170    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   171    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setPeriod}      &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   172    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   173    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #setTimeout}     &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   174    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   175    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #start}          &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   176    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   177    <span class="xdoc"> *    &lt;tr&gt;&lt;td&gt; {<b>@link</b> #stop}           &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;
</span>   178    <span class="xdoc"> *    &lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   Y    &lt;/td&gt;&lt;td&gt;   N    &lt;/td&gt;&lt;/tr&gt;
</span>   179    <span class="xdoc"> *    &lt;tr&gt;&lt;td colspan="6"&gt; Definitions: &lt;br /&gt;
</span>   180    <span class="xdoc"> *       &lt;ul&gt;
</span>   181    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Hwi&lt;/b&gt;: API is callable from a Hwi thread. &lt;/li&gt;
</span>   182    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Swi&lt;/b&gt;: API is callable from a Swi thread. &lt;/li&gt;
</span>   183    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Task&lt;/b&gt;: API is callable from a Task thread. &lt;/li&gt;
</span>   184    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Main&lt;/b&gt;: API is callable during any of these phases: &lt;/li&gt;
</span>   185    <span class="xdoc"> *           &lt;ul&gt;
</span>   186    <span class="xdoc"> *             &lt;li&gt; In your module startup after this module is started
</span>   187    <span class="xdoc"> *    (e.g. Clock_Module_startupDone() returns TRUE). &lt;/li&gt;
</span>   188    <span class="xdoc"> *             &lt;li&gt; During
</span>   189    <span class="xdoc"> *    {<b>@link</b> xdc.runtime.Startup#lastFxns Startup.lastFxns}. &lt;/li&gt;
</span>   190    <span class="xdoc"> *             &lt;li&gt; During main().&lt;/li&gt;
</span>   191    <span class="xdoc"> *             &lt;li&gt; During
</span>   192    <span class="xdoc"> *    {<b>@link</b> ti.sysbios.BIOS#startupFxns BIOS.startupFxns}.&lt;/li&gt;
</span>   193    <span class="xdoc"> *           &lt;/ul&gt;
</span>   194    <span class="xdoc"> *         &lt;li&gt; &lt;b&gt;Startup&lt;/b&gt;: API is callable during any of these phases:&lt;/li&gt;
</span>   195    <span class="xdoc"> *           &lt;ul&gt;
</span>   196    <span class="xdoc"> *             &lt;li&gt; During
</span>   197    <span class="xdoc"> *    {<b>@link</b> xdc.runtime.Startup#firstFxns Startup.firstFxns}.&lt;/li&gt;
</span>   198    <span class="xdoc"> *             &lt;li&gt; In your module startup before this module is started
</span>   199    <span class="xdoc"> *    (e.g. Clock_Module_startupDone() returns FALSE).&lt;/li&gt;
</span>   200    <span class="xdoc"> *           &lt;/ul&gt;
</span>   201    <span class="xdoc"> *       &lt;/ul&gt;
</span>   202    <span class="xdoc"> *    &lt;/td&gt;&lt;/tr&gt;
</span>   203    <span class="xdoc"> *
</span>   204    <span class="xdoc"> *  &lt;/table&gt;
</span>   205    <span class="xdoc"> *  <b>@p</b>
</span>   206    <span class="xdoc"> */</span>
   207    
   208    @ModuleStartup
   209    @InstanceInitStatic <span class="comment">/* Construct/Destruct CAN becalled at runtime */</span>
   210    @InstanceFinalize   <span class="comment">/* generate call to Clock_Instance_finalize on delete */</span>
   211    @Template(<span class="string">"./Clock.xdt"</span>)
   212    
   213    <span class=key>module</span> Clock
   214    {
   215        <span class="xdoc">/*!
</span>   216    <span class="xdoc">     *  ======== TickSource ========
</span>   217    <span class="xdoc">     *  Clock tick source
</span>   218    <span class="xdoc">     *
</span>   219    <span class="xdoc">     *  <b>@field(TickSource_TIMER)</b> The Clock module automatically configures a
</span>   220    <span class="xdoc">     *  a {<b>@link</b> ti.sysbios.hal.Timer} instance to drive the Clock tick.
</span>   221    <span class="xdoc">     *  The specific timer and its period can be controlled via
</span>   222    <span class="xdoc">     *  {<b>@link</b> #timerId} and {<b>@link</b> #tickPeriod}.
</span>   223    <span class="xdoc">     *
</span>   224    <span class="xdoc">     *  <b>@field(TickSource_USER)</b> The Application is responsible for calling
</span>   225    <span class="xdoc">     *  {<b>@link</b> #tick Clock_tick()} periodically. Make sure {<b>@link</b> #tickPeriod
</span>   226    <span class="xdoc">     *  Clock.tickPeriod} is set to the period that Clock_tick() is called.
</span>   227    <span class="xdoc">     *
</span>   228    <span class="xdoc">     *  Like most other module configuration parameters, the Clock.tickPeriod
</span>   229    <span class="xdoc">     *  config parameter value is accessible in runtime C code as
</span>   230    <span class="xdoc">     *  "Clock_tickPeriod".
</span>   231    <span class="xdoc">     *
</span>   232    <span class="xdoc">     *  <b>@field(TickSource_NULL)</b> The Clock module is disabled.
</span>   233    <span class="xdoc">     *  In this case, it is an error for the application to ever call
</span>   234    <span class="xdoc">     *  Clock_tick().
</span>   235    <span class="xdoc">     *
</span>   236    <span class="xdoc">     *  <b>@see</b> #tickPeriod
</span>   237    <span class="xdoc">     *  <b>@see</b> #timerId
</span>   238    <span class="xdoc">     */</span>
   239        <span class=key>enum</span>  TickSource {
   240            TickSource_TIMER,   <span class="xdoc">/*! Internally configure a hal Timer to periodically call Clock_tick() */</span>
   241            TickSource_USER,    <span class="xdoc">/*! Application code calls Clock_tick() */</span>
   242            TickSource_NULL     <span class="xdoc">/*! The Clock module is disabled */</span>
   243        };
   244    
   245        <span class="xdoc">/*!
</span>   246    <span class="xdoc">     *  ======== TickMode ========
</span>   247    <span class="xdoc">     *  Clock Tick Mode
</span>   248    <span class="xdoc">     */</span>
   249        <span class=key>enum</span>  TickMode {
   250            TickMode_PERIODIC,  <span class="xdoc">/*! Timer will interrupt every period */</span>
   251            TickMode_DYNAMIC    <span class="xdoc">/*! Unnecessary timer ticks can be suppressed (available on subset of devices) */</span>
   252        };
   253    
   254        <span class="xdoc">/*!
</span>   255    <span class="xdoc">     *  ======== BasicView ========
</span>   256    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   257    <span class="xdoc">     */</span>
   258        <span class=key>metaonly</span> <span class=key>struct</span> BasicView {
   259            String          label;
   260            UInt32          timeout;
   261            UInt            period;
   262            String          fxn[];
   263            UArg            arg;
   264            Bool            started;        <span class="comment">/* Instance running? */</span>
   265            String          tRemaining;     <span class="comment">/* Remaining timeout */</span>
   266            Bool            periodic;       <span class="comment">/* Periodic? (vs. one-shot) */</span>
   267        }
   268    
   269        <span class="xdoc">/*!
</span>   270    <span class="xdoc">     *  ======== ModuleView ========
</span>   271    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   272    <span class="xdoc">     */</span>
   273        <span class=key>metaonly</span> <span class=key>struct</span> ModuleView {
   274            String          ticks;
   275            String          tickSource;
   276            String          tickMode;
   277            String          timerHandle;
   278            UInt            timerId;
   279            UInt            swiPriority;
   280            UInt32          tickPeriod;
   281            volatile UInt   nSkip;
   282        }
   283    
   284        <span class="comment">/*
</span>   285    <span class="comment">     *  ======== rovViewInfo ========
</span>   286    <span class="comment">     *  @_nodoc
</span>   287    <span class="comment">     */</span>
   288        @Facet
   289        <span class=key>metaonly</span> <span class=key>config</span> ViewInfo.Instance rovViewInfo =
   290            ViewInfo.create({
   291                viewMap: [
   292                  [<span class="string">'Basic'</span>,    {type: ViewInfo.INSTANCE, viewInitFxn: <span class="string">'viewInitBasic'</span>,  structName: <span class="string">'BasicView'</span>}],
   293                  [<span class="string">'Module'</span>,   {type: ViewInfo.MODULE,   viewInitFxn: <span class="string">'viewInitModule'</span>, structName: <span class="string">'ModuleView'</span>}],
   294                ]
   295            });
   296    
   297        <span class="xdoc">/*!
</span>   298    <span class="xdoc">     *  ======== FuncPtr ========
</span>   299    <span class="xdoc">     * Instance function prototype
</span>   300    <span class="xdoc">     */</span>
   301        <span class=key>typedef</span> Void (*FuncPtr)(UArg);
   302    
   303        <span class="xdoc">/*!
</span>   304    <span class="xdoc">     *  ======== LW_delayed ========
</span>   305    <span class="xdoc">     *  Logged if Clock Swi delayed by &gt;= 1 tick
</span>   306    <span class="xdoc">     */</span>
   307        <span class=key>config</span> Log.Event LW_delayed = {
   308            mask: Diags.USER3,
   309            msg: <span class="string">"LW_delayed: delay: %d"</span>
   310        };
   311    
   312        <span class="xdoc">/*!
</span>   313    <span class="xdoc">     *  ======== LM_tick ========
</span>   314    <span class="xdoc">     *  Logged in every Clock tick interrupt
</span>   315    <span class="xdoc">     */</span>
   316        <span class=key>config</span> Log.Event LM_tick = {
   317            mask: Diags.USER1 | Diags.USER2,
   318            msg: <span class="string">"LM_tick: tick: %d"</span>
   319        };
   320    
   321        <span class="xdoc">/*!
</span>   322    <span class="xdoc">     *  ======== LM_begin ========
</span>   323    <span class="xdoc">     *  Logged just prior to calling each Clock function
</span>   324    <span class="xdoc">     */</span>
   325        <span class=key>config</span> Log.Event LM_begin = {
   326            mask: Diags.USER1 | Diags.USER2,
   327            msg: <span class="string">"LM_begin: clk: 0x%x, func: 0x%x"</span>
   328        };
   329    
   330        <span class="xdoc">/*!
</span>   331    <span class="xdoc">     *  ======== A_clockDisabled ========
</span>   332    <span class="xdoc">     *  Asserted in Clock_create()
</span>   333    <span class="xdoc">     */</span>
   334        <span class=key>config</span> Assert.Id A_clockDisabled = {
   335            msg: <span class="string">"A_clockDisabled: Cannot create a clock instance when BIOS.clockEnabled is false."</span>
   336        };
   337    
   338        <span class="xdoc">/*!
</span>   339    <span class="xdoc">     *  ======== A_badThreadType ========
</span>   340    <span class="xdoc">     *  Asserted in Clock_create and Clock_delete
</span>   341    <span class="xdoc">     */</span>
   342        <span class=key>config</span> Assert.Id A_badThreadType = {
   343            msg: <span class="string">"A_badThreadType: Cannot create/delete a Clock from Hwi or Swi thread."</span>
   344        };
   345    
   346        <span class="xdoc">/*!
</span>   347    <span class="xdoc">     *  ======== tickSource ========
</span>   348    <span class="xdoc">     *  Source of clock ticks
</span>   349    <span class="xdoc">     *
</span>   350    <span class="xdoc">     *  If this parameter is not set to TickSource_TIMER,
</span>   351    <span class="xdoc">     *  {<b>@link</b> #tickStart Clock_tickStart()},
</span>   352    <span class="xdoc">     *  {<b>@link</b> #tickStop Clock_tickStop()}, and
</span>   353    <span class="xdoc">     *  {<b>@link</b> #tickReconfig Clock_tickReconfig()}, have no effect.
</span>   354    <span class="xdoc">     *
</span>   355    <span class="xdoc">     *  The default is TickSource_TIMER.
</span>   356    <span class="xdoc">     */</span>
   357        <span class=key>config</span> TickSource tickSource = TickSource_TIMER;
   358    
   359        <span class="xdoc">/*!
</span>   360    <span class="xdoc">     *  ======== tickMode ========
</span>   361    <span class="xdoc">     *  Timer tick mode
</span>   362    <span class="xdoc">     *
</span>   363    <span class="xdoc">     *  This parameter specifies the tick mode to be used by the underlying
</span>   364    <span class="xdoc">     *  Timer.
</span>   365    <span class="xdoc">     *
</span>   366    <span class="xdoc">     *  With TickMode_PERIODIC the timer will interrupt the CPU at
</span>   367    <span class="xdoc">     *  a fixed rate, defined by the tickPeriod.
</span>   368    <span class="xdoc">     *
</span>   369    <span class="xdoc">     *  With TickMode_DYNAMIC the timer can be dynamically reprogrammed by
</span>   370    <span class="xdoc">     *  Clock, to interrupt the CPU when the next tick is actually needed for
</span>   371    <span class="xdoc">     *  a scheduled timeout. TickMode_DYNAMIC is not supported on all devices,
</span>   372    <span class="xdoc">     *  and may have some application constraints (for example, for MSP430,
</span>   373    <span class="xdoc">     *  see a description on this wiki page:
</span>   374    <span class="xdoc">     *  http://processors.wiki.ti.com/index.php/SYS/BIOS_for_the_MSP430#Clock_Tick_Suppression).
</span>   375    <span class="xdoc">     */</span>
   376        <span class=key>config</span> TickMode tickMode;
   377    
   378        <span class="xdoc">/*!
</span>   379    <span class="xdoc">     *  ======== timerId ========
</span>   380    <span class="xdoc">     *  Timer Id used to create a Timer instance
</span>   381    <span class="xdoc">     *
</span>   382    <span class="xdoc">     *  If {<b>@link</b> #tickSource Clock.tickSource} is set to TickSource_TIMER,
</span>   383    <span class="xdoc">     *  the Clock module automatically  creates a
</span>   384    <span class="xdoc">     *  {<b>@link</b> ti.sysbios.hal.Timer#create instance} that automatically calls
</span>   385    <span class="xdoc">     *  Clock_doTick() on a periodic basis (as specified by
</span>   386    <span class="xdoc">     *  {<b>@link</b> #tickPeriod tickPeriod} and {<b>@link</b> #periodType periodType}.)
</span>   387    <span class="xdoc">     *
</span>   388    <span class="xdoc">     *  This configuration parameter allows you to control which timer is
</span>   389    <span class="xdoc">     *  used to drive the Clock module.
</span>   390    <span class="xdoc">     *
</span>   391    <span class="xdoc">     *  The default value is {<b>@link</b> ti.sysbios.hal.Timer#ANY Timer.ANY} (~0)
</span>   392    <span class="xdoc">     *  and the maximum timerId possible is family and device specific.
</span>   393    <span class="xdoc">     *
</span>   394    <span class="xdoc">     *  <b>@see</b> ti.sysbios.hal.Timer
</span>   395    <span class="xdoc">     */</span>
   396        <span class=key>config</span> UInt timerId = ~0;
   397    
   398        <span class="xdoc">/*!
</span>   399    <span class="xdoc">     *  ======== swiPriority ========
</span>   400    <span class="xdoc">     *  The priority of Swi used by Clock to process its instances
</span>   401    <span class="xdoc">     *
</span>   402    <span class="xdoc">     *  All Clock instances are executed in the context of a single
</span>   403    <span class="xdoc">     *  {<b>@link</b> Swi}.  This parameter allows you to control the priority of
</span>   404    <span class="xdoc">     *  that Swi.
</span>   405    <span class="xdoc">     *
</span>   406    <span class="xdoc">     *  The default value of this parameter is Swi.numPriorities - 1; i.e.,
</span>   407    <span class="xdoc">     *  the maximum Swi priority.
</span>   408    <span class="xdoc">     *
</span>   409    <span class="xdoc">     *  <b>@see</b> ti.sysbios.knl.Swi#numPriorities
</span>   410    <span class="xdoc">     */</span>
   411        <span class=key>metaonly</span> <span class=key>config</span> UInt swiPriority;
   412    
   413        <span class="xdoc">/*!
</span>   414    <span class="xdoc">     *  ======== tickPeriod ========
</span>   415    <span class="xdoc">     *  Tick period specified in microseconds
</span>   416    <span class="xdoc">     *
</span>   417    <span class="xdoc">     *  Default value is family dependent. For example, Linux systems often
</span>   418    <span class="xdoc">     *  only support a minimum period of 10000 us and multiples of 10000 us.
</span>   419    <span class="xdoc">     *  TI platforms have a default of 1000 us.
</span>   420    <span class="xdoc">     *
</span>   421    <span class="xdoc">     *  Like most other module configuration parameters, the Clock.tickPeriod
</span>   422    <span class="xdoc">     *  config parameter value is accessible in runtime C code as
</span>   423    <span class="xdoc">     *  "Clock_tickPeriod".
</span>   424    <span class="xdoc">     */</span>
   425        <span class=key>config</span> UInt32 tickPeriod;
   426    
   427        <span class="xdoc">/*!
</span>   428    <span class="xdoc">     *  ======== getTicks ========
</span>   429    <span class="xdoc">     *  Time in Clock ticks
</span>   430    <span class="xdoc">     *
</span>   431    <span class="xdoc">     *  The value returned will wrap back to zero after it reaches the max
</span>   432    <span class="xdoc">     *  value that can be stored in 32 bits.
</span>   433    <span class="xdoc">     *
</span>   434    <span class="xdoc">     *  <b>@b(returns)</b>     time in clock ticks
</span>   435    <span class="xdoc">     */</span>
   436        @DirectCall
   437        UInt32 getTicks();
   438    
   439        <span class="xdoc">/*!
</span>   440    <span class="xdoc">     *  ======== getTimerHandle ========
</span>   441    <span class="xdoc">     *  Get timer Handle
</span>   442    <span class="xdoc">     *
</span>   443    <span class="xdoc">     *  Used when is it necessary to change family
</span>   444    <span class="xdoc">     *  specific options for the timer and its Hwi Object.
</span>   445    <span class="xdoc">     *
</span>   446    <span class="xdoc">     *  <b>@b(returns)</b>     Timer Handle
</span>   447    <span class="xdoc">     */</span>
   448        @DirectCall
   449        ti.sysbios.hal.Timer.Handle getTimerHandle();
   450    
   451        <span class="xdoc">/*!
</span>   452    <span class="xdoc">     *  ======== tickStop ========
</span>   453    <span class="xdoc">     *  Stop clock for reconfiguration
</span>   454    <span class="xdoc">     *
</span>   455    <span class="xdoc">     *  This function is used to stop the timer used for generation of
</span>   456    <span class="xdoc">     *  clock ticks. It is used along with Clock_tickStart() and
</span>   457    <span class="xdoc">     *  Clock_tickReconfig() to allow reconfiguration of timer at runtime.
</span>   458    <span class="xdoc">     *
</span>   459    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   460    <span class="xdoc">     *  This function is non-reentrant and appropriate locks must be used to
</span>   461    <span class="xdoc">     *  protect against  re-entrancy.
</span>   462    <span class="xdoc">     */</span>
   463        @DirectCall
   464        Void tickStop();
   465    
   466        <span class="xdoc">/*!
</span>   467    <span class="xdoc">     *  ======== tickReconfig ========
</span>   468    <span class="xdoc">     *  Reconfigure clock for new cpu frequency
</span>   469    <span class="xdoc">     *
</span>   470    <span class="xdoc">     *  This function uses the new cpu frequency to reconfigure the timer used
</span>   471    <span class="xdoc">     *  for generation of clock ticks such that tick period is
</span>   472    <span class="xdoc">     *  accurate.  This function is used along with Clock_tickStop() and
</span>   473    <span class="xdoc">     *  Clock_tickStart() to allow reconfiguration of timer at runtime.
</span>   474    <span class="xdoc">     *
</span>   475    <span class="xdoc">     *  When calling Clock_tickReconfig outside of main(), you must also call
</span>   476    <span class="xdoc">     *  Clock_tickStop and Clock_tickStart to stop and restart the timer.
</span>   477    <span class="xdoc">     *  Use the following call sequence:
</span>   478    <span class="xdoc">     *
</span>   479    <span class="xdoc">     *  <b>@p(code)</b>
</span>   480    <span class="xdoc">     *  // disable interrupts if an interrupt could lead to
</span>   481    <span class="xdoc">     *  // another call to Clock_tickReconfig or if interrupt
</span>   482    <span class="xdoc">     *  // processing relies on having a running timer
</span>   483    <span class="xdoc">     *  Hwi_disable() or Swi_disable();
</span>   484    <span class="xdoc">     *  BIOS_setCpuFreq(&amp;freq);
</span>   485    <span class="xdoc">     *  Clock_tickStop();
</span>   486    <span class="xdoc">     *  Clock_tickReconfig();
</span>   487    <span class="xdoc">     *  Clock_tickStart();
</span>   488    <span class="xdoc">     *  Hwi_restore() or Swi_enable()
</span>   489    <span class="xdoc">     *  <b>@p</b>
</span>   490    <span class="xdoc">     *
</span>   491    <span class="xdoc">     *  When calling Clock_tickReconfig from main(), the timer has not yet
</span>   492    <span class="xdoc">     *  been started because the timer is started as part of BIOS_start().
</span>   493    <span class="xdoc">     *  As a result, you can use the following simplified call sequence
</span>   494    <span class="xdoc">     *  in main():
</span>   495    <span class="xdoc">     *
</span>   496    <span class="xdoc">     *  <b>@p(code)</b>
</span>   497    <span class="xdoc">     *  BIOS_setCpuFrequency(Types.FreqHz *freq);
</span>   498    <span class="xdoc">     *  Clock_tickReconfig(Void);
</span>   499    <span class="xdoc">     *  <b>@p</b>
</span>   500    <span class="xdoc">     *
</span>   501    <span class="xdoc">     *  The return value is false if the timer cannot support the new
</span>   502    <span class="xdoc">     *  frequency
</span>   503    <span class="xdoc">     *
</span>   504    <span class="xdoc">     *  <b>@b(returns)</b>     true if successful
</span>   505    <span class="xdoc">     *
</span>   506    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   507    <span class="xdoc">     *  This function is non-reentrant and appropriate locks must be used to
</span>   508    <span class="xdoc">     *  protect against  re-entrancy.
</span>   509    <span class="xdoc">     */</span>
   510        @DirectCall
   511        Bool tickReconfig();
   512    
   513        <span class="xdoc">/*!
</span>   514    <span class="xdoc">     *  ======== tickStart ========
</span>   515    <span class="xdoc">     *  Start clock after reconfiguration
</span>   516    <span class="xdoc">     *
</span>   517    <span class="xdoc">     *  This function starts the timer used for generation of clock ticks
</span>   518    <span class="xdoc">     *  It is used along with Clock_tickStop() and Clock_tickReconfig() to
</span>   519    <span class="xdoc">     *  allow reconfiguration of timer at runtime. The new timer configuration
</span>   520    <span class="xdoc">     *  reflects changes caused by a call to reconfig().
</span>   521    <span class="xdoc">     *
</span>   522    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   523    <span class="xdoc">     *  This function is non-reentrant and appropriate locks must be used to
</span>   524    <span class="xdoc">     *  protect against  re-entrancy.
</span>   525    <span class="xdoc">     */</span>
   526        @DirectCall
   527        Void tickStart();
   528    
   529        <span class="xdoc">/*!
</span>   530    <span class="xdoc">     *  ======== tick ========
</span>   531    <span class="xdoc">     *  Advance Clock time by one tick
</span>   532    <span class="xdoc">     *
</span>   533    <span class="xdoc">     *  After incrementing a global tick counter, this function posts a Swi
</span>   534    <span class="xdoc">     *  that processes the clock instances.
</span>   535    <span class="xdoc">     *
</span>   536    <span class="xdoc">     *  This function is automatically called by a timer ISR when
</span>   537    <span class="xdoc">     *  {<b>@link</b> #tickSource} is set to {<b>@link</b> #TickSource_TIMER}.
</span>   538    <span class="xdoc">     *
</span>   539    <span class="xdoc">     *  When {<b>@link</b> #tickSource} is set to
</span>   540    <span class="xdoc">     *  {<b>@link</b> #TickSource_USER}, Clock_tick() must be called by the
</span>   541    <span class="xdoc">     *  application.  Usually, this is done within a user defined {<b>@link</b> ti.sysbios.hal.Hwi Hwi},
</span>   542    <span class="xdoc">     *  {<b>@link</b> Swi}, or {<b>@link</b> Task}.
</span>   543    <span class="xdoc">     *
</span>   544    <span class="xdoc">     *  Note that this function is not re-entrant.  The application is
</span>   545    <span class="xdoc">     *  responsible for ensuring that invocations of this function are
</span>   546    <span class="xdoc">     *  serialized: either only one thread in the system ever calls this
</span>   547    <span class="xdoc">     *  function or all calls are "wrapped" by an appropriate mutex.
</span>   548    <span class="xdoc">     *
</span>   549    <span class="xdoc">     *  <b>@see</b> #tickSource
</span>   550    <span class="xdoc">     */</span>
   551        @DirectCall
   552        Void tick();
   553    
   554        <span class="xdoc">/*!
</span>   555    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   556    <span class="xdoc">     *  ======== workFunc ========
</span>   557    <span class="xdoc">     *  Clock Q service routine
</span>   558    <span class="xdoc">     *
</span>   559    <span class="xdoc">     *  <b>@param(arg0)</b>    Unused. required to match Swi.FuncPtr
</span>   560    <span class="xdoc">     *  <b>@param(arg1)</b>    Unused. required to match Swi.FuncPtr
</span>   561    <span class="xdoc">     */</span>
   562        @DirectCall
   563        Void workFunc(UArg arg0, UArg arg1);
   564    
   565        <span class="xdoc">/*!
</span>   566    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   567    <span class="xdoc">     *  ======== workFuncDynamic ========
</span>   568    <span class="xdoc">     *  Clock Q service routine for TickMode_DYNAMIC
</span>   569    <span class="xdoc">     *
</span>   570    <span class="xdoc">     *  <b>@param(arg0)</b>    Unused. required to match Swi.FuncPtr
</span>   571    <span class="xdoc">     *  <b>@param(arg1)</b>    Unused. required to match Swi.FuncPtr
</span>   572    <span class="xdoc">     */</span>
   573        @DirectCall
   574        Void workFuncDynamic(UArg arg0, UArg arg1);
   575    
   576        <span class="xdoc">/*!
</span>   577    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   578    <span class="xdoc">     *  ======= logTick ========
</span>   579    <span class="xdoc">     *  Log the LD_tick from within Clock module scope
</span>   580    <span class="xdoc">     */</span>
   581        @DirectCall
   582        Void logTick();
   583    
   584        <span class="xdoc">/*!
</span>   585    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   586    <span class="xdoc">     *  ======== getCompletedTicks ========
</span>   587    <span class="xdoc">     *  Get the number of Clock ticks that have completed
</span>   588    <span class="xdoc">     *
</span>   589    <span class="xdoc">     *  Retuns the number of ticks completed, to the point where
</span>   590    <span class="xdoc">     *  the underlying Timer interrupt has been serviced.
</span>   591    <span class="xdoc">     *
</span>   592    <span class="xdoc">     *  <b>@b(returns)</b>     time in clock ticks
</span>   593    <span class="xdoc">     */</span>
   594        @DirectCall
   595        UInt32 getCompletedTicks();
   596    
   597        <span class="xdoc">/*!
</span>   598    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   599    <span class="xdoc">     *  ======== getTickPeriod ========
</span>   600    <span class="xdoc">     *  Get the Clock tick period in timer counts
</span>   601    <span class="xdoc">     *
</span>   602    <span class="xdoc">     *  The period is in units returned by the underlying Timer.
</span>   603    <span class="xdoc">     *
</span>   604    <span class="xdoc">     *  <b>@b(returns)</b>     period in timer counts
</span>   605    <span class="xdoc">     */</span>
   606        @DirectCall
   607        UInt32 getTickPeriod();
   608    
   609        <span class="xdoc">/*!
</span>   610    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   611    <span class="xdoc">     *  ======= setupTimerToSkipTicks ========
</span>   612    <span class="xdoc">     *  Reprogram Clock's Timer to suppress unnecessary tick interrupts
</span>   613    <span class="xdoc">     */</span>
   614        @DirectCall
   615        Void setupTimerToSkipTicks(UInt skips);
   616    
   617    <span class=key>instance</span>:
   618    
   619        <span class="xdoc">/*!
</span>   620    <span class="xdoc">     *  ======== create ========
</span>   621    <span class="xdoc">     *  Creates a Clock Instance
</span>   622    <span class="xdoc">     *
</span>   623    <span class="xdoc">     *  The first argument is the function that gets called when the timeout
</span>   624    <span class="xdoc">     *  expires.
</span>   625    <span class="xdoc">     *
</span>   626    <span class="xdoc">     *  The 'timeout' argument is used to specify the initial timeout
</span>   627    <span class="xdoc">     *  for both one-shot and periodic Clock instances (in Clock ticks).
</span>   628    <span class="xdoc">     *
</span>   629    <span class="xdoc">     *  The {<b>@link</b> #period} parameter is used to set the subsequent timeout
</span>   630    <span class="xdoc">     *  interval (in Clock ticks) for periodic instances.
</span>   631    <span class="xdoc">     *
</span>   632    <span class="xdoc">     *  For one-shot instances, the period parameter must be set to zero.
</span>   633    <span class="xdoc">     *
</span>   634    <span class="xdoc">     *  When instances are created they are placed upon a linked list managed
</span>   635    <span class="xdoc">     *  by the Clock module.  For this reason, instances cannot be created
</span>   636    <span class="xdoc">     *  from either Hwi or Swi context.
</span>   637    <span class="xdoc">     *
</span>   638    <span class="xdoc">     *  <b>@param(clockFxn)</b>  Function that runs upon timeout
</span>   639    <span class="xdoc">     *  <b>@param(timeout)</b>   One-shot timeout or initial start delay (in clock
</span>   640    <span class="xdoc">     *                    ticks)
</span>   641    <span class="xdoc">     */</span>
   642        @DirectCall
   643        create(FuncPtr clockFxn, UInt timeout);
   644    
   645        <span class="xdoc">/*!
</span>   646    <span class="xdoc">     *  ======== startFlag ========
</span>   647    <span class="xdoc">     *  Start immediately after instance is created
</span>   648    <span class="xdoc">     *
</span>   649    <span class="xdoc">     *  When this flag is set to false, the user will have to call
</span>   650    <span class="xdoc">     *  Clock_start() to start the instance.
</span>   651    <span class="xdoc">     *
</span>   652    <span class="xdoc">     *  When set to true, both statically created Clock objects and Clock
</span>   653    <span class="xdoc">     *  objects created in main() are started at the end of main() when the
</span>   654    <span class="xdoc">     *  user calls BIOS_start(). Dynamically created Clock objects created
</span>   655    <span class="xdoc">     *  after main() (ie within a task) will be started immediately.
</span>   656    <span class="xdoc">     *
</span>   657    <span class="xdoc">     *  The default setting for this parameter is false.
</span>   658    <span class="xdoc">     *
</span>   659    <span class="xdoc">     *  The configured Clock function will be called initially after an
</span>   660    <span class="xdoc">     *  interval equal to the 'timeout' argument for both one-shot and
</span>   661    <span class="xdoc">     *  periodic Clock objects.
</span>   662    <span class="xdoc">     *
</span>   663    <span class="xdoc">     *  Periodic Clock objects will subsequently be called at the rate
</span>   664    <span class="xdoc">     *  specified by the {<b>@link</b> #period} parameter.
</span>   665    <span class="xdoc">     *
</span>   666    <span class="xdoc">     */</span>
   667        <span class=key>config</span> Bool startFlag = <span class=key>false</span>;
   668    
   669        <span class="xdoc">/*!
</span>   670    <span class="xdoc">     *  ======== period ========
</span>   671    <span class="xdoc">     *  Period of this instance (in clock ticks)
</span>   672    <span class="xdoc">     *
</span>   673    <span class="xdoc">     *  The default value of this parameter is 0, which indicates this is
</span>   674    <span class="xdoc">     *  a one-shot Clock object.
</span>   675    <span class="xdoc">     *
</span>   676    <span class="xdoc">     *  A non zero value for this parameter specifies that the Clock
</span>   677    <span class="xdoc">     *  object is to be called periodically, and also specifies the
</span>   678    <span class="xdoc">     *  rate (in Clock ticks) that the Clock function will be called
</span>   679    <span class="xdoc">     *  AFTER the initial 'timeout' argument period.
</span>   680    <span class="xdoc">     *
</span>   681    <span class="xdoc">     *  For one-shot Clock instances, this parameter must be set to zero.
</span>   682    <span class="xdoc">     */</span>
   683        <span class=key>config</span> UInt32 period = 0;
   684    
   685        <span class="xdoc">/*!
</span>   686    <span class="xdoc">     *  ======== arg ========
</span>   687    <span class="xdoc">     *  Uninterpreted argument passed to instance function
</span>   688    <span class="xdoc">     *
</span>   689    <span class="xdoc">     *  The default is null.
</span>   690    <span class="xdoc">     */</span>
   691        <span class=key>config</span> UArg arg = <span class=key>null</span>;
   692    
   693        <span class="xdoc">/*!
</span>   694    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   695    <span class="xdoc">     *  ======== addI ========
</span>   696    <span class="xdoc">     *  Lightweight One-Shot Clock create for internal SYS/BIOS timeout APIs
</span>   697    <span class="xdoc">     *  Does NOT start the timeout (ie requires Clock_startI() to be called)
</span>   698    <span class="xdoc">     *  Does NOT assume Hwis are disabled
</span>   699    <span class="xdoc">     */</span>
   700        @DirectCall
   701        Void addI(FuncPtr clockFxn, UInt timeout, UArg arg);
   702    
   703        <span class="xdoc">/*!
</span>   704    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   705    <span class="xdoc">     *  ======== removeI ========
</span>   706    <span class="xdoc">     *  Lightweight Clock delete for internal SYS/BIOS timeout APIs
</span>   707    <span class="xdoc">     *  Assumes Hwis are disabled
</span>   708    <span class="xdoc">     */</span>
   709        @DirectCall
   710        Void removeI();
   711    
   712        <span class="xdoc">/*!
</span>   713    <span class="xdoc">     *  ======== start ========
</span>   714    <span class="xdoc">     *  Start instance
</span>   715    <span class="xdoc">     *
</span>   716    <span class="xdoc">     *  The {<b>@link</b> #timeout} and {<b>@link</b> #period} values set during create()
</span>   717    <span class="xdoc">     *  or by calling Clock_setTimeout() and Clock_setPeriod() are used and
</span>   718    <span class="xdoc">     *  the expiry is recomputed.
</span>   719    <span class="xdoc">     *  Note that for periodic instances, the first expiry is
</span>   720    <span class="xdoc">     *  computed using the timeout specified. All subsequent expiries use the
</span>   721    <span class="xdoc">     *  period value.
</span>   722    <span class="xdoc">     *
</span>   723    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   724    <span class="xdoc">     *  Timeout of instance cannot be zero
</span>   725    <span class="xdoc">     */</span>
   726        @DirectCall
   727        Void start();
   728    
   729        <span class="xdoc">/*!
</span>   730    <span class="xdoc">     *  <b>@_nodoc</b>
</span>   731    <span class="xdoc">     *  ======== startI ========
</span>   732    <span class="xdoc">     *  Internal start function which assumes Hwis disabled
</span>   733    <span class="xdoc">     */</span>
   734        @DirectCall
   735        Void startI();
   736    
   737        <span class="xdoc">/*!
</span>   738    <span class="xdoc">     *  ======== stop ========
</span>   739    <span class="xdoc">     *  Stop instance
</span>   740    <span class="xdoc">     */</span>
   741        @DirectCall
   742        Void stop();
   743    
   744        <span class="xdoc">/*!
</span>   745    <span class="xdoc">     *  ======== setPeriod ========
</span>   746    <span class="xdoc">     *  Set periodic interval
</span>   747    <span class="xdoc">     *
</span>   748    <span class="xdoc">     *  <b>@param(period)</b>          periodic interval in Clock ticks
</span>   749    <span class="xdoc">     *
</span>   750    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   751    <span class="xdoc">     *  Cannot change period of instance that has been started.
</span>   752    <span class="xdoc">     */</span>
   753        @DirectCall
   754        Void setPeriod(UInt32 period);
   755    
   756        <span class="xdoc">/*!
</span>   757    <span class="xdoc">     *  ======== setTimeout ========
</span>   758    <span class="xdoc">     *  Set the initial timeout
</span>   759    <span class="xdoc">     *
</span>   760    <span class="xdoc">     *  <b>@param(timeout)</b>         initial timeout in Clock ticks
</span>   761    <span class="xdoc">     *
</span>   762    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   763    <span class="xdoc">     *  Cannot change the initial timeout of instance that has been started.
</span>   764    <span class="xdoc">     */</span>
   765        @DirectCall
   766        Void setTimeout(UInt32 timeout);
   767    
   768        <span class="xdoc">/*!
</span>   769    <span class="xdoc">     *  ======== setFunc ========
</span>   770    <span class="xdoc">     *  Overwrite Clock function and arg
</span>   771    <span class="xdoc">     *
</span>   772    <span class="xdoc">     *  Replaces a Clock object's clockFxn function originally
</span>   773    <span class="xdoc">     *  provided in {<b>@link</b> #create}.
</span>   774    <span class="xdoc">     *
</span>   775    <span class="xdoc">     *  <b>@param(clockFxn)</b>        function of type FuncPtr
</span>   776    <span class="xdoc">     *  <b>@param(arg)</b>             argument to clockFxn
</span>   777    <span class="xdoc">     *
</span>   778    <span class="xdoc">     *  <b>@a(constraints)</b>
</span>   779    <span class="xdoc">     *  Cannot change function and arg of Clock object that has been started.
</span>   780    <span class="xdoc">     */</span>
   781        @DirectCall
   782        Void setFunc(FuncPtr fxn, UArg arg);
   783    
   784        <span class="xdoc">/*!
</span>   785    <span class="xdoc">     *  ======== getPeriod ========
</span>   786    <span class="xdoc">     *  Get period of instance
</span>   787    <span class="xdoc">     *
</span>   788    <span class="xdoc">     *  Returns the period of an instance.
</span>   789    <span class="xdoc">     *
</span>   790    <span class="xdoc">     *  <b>@b(returns)</b>             returns periodic interval in Clock ticks
</span>   791    <span class="xdoc">     */</span>
   792        @DirectCall
   793        UInt32 getPeriod();
   794    
   795        <span class="xdoc">/*!
</span>   796    <span class="xdoc">     *  ======== getTimeout ========
</span>   797    <span class="xdoc">     *  Get timeout of instance
</span>   798    <span class="xdoc">     *
</span>   799    <span class="xdoc">     *  Returns the remaining time if instance has been started.
</span>   800    <span class="xdoc">     *
</span>   801    <span class="xdoc">     *  <b>@b(returns)</b>             returns timeout in clock ticks
</span>   802    <span class="xdoc">     */</span>
   803        @DirectCall
   804        UInt32 getTimeout();
   805    
   806        <span class="xdoc">/*!
</span>   807    <span class="xdoc">     *  ======== isActive ========
</span>   808    <span class="xdoc">     *  Determine if Clock object is currently active (ie running)
</span>   809    <span class="xdoc">     *
</span>   810    <span class="xdoc">     *  Returns TRUE if Clock object is currently active
</span>   811    <span class="xdoc">     *
</span>   812    <span class="xdoc">     *  <b>@b(returns)</b>             returns active state
</span>   813    <span class="xdoc">     */</span>
   814        @DirectCall
   815        Bool isActive();
   816    
   817    <span class=key>internal</span>:
   818    
   819        <span class="xdoc">/*!
</span>   820    <span class="xdoc">     *  ======== doTick ========
</span>   821    <span class="xdoc">     *  Function called by the timer interrupt handler
</span>   822    <span class="xdoc">     *
</span>   823    <span class="xdoc">     *  <b>@param(arg)</b>     Unused. Required to match signature of Hwi.FuncPtr
</span>   824    <span class="xdoc">     */</span>
   825        Void doTick(UArg arg);
   826    
   827        <span class="comment">/*
</span>   828    <span class="comment">     *  ======== Instance_State ========
</span>   829    <span class="comment">     */</span>
   830        <span class=key>struct</span> Instance_State {
   831            Queue.Elem      elem;           <span class=comment>// required for clock queue</span>
   832            UInt32          timeout;        <span class=comment>// in clock ticks</span>
   833            UInt32          currTimeout;    <span class=comment>// working timeout</span>
   834            UInt32          period;         <span class=comment>// periodic instance if &gt; 0</span>
   835            volatile Bool   active;         <span class=comment>// active/idle flag</span>
   836            FuncPtr         fxn;            <span class=comment>// instance function</span>
   837            UArg            arg;            <span class=comment>// function arg</span>
   838        };
   839    
   840        <span class="comment">/*
</span>   841    <span class="comment">     *  ======== Module_State ========
</span>   842    <span class="comment">     */</span>
   843        <span class=key>struct</span> Module_State {
   844            volatile UInt32 ticks;          <span class=comment>// ticks</span>
   845            UInt            swiCount;       <span class=comment>// num of Swi posts before Swi runs</span>
   846            Timer.Handle    timer;          <span class=comment>// timer used</span>
   847                                            <span class=comment>// points to generated Clock_doTick()</span>
   848            Queue.Object    clockQ;         <span class=comment>// clock que</span>
   849            Swi.Handle      swi;            <span class=comment>// clock swi</span>
   850            UInt32          periodCounts;   <span class=comment>// clock tick period in timer counts</span>
   851            volatile UInt   numTickSkip;    <span class=comment>// number of ticks being suppressed</span>
   852            UInt32          skipsWorkFunc;  <span class=comment>// new skips reg'd during workFunc</span>
   853            Bool            inWorkFunc;     <span class=comment>// true if in Clock Swi servicing Q</span>
   854        };
   855    }
</pre>
</body></html>
